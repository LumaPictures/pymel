from collections import *
from copy import *
from _typeshed import Incomplete
from collections.abc import Generator

useNetworkx: bool
networkxLoad: bool

def isSequence(x): ...
def isTree(x): ...
def isImmutableTree(x): ...
def isMutableTree(x): ...
def mutabletree(f): ...

class MetaTree(type):
    class PyTree:
        def __bool__(self) -> bool: ...
        def isElement(self): ...
        def hasChilds(self): ...
        def childs(self): ...
        def siblings(self): ...
        def __iter__(self): ...
        def __reduce__(self): ...
        def __eq__(self, other): ...
        def __ne__(self, other): ...
        def __contains__(self, element) -> bool: ...
        def issubtree(self, other): ...
        def __getitem__(self, value): ...
        def get(self, value, default=...): ...
        def remove(self, element) -> None: ...
        def __delitem__(self, element) -> None: ...
        def add(self, element, parent: Incomplete | None = ..., next: Incomplete | None = ...) -> None: ...
        def __cmp__(self, other): ...
        __le__: Incomplete
        __lt__: Incomplete
        __ge__: Incomplete
        __gt__: Incomplete
        def sort(self, *args) -> None: ...
        def __init__(self, *args, **kwargs) -> None: ...
    class IndexedPyTree:
        def elementKey(self, element) -> None: ...
        def __getitem__(self, value): ...
        def get(self, value, default=...): ...
    class NxTree: ...
    class ImTree:
        def preorder(self) -> Generator[Incomplete, None, None]: ...
        def postorder(self) -> Generator[Incomplete, None, None]: ...
        def breadth(self) -> Generator[Incomplete, None, None]: ...
        def child(self, index: int = ...): ...
        def parents(self) -> Generator[Incomplete, None, None]: ...
        def root(self): ...
        def tops(self) -> Generator[Incomplete, None, None]: ...
        def top(self, index: int = ...): ...
        def depth(self): ...
        def leaves(self) -> Generator[Incomplete, None, None]: ...
        def level(self, dist: int = ...) -> Generator[Incomplete, None, None]: ...
        def size(self): ...
        __len__ = size
        def height(self): ...
        def path(self, element: Incomplete | None = ..., **kwargs): ...
        def dist(self, element, **kwargs): ...
        def formatted(self, returnList: bool = ...): ...
        def view(self) -> None: ...
        def debug(self, depth: int = ...): ...
        def copy(self, cls: Incomplete | None = ...): ...
    class MuTree:
        def __setitem__(self, element, value) -> None: ...
        def graft(self, element, parent: Incomplete | None = ..., next: Incomplete | None = ...) -> None: ...
        def prune(self, element) -> None: ...
        def pop(self, element) -> None: ...
        def reroot(self, element) -> None: ...
    def __new__(mcl, classname, bases, classdict): ...
    TreeType: Incomplete

class FrozenTree:
    mutable: bool
    indexed: bool

class Tree:
    mutable: bool
    indexed: bool

class IndexedFrozenTree:
    mutable: bool
    indexed: bool

class IndexedTree:
    mutable: bool
    indexed: bool

def treeFromDict(childToParentDict): ...
def treeFromChildLink(isExactChildFn, *args): ...
def treeFromIsChild(isChildFn, *elements): ...
