import types
from _typeshed import Incomplete
from builtins import object
from collections import defaultdict as defaultdict
from future.utils import with_metaclass as with_metaclass
from typing import Any, Iterable, List, Optional, Tuple, Type, TypeVar, Union

TYPE_CHECKING: bool
T = TypeVar('T')

class Singleton(type):
    def __new__(mcl, classname, bases, classdict): ...

class metaStatic(Singleton):
    def __new__(mcl, classname, bases, classdict): ...

class defaultlist(list):
    default_factory: Incomplete
    def __init__(self, default_factory, *args, **kwargs) -> None: ...
    def __setitem__(self, index, item) -> None: ...
    def __getitem__(self, index): ...

class ModuleInterceptor:
    module: Incomplete
    callback: Incomplete
    def __init__(self, moduleName, callback) -> None: ...
    def __getattr__(self, attr): ...

def readonly(f): ...

class metaReadOnlyAttr(type):
    def __setattr__(cls, name, value) -> None: ...
    def __new__(mcl, classname, bases, classdict): ...

NOT_PROXY_WRAPPED: Incomplete

def proxyClass(cls, classname: str, dataAttrName: str = ..., dataFuncName: str = ..., remove: Iterable[str] = ..., makeDefaultInit: bool = ..., sourceIsImmutable: bool = ..., module: Any = ...) -> Type[T]: ...

class ProxyUnicode:
    def center(self, width: int, fillchar: str = ...) -> str: ...
    def endswith(self, suffix: Union[str, Tuple[str, ...]], start: int = ..., end: int = ...) -> bool: ...
    def find(self, sub: str, start: int = ..., end: int = ...) -> int: ...
    def format(self, *args: object, **kwargs: object) -> str: ...
    def isdecimal(self) -> bool: ...
    def isidentifier(self) -> bool: ...
    def islower(self) -> bool: ...
    def isnumeric(self) -> bool: ...
    def isprintable(self) -> bool: ...
    def isupper(self) -> bool: ...
    def join(self, iterable: Iterable[str]) -> str: ...
    def ljust(self, width: int, fillchar: str = ...) -> str: ...
    def lower(self) -> str: ...
    def lstrip(self, chars: str = ...) -> str: ...
    def partition(self, sep: str) -> Tuple[str, str, str]: ...
    def replace(self, old: str, new: str, count: int = ...) -> str: ...
    def rfind(self, sub: str, start: int = ..., end: int = ...) -> int: ...
    def rindex(self, sub: str, start: int = ..., end: int = ...) -> int: ...
    def rjust(self, width: int, fillchar: str = ...) -> str: ...
    def rpartition(self, sep: str) -> Tuple[str, str, str]: ...
    def rsplit(self, sep: Optional[str] = ..., maxsplit: int = ...) -> List[str]: ...
    def rstrip(self, chars: str = ...) -> str: ...
    def split(self, sep: Optional[str] = ..., maxsplit: int = ...) -> List[str]: ...
    def startswith(self, prefix: Union[str, Tuple[str, ...]], start: int = ..., end: int = ...) -> bool: ...
    def strip(self, chars: str = ...) -> str: ...
    def upper(self) -> str: ...
    def __add__(self, s: str) -> str: ...
    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...
    def __lt__(self, x: object) -> bool: ...
    def __le__(self, x: object) -> bool: ...
    def __gt__(self, x: object) -> bool: ...
    def __ge__(self, x: object) -> bool: ...

class universalmethod:
    f: Incomplete
    __doc__: Incomplete
    def __init__(self, f) -> None: ...
    def __get__(self, instance, cls: Incomplete | None = ...): ...

class LazyLoadModule(types.ModuleType):
    class LazyLoader:
        creator: Incomplete
        args: Incomplete
        kwargs: Incomplete
        name: Incomplete
        def __init__(self, name, creator, *creatorArgs, **creatorKwargs) -> None: ...
        newobj: Incomplete
        def __get__(self, obj, objtype): ...
    def __new__(cls, name, contents, autoSubClass: bool = ...): ...
    def __init__(self, name, contents, autoSubClass: bool = ...) -> None: ...
    def __dir__(self): ...
    def __setitem__(self, attr, args) -> None: ...
    def __getitem__(self, attr): ...

class LazyDocStringError(Exception): ...

class LazyDocString:
    documentedObj: Incomplete
    docGetter: Incomplete
    args: Incomplete
    kwargs: Incomplete
    def __init__(self, argList) -> None: ...

def makeMethod(name): ...
def addLazyDocString(obj, creator, *creatorArgs, **creatorKwargs) -> None: ...

class TwoWayDict(dict):
    def __init__(self, *args, **kwargs) -> None: ...
    def __setitem__(self, k, v) -> None: ...
    def has_value(self, v): ...
    def __delitem__(self, k) -> None: ...
    def clear(self) -> None: ...
    def copy(self): ...
    def pop(self, k): ...
    def popitem(self, **kws) -> None: ...
    def setdefault(self, **kws) -> None: ...
    def update(self, *args, **kwargs) -> None: ...
    def get_key(self, v): ...

class EquivalencePairs(TwoWayDict):
    def __setitem__(self, k, v) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __getitem__(self, key): ...
    def __contains__(self, key) -> bool: ...
    def get(self, key, d: Incomplete | None = ...): ...

def alias(origAttrName): ...

class propertycache:
    func: Incomplete
    name: Incomplete
    def __init__(self, func) -> None: ...
    def __get__(self, ownerInstance, ownerCls: Incomplete | None = ...): ...
