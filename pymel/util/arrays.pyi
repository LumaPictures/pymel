from typing import *
from . import mathutils as mathutils
from .arguments import clsname as clsname, isNumeric as isNumeric
from .mathutils import blend as blend, clamp as clamp, conjugate as conjugate, imag as imag, real as real, round as round
from .utilitytypes import metaReadOnlyAttr as metaReadOnlyAttr, readonly as readonly
from _typeshed import Incomplete
from math import exp as exp, pi as pi

def coerce(v1, v2): ...

eps: Incomplete

def patchMath(): ...
def sum(a, start: int = ..., axis: Incomplete | None = ...): ...
def prod(a, start: int = ..., axis: Incomplete | None = ...): ...
def any(a, axis: Incomplete | None = ...): ...
def all(a, axis: Incomplete | None = ...): ...
def min(*args, **kwargs): ...
def max(*args, **kwargs): ...
def sqlength(a, axis: Incomplete | None = ...): ...
def length(a, axis: Incomplete | None = ...): ...
def normal(a, axis: Incomplete | None = ...): ...
def dist(a, b, axis: Incomplete | None = ...): ...

class ArrayIter:
    base: Incomplete
    ndim: Incomplete
    size: Incomplete
    coords: Incomplete
    axis: Incomplete
    shape: Incomplete
    itemshape: Incomplete
    itemdim: Incomplete
    itemsize: Incomplete
    subsizes: Incomplete
    def __init__(self, data, *args) -> None: ...
    def __length_hint__(self) -> int: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __next__(self): ...
    def toArrayCoords(self, index, default: Incomplete | None = ...): ...
    def __getitem__(self, index): ...
    def __delitem__(self, index) -> None: ...
    def __setitem__(self, index, value) -> None: ...

class Array:
    __readonly__: Incomplete
    apicls = list
    shape: Incomplete
    ndim: Incomplete
    size: Incomplete
    data: Incomplete
    def assign(self, value): ...
    def get(self): ...
    def __new__(cls, *args, **kwargs): ...
    def __init__(self, *args, **kwargs) -> None: ...
    def filled(self, value: Incomplete | None = ...): ...
    def fill(self, value: Incomplete | None = ...) -> None: ...
    def appended(self, other, axis: int = ...): ...
    def append(self, other, axis: int = ...) -> None: ...
    def stacked(self, other, axis: int = ...): ...
    def stack(self, other, axis: int = ...) -> None: ...
    def hstacked(self, other): ...
    def hstack(self, other) -> None: ...
    def vstacked(self, other): ...
    def vstack(self, other) -> None: ...
    extended = vstacked
    extend = vstack
    def reshaped(self, shape: Incomplete | None = ...): ...
    def reshape(self, shape: Incomplete | None = ...) -> None: ...
    def resized(self, shape: Incomplete | None = ..., value: Incomplete | None = ...): ...
    def resize(self, shape: Incomplete | None = ..., value: Incomplete | None = ...) -> None: ...
    def fitted(self, other): ...
    def fit(self, other) -> None: ...
    def trimmed(self, shape: Incomplete | None = ..., value: Incomplete | None = ...): ...
    def trim(self, shape: Incomplete | None = ..., value: Incomplete | None = ...) -> None: ...
    def __reduce__(self): ...
    def __getnewargs__(self): ...
    def copy(self): ...
    def deepcopy(self): ...
    def formated(self): ...
    def __len__(self) -> int: ...
    def __getitem__(self, index): ...
    def __getslice__(self, start, end): ...
    def __setitem__(self, index, value) -> None: ...
    def __setslice__(self, start, end, value) -> None: ...
    def __delitem__(self, index) -> None: ...
    def __delslice__(self, start) -> None: ...
    def deleted(self, *args): ...
    def strip(self, *args) -> None: ...
    def stripped(self, *args): ...
    def __iter__(self, *args, **kwargs): ...
    def axisiter(self, *args): ...
    def subiter(self, dim: Incomplete | None = ...): ...
    @property
    def flat(self): ...
    def tolist(self): ...
    def totuple(self): ...
    __hash__: Incomplete
    def ravel(self): ...
    def __contains__(self, value) -> bool: ...
    def count(self, value): ...
    def index(self, value): ...
    def __coerce__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __neq__ = __ne__
    def __abs__(self): ...
    def __invert__(self): ...
    def __round__(self, ndigits: int = ...): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __iadd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __isub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __imul__(self, other): ...
    def __pow__(self, other, modulo: Incomplete | None = ...): ...
    def __rpow__(self, other): ...
    def __ipow__(self, other, modulo: Incomplete | None = ...): ...
    def __div__(self, other): ...
    def __rdiv__(self, other): ...
    def __idiv__(self, other): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __itruediv__(self, other): ...
    def __floordiv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __ifloordiv__(self, other): ...
    def __mod__(self, other): ...
    def __rmod__(self, other): ...
    def __imod__(self, other): ...
    def sum(self, *args, **kwargs): ...
    def prod(self, *args, **kwargs): ...
    def any(self, *args, **kwargs): ...
    def all(self, *args, **kwargs): ...
    def min(self, *args, **kwargs): ...
    def max(self, *args, **kwargs): ...
    def sqlength(self, *args): ...
    def length(self, *args): ...
    def normal(self, *args): ...
    def normalize(self, *args) -> None: ...
    def dist(self, other, *args): ...
    def distanceTo(self, other): ...
    def isEquivalent(self, other, tol=...): ...
    def transpose(self, *args): ...
    T: Incomplete
    def conjugate(self): ...
    def real(self): ...
    def imag(self): ...
    def blend(self, other, weight: float = ...): ...
    def clamp(self, low: int = ..., high: int = ...): ...

def det(value): ...
def inv(value): ...

class MatrixN(Array):
    ndim: int
    shape: Incomplete
    size: Incomplete
    def is_square(self): ...
    @classmethod
    def identity(cls, n): ...
    @classmethod
    def basis(cls, u, v, normalize: bool = ...): ...
    nrow: Incomplete
    ncol: Incomplete
    @property
    def row(self): ...
    @property
    def col(self): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __imul__(self, other): ...
    def diagonal(self, offset: int = ..., wrap: bool = ...): ...
    def trace(self, offset: int = ..., wrap: bool = ...): ...
    def minor(self, i, j): ...
    def cofactor(self, i, j): ...
    def adjugate(self): ...
    def gauss(self): ...
    def reduced(self): ...
    def det(self): ...
    def isSingular(self, tol=...): ...
    def inverse(self): ...
    inv = inverse
    I: Incomplete
    def linverse(self): ...
    def rinverse(self): ...

def cross(u, v): ...
def dot(u, v): ...
def outer(u, v): ...
def angle(a, b, c: Incomplete | None = ...): ...
def axis(a, b, c: Incomplete | None = ..., normalize: bool = ...): ...
def cotan(a, b, c: Incomplete | None = ...): ...

class VectorN(Array):
    ndim: int
    shape: Incomplete
    size: Incomplete
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __imul__(self, other): ...
    def __xor__(self, other): ...
    def __ixor__(self, other): ...
    def cross(self, other): ...
    def dot(self, other): ...
    def outer(self, other): ...
    def transformAsNormal(self, other): ...
    def sqlength(self) -> float: ...
    def length(self) -> float: ...
    def normal(self): ...
    unit = normal
    def isParallel(self, other, tol=...): ...
    def angle(self, other, third: Incomplete | None = ...): ...
    def axis(self, other, third: Incomplete | None = ..., normalize: bool = ...): ...
    def cotan(self, other, third: Incomplete | None = ...): ...
    def projectionOnto(self, other): ...
