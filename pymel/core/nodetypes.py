"""
Contains classes corresponding to the Maya type hierarchy, including `DependNode`, `Transform`, `Mesh`, and `Camera`.
"""
import sys
import os
import re
import inspect
import itertools
import math

import pymel.util as _util
import pymel.internal.pmcmds as cmds  # @UnresolvedImport
import pymel.internal.factories as _factories
import pymel.api as _api  # @UnresolvedImport
import pymel.internal.apicache as _apicache
import pymel.internal.pwarnings as _warnings
from pymel.internal import getLogger as _getLogger
from pymel.internal.startup import pymel_options as _pymel_options
import datatypes
_logger = _getLogger(__name__)

# to make sure Maya is up
import pymel.internal as internal
import pymel.versions as versions

from maya.cmds import about as _about
import maya.mel as mm

#from general import *
import animation
import effects
import general
import modeling
import other
import rendering
import system
import windows

from animation import listAnimatable as _listAnimatable
from system import namespaceInfo as _namespaceInfo, FileReference as _FileReference
from pymel.util.enum import Enum

if False:
    from typing import *

_thisModule = sys.modules[__name__]

_f = _factories

#__all__ = ['Component', 'MeshEdge', 'MeshVertex', 'MeshFace', 'Attribute', 'DependNode' ]

# Mesh Components

# If we're reloading, clear the pynode types out
_factories.clearPyNodeTypes()

# Dictionary mapping from maya node type names (ie, surfaceShape) to pymel
# class names, in this module - ie, SurfaceShape
mayaTypeNameToPymelTypeName = {}
pymelTypeNameToMayaTypeName = {}


def _addTypeNames():
    for name, obj in globals().items():
        if isinstance(obj, type) and issubclass(obj, DependNode):
            mayaTypeNameToPymelTypeName[obj.__melnode__] = name
            pymelTypeNameToMayaTypeName[name] = obj.__melnode__


class DependNode(general.PyNode):
    __apicls__ = _api.MFnDependencyNode
    __metaclass__ = _factories.MetaMayaTypeRegistry

    # ------------------------------
    #    Name Info and Manipulation
    # ------------------------------
#    def __new__(cls,name,create=False):
#        """
#        Provides the ability to create the object when creating a class
#
#            >>> n = pm.Transform("persp",create=True)
#            >>> n.__repr__()
#            # Result: nt.Transform(u'persp1')
#        """
#        if create:
#            ntype = cls.__melnode__
#            name = createNode(ntype,n=name,ss=1)
#        return general.PyNode.__new__(cls,name)

#    def __init__(self, *args, **kwargs ):
#        self.apicls.__init__(self, self._apiobject.object() )

    @_util.universalmethod
    def __melobject__(self):
        """Special method for returning a mel-friendly representation."""
        if isinstance(self, DependNode):
            # For instance, return the node's name...
            return self.name()
        else:
            # For the class itself, return the mel node name
            return self.__melnode__

    def __repr__(self):
        # type: () -> unicode
        """
        Returns
        -------
        unicode
        """
        return u"nt.%s(%r)" % (self.__class__.__name__, self.name())

    def _updateName(self):
        # test validity
        self.__apimobject__()
        self._name = self.__apimfn__().name()
        return self._name

    # TODO: unify handling of name parsing (perhaps around the name parser
    # classes?
    def name(self, update=True, stripNamespace=False, levels=0, long=False,
             stripUnderWorld=False):
        # type: (bool, bool, int, bool, bool) -> unicode
        '''The name of the node

        Returns
        -------
        unicode

        Parameters
        ----------
        update : bool
            if True, will always query to underlying maya object to get it's
            current name (and will therefore detect renames, re-parenting, etc);
            if False, it will use a cached value if available (which is slightly
            faster, but may be out of date)
        stripNamespace : bool
            if True, all nodes will have their namespaces stipped off of them
            (or a certain number of them, if levels is also used)
        levels : int
            if stripNamespace is True, then this number will determine the how
            many namespaces will be removed; if 0 (the default), then all
            leading namespaces will be removed; otherwise, this value gives the
            number of left-most levels to strip
        long : bool
            ignored; included simply to unify the interface between DependNode
            and DagNode, to make it easier to loop over lists of them
        stripUnderWorld : bool
            ignored; included simply to unify the interface between DependNode
            and DagNode, to make it easier to loop over lists of them


        Examples
        --------
        >>> import pymel.core as pm
        >>> pm.newFile(f=1)
        ''
        >>> node = pm.createNode('blinn')

        >>> pm.namespace(add='foo')
        u'foo'
        >>> pm.namespace(add='bar', parent='foo')
        u'foo:bar'
        >>> pm.namespace(add='stuff', parent='foo:bar')
        u'foo:bar:stuff'

        >>> node.rename(':foo:bar:stuff:blinn1')
        nt.Blinn(u'foo:bar:stuff:blinn1')

        >>> node.name()
        u'foo:bar:stuff:blinn1'
        >>> node.name(stripNamespace=True)
        u'blinn1'
        >>> node.name(stripNamespace=True, levels=1)
        u'bar:stuff:blinn1'
        >>> node.name(stripNamespace=True, levels=2)
        u'stuff:blinn1'
        '''
        if update or self._name is None:
            try:
                self._updateName()
            except general.MayaObjectError:
                general.DeletedMayaNodeError.handle(self)
        name = self._name
        if stripNamespace:
            if levels:
                spaceSplit = name.split(':')
                name = ':'.join(spaceSplit[min(len(spaceSplit) - 1, levels):])
            else:
                name = name.rsplit(':', 1)[-1]
        return name

    def namespace(self, root=False):
        # type: (bool) -> unicode
        """Returns the namespace of the object with trailing colon included.

        See `DependNode.parentNamespace` for a variant which does not include
        the trailing colon.

        Parameters
        ----------
        root : bool
            By default, if the object is in the root namespace, an empty string
            is returned; if root is True, ':' is returned in this case.

        Returns
        -------
        unicode
        """
        ns = self.parentNamespace()
        if ns or root:
            ns += ':'
        return ns

    def shortName(self, **kwargs):
        # type: (**Any) -> unicode
        """
        This produces the same results as `DependNode.name` and is included to
        simplify looping over lists of nodes that include both Dag and Depend
        nodes.

        Returns
        -------
        unicode
        """
        return self.name(**kwargs)

    def longName(self, **kwargs):
        # type: (**Any) -> unicode
        """
        This produces the same results as `DependNode.name` and is included to
        simplify looping over lists of nodes that include both Dag and Depend
        nodes.

        Returns
        -------
        unicode
        """
        return self.name(**kwargs)

    def nodeName(self, **kwargs):
        # type: (**Any) -> unicode
        """
        This produces the same results as `DependNode.name` and is included to
        simplify looping over lists of nodes that include both Dag and Depend
        nodes.

        Returns
        -------
        unicode
        """
        return self.name(**kwargs)

    #rename = rename
    def rename(self, name, **kwargs):
        # type: (Any, **Any) -> DependNode
        """
        Returns
        -------
        DependNode
        """
        # self.setName( name ) # no undo support

        # check for preserveNamespace a pymel unique flag
        if kwargs.pop('preserveNamespace', False):
            name = self.namespace(root=True) + name

        # ensure shortname
        if '|' in name:
            name = name.split('|')[-1]

        return general.rename(self, name, **kwargs)

    def __apiobject__(self):
        "get the default API object (MObject) for this node if it is valid"
        return self.__apimobject__()

    def __apimobject__(self):
        "get the ``maya.OpenMaya.MObject`` for this node if it is valid"
        handle = self.__apihandle__()
        if _api.isValidMObjectHandle(handle):
            return handle.object()
        raise general.MayaNodeError(self._name)

    def __apihandle__(self):
        "get the ``maya.OpenMaya.MObjectHandle`` for this node if it is valid"
        return self.__apiobjects__['MObjectHandle']

    def __str__(self):
        return "%s" % self.name()

    def __unicode__(self):
        return u"%s" % self.name()

    if versions.current() >= versions.v2009:
        def __hash__(self):
            return self.__apihandle__().hashCode()

    def node(self):
        # type: () -> DependNode
        """for compatibility with Attribute class

        Returns
        -------
        DependNode
        """
        return self

    # -------------------------
    #    Modification
    # -------------------------

    def lock(self, **kwargs):
        'lockNode -lock 1'
        #kwargs['lock'] = True
        # kwargs.pop('l',None)
        # return cmds.lockNode( self, **kwargs)
        return self.setLocked(True)

    def unlock(self, **kwargs):
        'lockNode -lock 0'
        #kwargs['lock'] = False
        # kwargs.pop('l',None)
        # return cmds.lockNode( self, **kwargs)
        return self.setLocked(False)

    def cast(self, swapNode, **kwargs):
        """nodeCast"""
        return cmds.nodeCast(self, swapNode, *kwargs)

    duplicate = general.duplicate

# -------------------------
# xxx{    Presets
# -------------------------

    def savePreset(self, presetName, custom=None, attributes=[]):

        kwargs = {'save': True}
        if attributes:
            kwargs['attributes'] = ' '.join(attributes)
        if custom:
            kwargs['custom'] = custom

        return cmds.nodePreset(presetName, **kwargs)

    def loadPreset(self, presetName):
        kwargs = {'load': True}
        return cmds.nodePreset(presetName, **kwargs)

    def deletePreset(self, presetName):
        kwargs = {'delete': True}
        return cmds.nodePreset(presetName, **kwargs)

    def listPresets(self):
        kwargs = {'list': True}
        return cmds.nodePreset(**kwargs)
#}

# -------------------------
# xxx{    Info
# -------------------------
    type = general.nodeType

    def referenceFile(self):
        # type: () -> Optional[_FileReference]
        """referenceQuery -file
        Return the reference file to which this object belongs.
        None if object is not referenced

        Returns
        -------
        Optional[_FileReference]
        """
        try:
            return _FileReference(cmds.referenceQuery(self, f=1))
        except RuntimeError:
            return None

    def classification(self, **kwargs):
        'getClassification'
        return general.getClassification(self.type(), **kwargs)
        # return self.__apimfn__().classification( self.type() )

#}
# -------------------------
# xxx{   Connections
# -------------------------

    def inputs(self, **kwargs):
        # type: (**Any) -> List[general.PyNode]
        """listConnections -source 1 -destination 0

        Returns
        -------
        List[general.PyNode]
        """
        kwargs['source'] = True
        kwargs.pop('s', None)
        kwargs['destination'] = False
        kwargs.pop('d', None)
        return general.listConnections(self, **kwargs)

    def outputs(self, **kwargs):
        # type: (**Any) -> List[general.PyNode]
        """listConnections -source 0 -destination 1

        Returns
        -------
        List[general.PyNode]
        """
        kwargs['source'] = False
        kwargs.pop('s', None)
        kwargs['destination'] = True
        kwargs.pop('d', None)

        return general.listConnections(self, **kwargs)

    def sources(self, **kwargs):
        # type: (**Any) -> List[general.PyNode]
        """listConnections -source 1 -destination 0

        Returns
        -------
        List[general.PyNode]
        """
        kwargs['source'] = True
        kwargs.pop('s', None)
        kwargs['destination'] = False
        kwargs.pop('d', None)
        return general.listConnections(self, **kwargs)

    def destinations(self, **kwargs):
        # type: (**Any) -> List[general.PyNode]
        """listConnections -source 0 -destination 1

        Returns
        -------
        List[general.PyNode]
        """
        kwargs['source'] = False
        kwargs.pop('s', None)
        kwargs['destination'] = True
        kwargs.pop('d', None)

        return general.listConnections(self, **kwargs)

    def shadingGroups(self):
        # type: () -> List[ShadingEngine]
        """list any shading groups in the future of this object - works for
        shading nodes, transforms, and shapes

        Also see listSets(type=1) - which returns which 'rendering sets' the
        object is a member of (and 'rendering sets' seem to consist only of
        shading groups), whereas this method searches the object's future for
        any nodes of type 'shadingEngine'.

        Returns
        -------
        List[ShadingEngine]
        """
        return self.future(type='shadingEngine')

#}
# -------------------------
# xxx{    Attributes
# -------------------------
    def __getattr__(self, attr):
        try:
            return getattr(super(general.PyNode, self), attr)
        except AttributeError:
            try:
                return DependNode.attr(self, attr)
            except general.MayaAttributeError, e:
                # since we're being called via __getattr__ we don't know whether the user was intending
                # to get a class method or a maya attribute, so we raise a more generic AttributeError
                raise AttributeError, "%r has no attribute or method named '%s'" % (self, attr)

    @_util.universalmethod
    def attrDefaults(obj, attr):  # @NoSelf
        """
        Access to an attribute of a node.  This does not require an instance:

            >>> nt.Transform.attrDefaults('tx').isKeyable()
            True

        but it can use one if needed ( for example, for dynamically created attributes )

            >>> nt.Transform(u'persp').attrDefaults('tx').isKeyable()

        Note: this is still experimental.
        """
        if inspect.isclass(obj):
            self = None
            cls = obj  # keep things familiar
        else:
            self = obj  # keep things familiar
            cls = type(obj)

        attributes = cls.__apiobjects__.setdefault('MFnAttributes', {})
        attrObj = attributes.get(attr, None)
        if not _api.isValidMObject(attrObj):
            def toAttrObj(apiObj):
                try:
                    attrObj = apiObj.attribute(attr)
                    if attrObj.isNull():
                        raise RuntimeError
                except RuntimeError:
                    # just try it first, then check if it has the attribute if
                    # we errored (as opposed to always check first if the node
                    # has the attribute), on the assumption that this will be
                    # "faster" for most cases, where the node actually DOES have
                    # the attribute...
                    if not apiObj.hasAttribute(attr):
                        raise general.MayaAttributeError('%s.%s' % (cls.__melnode__, attr))
                    else:
                        # don't know why we got this error, so just reraise
                        raise
                return attrObj

            if self is None:
                if hasattr(_api, 'MNodeClass'):
                    # Yay, we have MNodeClass, use it!
                    nodeCls = _api.MNodeClass(cls.__melnode__)
                    attrObj = toAttrObj(nodeCls)
                else:
                    # We don't have an instance of the node, we need
                    # to make a ghost one...
                    with _apicache._GhostObjMaker(cls.__melnode__) as nodeObj:
                        if nodeObj is None:
                            # for instance, we get this if we have an abstract class...
                            raise RuntimeError("Unable to get attribute defaults for abstract node class %s, in versions prior to 2012" % cls.__melnode__)
                        nodeMfn = cls.__apicls__(nodeObj)
                        attrObj = toAttrObj(nodeMfn)
            else:
                nodeMfn = self.__apimfn__()
                attrObj = toAttrObj(nodeMfn)
            attributes[attr] = attrObj
        return general.AttributeDefaults(attrObj)

    def attr(self, attr):
        # type: (Any) -> general.Attribute
        """
        access to attribute plug of a node. returns an instance of the Attribute class for the
        given attribute name.

        Returns
        -------
        general.Attribute
        """
        return self._attr(attr, False)

    # Just have this alias because it will sometimes return attributes for an
    # underlying shape, which we may want for DagNode.attr, but don't want for
    # DependNode.attr (and using the on-shape result, instead of throwing it
    # away and then finding it again on the shape, saves time for the DagNode
    # case)
    def _attr(self, attr, allowOtherNode):
        # return Attribute( '%s.%s' % (self, attr) )
        try:
            if '.' in attr or '[' in attr:
                # Compound or Multi Attribute
                # there are a couple of different ways we can proceed:
                # Option 1: back out to _api.toApiObject (via general.PyNode)
                # return Attribute( self.__apiobject__(), self.name() + '.' + attr )

                # Option 2: nameparse.
                # this avoids calling self.name(), which can be slow
                import pymel.util.nameparse as nameparse
                nameTokens = nameparse.getBasicPartList('dummy.' + attr)
                result = self.__apiobject__()
                for token in nameTokens[1:]:  # skip the first, bc it's the node, which we already have
                    if isinstance(token, nameparse.MayaName):
                        if isinstance(result, _api.MPlug):
                            # you can't get a child plug from a multi/array plug.
                            # if result is currently 'defaultLightList1.lightDataArray' (an array)
                            # and we're trying to get the next plug, 'lightDirection', then we need a dummy index.
                            # the following line will reuslt in 'defaultLightList1.lightDataArray[-1].lightDirection'
                            if result.isArray():
                                result = self.__apimfn__().findPlug(unicode(token))
                            else:
                                result = result.child(self.__apimfn__().attribute(unicode(token)))
                        else:  # Node
                            result = self.__apimfn__().findPlug(unicode(token))
#                                # search children for the attribute to simulate  cam.focalLength --> perspShape.focalLength
#                                except TypeError:
#                                    for i in range(fn.childCount()):
#                                        try: result = _api.MFnDagNode( fn.child(i) ).findPlug( unicode(token) )
#                                        except TypeError: pass
#                                        else:break
                    if isinstance(token, nameparse.NameIndex):
                        if token.value != -1:
                            result = result.elementByLogicalIndex(token.value)
                plug = result
            else:
                try:
                    plug = self.__apimfn__().findPlug(attr, False)
                except RuntimeError:
                    # Don't use .findAlias, as it always returns the 'base'
                    # attribute - ie, if the alias is to foo[0].bar, it will
                    # just point to foo
                    # aliases
                    #obj = _api.MObject()
                    #self.__apimfn__().findAlias( attr, obj )
                    #plug = self.__apimfn__().findPlug( obj, False )

                    # the following technique gets aliased attributes as well. turning dagPlugs to off saves time because we already
                    # know the dagNode. however, certain attributes, such as rotatePivot, are detected as components,
                    # despite the fact that findPlug finds them as MPlugs. need to look into this
                    # TODO: test speed versus above method
                    try:
                        plug = _api.toApiObject(self.name() + '.' + attr, dagPlugs=False)
                    except RuntimeError:
                        raise
                    if not isinstance(plug, _api.MPlug):
                        raise RuntimeError

                if not (allowOtherNode or plug.node() == self.__apimobject__()):
                    # we could have gotten an attribute on a shape object,
                    # which we don't want
                    raise RuntimeError
            return general.Attribute(self.__apiobject__(), plug)

        except RuntimeError:
            # raise our own MayaAttributeError, which subclasses AttributeError and MayaObjectError
            raise general.MayaAttributeError('%s.%s' % (self, attr))

    hasAttr = general.hasAttr

    @_factories.addMelDocs('setAttr')
    def setAttr(self, attr, *args, **kwargs):
        # for now, using strings is better, because there is no MPlug support
        return general.setAttr("%s.%s" % (self, attr), *args, **kwargs)

    @_factories.addMelDocs('setAttr')
    def setDynamicAttr(self, attr, *args, **kwargs):
        """
        same as `DependNode.setAttr` with the force flag set to True.  This causes
        the attribute to be created based on the passed input value.
        """

        # for now, using strings is better, because there is no MPlug support
        kwargs['force'] = True
        return general.setAttr("%s.%s" % (self, attr), *args, **kwargs)

    @_factories.addMelDocs('getAttr')
    def getAttr(self, attr, *args, **kwargs):
        # for now, using strings is better, because there is no MPlug support
        return general.getAttr("%s.%s" % (self, attr), *args, **kwargs)

    @_factories.addMelDocs('addAttr')
    def addAttr(self, attr, **kwargs):
        # for now, using strings is better, because there is no MPlug support
        assert 'longName' not in kwargs and 'ln' not in kwargs
        kwargs['longName'] = attr
        return general.addAttr(unicode(self), **kwargs)

    @_factories.addMelDocs('deleteAttr')
    def deleteAttr(self, attr, *args, **kwargs):
        # for now, using strings is better, because there is no MPlug support
        return general.deleteAttr("%s.%s" % (self, attr), *args, **kwargs)

    @_factories.addMelDocs('connectAttr')
    def connectAttr(self, attr, destination, **kwargs):
        # for now, using strings is better, because there is no MPlug support
        return general.connectAttr("%s.%s" % (self, attr), destination, **kwargs)

    @_factories.addMelDocs('disconnectAttr')
    def disconnectAttr(self, attr, destination=None, **kwargs):
        # for now, using strings is better, because there is no MPlug support
        return general.disconnectAttr("%s.%s" % (self, attr), destination, **kwargs)

    listAnimatable = _listAnimatable

    def listAttr(self, **kwargs):
        # type: (**Any) -> List[general.Attribute]
        """
        listAttr

        Modifications:
          - returns an empty list when the result is None
          - added 'alias' keyword to list attributes that have aliases
          - added 'topLevel' keyword to only return attributes that are not
            compound children; may not be used in combination with
            'descendants'
          - added 'descendants' keyword to return all top-level attributes
            and all their descendants; note that the standard call may return
            some attributes that 'descendants' will not, if there are compound
            multi attributes with no existing indices; ie, the standard call
            might return "node.parentAttr[-1].childAttr", but the 'descendants'
            version would only return childAttr if an index exists for
            parentAttr, ie "node.parentAttr[0].childAttr"; may not be used in
            combination with 'topLevel'

        Returns
        -------
        List[general.Attribute]
        """
        topLevel = kwargs.pop('topLevel', False)
        descendants = kwargs.pop('descendants', False)
        if descendants:
            if topLevel:
                raise ValueError("may not specify both topLevel and descendants")
            # get the topLevel ones, then aggregate all the descendants...
            topChildren = self.listAttr(topLevel=True, **kwargs)
            res = list(topChildren)
            for child in topChildren:
                res.extend(child.iterDescendants())
            return res

        alias = kwargs.pop('alias', False)
        # stringify fix
        res = [self.attr(x) for x in _util.listForNone(cmds.listAttr(self.name(), **kwargs))]
        if alias:
            # need to make sure that our alias wasn't filtered out by one of
            # the other kwargs (keyable, etc)...
            # HOWEVER, we can't just do a straight up check to see if the
            # results of listAlias() are in res - because the attributes in
            # res are index-less (ie, ,myAttr[-1]), while the results returned
            # by listAliases() have indices (ie, .myAttr[25])... so instead we
            # just do a comparison of the names (which are easily hashable)
            res = set(x.attrName() for x in res)
            res = [x[1] for x in self.listAliases() if x[1].attrName() in res]
        if topLevel:
            res = [x for x in res if x.getParent() is None]
        return res

    def listAliases(self):
        # type: () -> List[Tuple[str, general.Attribute]]
        """
        aliasAttr

        Modifications:
          - returns an empty list when the result is None
          - when queried, returns a list of (alias, `Attribute`) pairs.

        Returns
        -------
        List[Tuple[str, general.Attribute]]
        """

        #tmp = _util.listForNone(cmds.aliasAttr(self.name(),query=True))
        tmp = []
        self.__apimfn__().getAliasList(tmp)
        res = []
        for i in range(0, len(tmp), 2):
            res.append((tmp[i], general.Attribute(self.node() + '.' + tmp[i + 1])))
        return res

    def attrInfo(self, **kwargs):
        # type: (**Any) -> List[general.Attribute]
        """attributeInfo

        Returns
        -------
        List[general.Attribute]
        """
        # stringify fix
        return [self.attr(x) for x
                in _util.listForNone(cmds.attributeInfo(self.name(), **kwargs))]


#}
# ----------------------------------------
# xxx{ Name Info and Manipulation
# ----------------------------------------

# Now just wraps NameParser functions

    def stripNum(self):
        # type: () -> unicode
        """
        Return the name of the node with trailing numbers stripped off.

        If no trailing numbers are found the name will be returned unchanged.

        >>> from pymel.core import *
        >>> SCENE.lambert1.stripNum()
        u'lambert'

        Returns
        -------
        unicode
        """
        return other.NameParser(self).stripNum()

    def extractNum(self):
        # type: () -> unicode
        """
        Return the trailing numbers of the node name.

        If no trailing numbers are found an error will be raised.

        >>> from pymel.core import *
        >>> SCENE.lambert1.extractNum()
        u'1'

        Returns
        -------
        unicode
        """
        return other.NameParser(self).extractNum()

    def nextUniqueName(self):
        # type: () -> unicode
        """
        Increment the trailing number of the object until a unique name is
        found.

        If there is no trailing number, appends '1' to the name.

        Returns
        -------
        unicode
        """
        return other.NameParser(self).nextUniqueName()

    def nextName(self):
        # type: () -> unicode
        """
        Increment the trailing number of the object by 1

        Raises an error if the name has no trailing number.

        >>> from pymel.core import *
        >>> SCENE.lambert1.nextName()
        DependNodeName(u'lambert2')

        Returns
        -------
        unicode
        """
        return other.NameParser(self).nextName()

    def prevName(self):
        # type: () -> unicode
        """
        Decrement the trailing number of the object by 1

        Raises an error if the name has no trailing number.

        Returns
        -------
        unicode
        """
        return other.NameParser(self).prevName()

    @classmethod
    def registerVirtualSubClass(cls, nameRequired=False):
        """
        Deprecated
        """
        _factories.registerVirtualClass(cls, nameRequired)
# ------ Do not edit below this line --------
    __melnode__ = 'dependNode'
    __slots__ = ()
    MAttrClass = Enum('MAttrClass', {'localDynamicAttr': 1, 'kLocalDynamicAttr': 1, 'kNormalAttr': 2, 'normalAttr': 2, 'kExtensionAttr': 3, 'extensionAttr': 3, 'kInvalidAttr': 4, 'invalidAttr': 4}, multiKeys=True, defaultKeys={1: 'localDynamicAttr', 2: 'normalAttr', 3: 'extensionAttr', 4: 'invalidAttr'})
    MdgTimerMetric = Enum('MdgTimerMetric', {'kTimerMetric_callback': 0, 'metric_callback': 0, 'metric_compute': 1, 'kTimerMetric_compute': 1, 'kTimerMetric_dirty': 2, 'metric_dirty': 2, 'metric_draw': 3, 'kTimerMetric_draw': 3, 'kTimerMetric_fetch': 4, 'metric_fetch': 4, 'kTimerMetric_callbackViaAPI': 5, 'metric_callbackViaAPI': 5, 'metric_callbackNotViaAPI': 6, 'kTimerMetric_callbackNotViaAPI': 6, 'kTimerMetric_computeDuringCallback': 7, 'metric_computeDuringCallback': 7, 'metric_computeNotDuringCallback': 8, 'kTimerMetric_computeNotDuringCallback': 8, 'kTimerMetrics': 9, 'metrics': 9}, multiKeys=True, defaultKeys={0: 'metric_callback', 1: 'metric_compute', 2: 'metric_dirty', 3: 'metric_draw', 4: 'metric_fetch', 5: 'metric_callbackViaAPI', 6: 'metric_callbackNotViaAPI', 7: 'metric_computeDuringCallback', 8: 'metric_computeNotDuringCallback', 9: 'metrics'})
    MdgTimerState = Enum('MdgTimerState', {'off': 0, 'kTimerOff': 0, 'on': 1, 'kTimerOn': 1, 'uninitialized': 2, 'kTimerUninitialized': 2, 'invalidState': 3, 'kTimerInvalidState': 3}, multiKeys=True, defaultKeys={0: 'off', 1: 'on', 2: 'uninitialized', 3: 'invalidState'})
    MdgTimerType = Enum('MdgTimerType', {'type_self': 0, 'kTimerType_self': 0, 'type_inclusive': 1, 'kTimerType_inclusive': 1, 'type_count': 2, 'kTimerType_count': 2, 'kTimerTypes': 3, 'types': 3}, multiKeys=True, defaultKeys={0: 'type_self', 1: 'type_inclusive', 2: 'type_count', 3: 'types'})

    @_f.deprecated
    def addAttribute(self, attr):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([attr], [('attr', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'addAttribute', final_do)
        return res

    @classmethod
    @_f.deprecated
    def allocateFlag(self, pluginName):
        # type: (unicode) -> int
        do, final_do, outTypes = _f.getDoArgs([pluginName], [('pluginName', 'MString', 'in', None)])
        res = _api.MFnDependencyNode.allocateFlag(*final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.deprecated
    def attribute(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'attribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.deprecated
    def attributeClass(self, attribute):
        # type: (general.PyNode) -> DependencyNode.MAttrClass
        do, final_do, outTypes = _f.getDoArgs([attribute], [('attribute', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'attributeClass', final_do)
        res = _f.ApiArgUtil._castResult(self, res, ('MFnDependencyNode', 'MAttrClass'), None)
        return res

    @_f.addApiDocs(_api.MFnDependencyNode, 'attributeCount')
    def attributeCount(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'attributeCount')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'canBeWritten')
    def canBeWritten(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'canBeWritten')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @classmethod
    @_f.deprecated
    def deallocateAllFlags(self, pluginName):
        # type: (unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([pluginName], [('pluginName', 'MString', 'in', None)])
        res = _api.MFnDependencyNode.deallocateAllFlags(*final_do)
        return res

    @classmethod
    @_f.deprecated
    def deallocateFlag(self, pluginName, flag):
        # type: (unicode, int) -> None
        do, final_do, outTypes = _f.getDoArgs([pluginName, flag], [('pluginName', 'MString', 'in', None), ('flag', 'uint', 'in', None)])
        res = _api.MFnDependencyNode.deallocateFlag(*final_do)
        return res

    @_f.deprecated
    def dgCallbacks(self, timerType, callbackName, value):
        # type: (DependencyNode.MdgTimerType, List[unicode], List[float]) -> None
        do, final_do, outTypes = _f.getDoArgs([timerType, callbackName, value], [('timerType', ('MFnDependencyNode', 'MdgTimerType'), 'in', None), ('callbackName', 'MStringArray', 'in', None), ('value', 'MDoubleArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'dgCallbacks', final_do)
        return res

    @_f.deprecated
    def dgTimer(self, timerMetric, timerType):
        # type: (DependencyNode.MdgTimerMetric, DependencyNode.MdgTimerType) -> float
        do, final_do, outTypes = _f.getDoArgs([timerMetric, timerType], [('timerMetric', ('MFnDependencyNode', 'MdgTimerMetric'), 'in', None), ('timerType', ('MFnDependencyNode', 'MdgTimerType'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'dgTimer', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.deprecated
    def dgTimerOff(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'dgTimerOff')
        return res

    @_f.deprecated
    def dgTimerOn(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'dgTimerOn')
        return res

    @_f.deprecated
    def dgTimerQueryState(self):
        # type: () -> DependencyNode.MdgTimerState
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'dgTimerQueryState')
        return _f.ApiArgUtil._castResult(self, res, ('MFnDependencyNode', 'MdgTimerState'), None)

    @_f.deprecated
    def dgTimerReset(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'dgTimerReset')
        return res

    @classmethod
    @_f.addApiDocs(_api.MFnDependencyNode, 'enableDGTiming')
    def enableDGTiming(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.getDoArgs([enable], [('enable', 'bool', 'in', None)])
        res = _api.MFnDependencyNode.enableDGTiming(*final_do)
        return res

    @_f.deprecated
    def findAlias(self, alias):
        # type: (unicode) -> Tuple[bool, general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([alias], [('alias', 'MString', 'in', None), ('attrObj', 'MObject', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'findAlias', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def findPlug(self, attr, wantNetworkedPlug):
        # type: (general.PyNode, bool) -> Attribute
        do, final_do, outTypes = _f.getDoArgs([attr, wantNetworkedPlug], [('attr', 'MObject', 'in', None), ('wantNetworkedPlug', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'findPlug', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPlug', None)
        return res

    @_f.deprecated
    def getAffectedAttributes(self, attr):
        # type: (general.PyNode) -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([attr], [('attr', 'MObject', 'in', None), ('affectedAttributes', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'getAffectedAttributes', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def getAffectedByAttributes(self, attr):
        # type: (general.PyNode) -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([attr], [('attr', 'MObject', 'in', None), ('affectedByAttributes', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'getAffectedByAttributes', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def getAliasAttr(self, force):
        # type: (bool) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([force], [('force', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'getAliasAttr', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.deprecated
    def getAliasList(self):
        # type: () -> Tuple[bool, List[unicode]]
        do, final_do, outTypes = _f.getDoArgs([], [('strArray', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'getAliasList', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def getConnections(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('array', 'MPlugArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'getConnections', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnDependencyNode, 'icon')
    def getIcon(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'icon')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'name')
    def getName(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'name')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.deprecated
    def hasAttribute(self, attrName):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([attrName], [('attrName', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'hasAttribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.deprecated
    def hasUniqueName(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'hasUniqueName')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'isDefaultNode')
    def isDefaultNode(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'isDefaultNode')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'isFlagSet')
    def isFlagSet(self, flag):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([flag], [('flag', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'isFlagSet', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.deprecated
    def isFromReferencedFile(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'isFromReferencedFile')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'isLocked')
    def isLocked(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'isLocked')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.deprecated
    def isNewAttribute(self, attr):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([attr], [('attr', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'isNewAttribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnDependencyNode, 'isFromReferencedFile')
    def isReferenced(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'isFromReferencedFile')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)
    isReadOnly = isReferenced

    @_f.addApiDocs(_api.MFnDependencyNode, 'isShared')
    def isShared(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'isShared')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'isTrackingEdits')
    def isTrackingEdits(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'isTrackingEdits')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'hasUniqueName')
    def isUniquelyNamed(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'hasUniqueName')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'parentNamespace')
    def parentNamespace(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'parentNamespace')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.addApiDocs(_api.MFnDependencyNode, 'pluginName')
    def pluginName(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'pluginName')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.deprecated
    def plugsAlias(self, plug):
        # type: (Attribute) -> unicode
        do, final_do, outTypes = _f.getDoArgs([plug], [('plug', 'MPlug', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'plugsAlias', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.deprecated
    def removeAttribute(self, attribute):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([attribute], [('attribute', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'removeAttribute', final_do)
        return res

    @_f.deprecated
    def reorderedAttribute(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'reorderedAttribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.deprecated
    def setAlias(self, alias, name, plug, add=True):
        # type: (unicode, unicode, Attribute, bool) -> bool
        do, final_do, outTypes = _f.getDoArgs([alias, name, plug, add], [('alias', 'MString', 'in', None), ('name', 'MString', 'in', None), ('plug', 'MPlug', 'in', None), ('add', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'setAlias', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnDependencyNode, 'setDoNotWrite')
    def setDoNotWrite(self, flag):
        # type: (bool) -> None
        do, final_do, outTypes = _f.getDoArgs([flag], [('flag', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'setDoNotWrite', final_do)
        return res

    @_f.deprecated
    def setFlag(self, flag, state):
        # type: (int, bool) -> None
        do, final_do, outTypes = _f.getDoArgs([flag, state], [('flag', 'uint', 'in', None), ('state', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'setFlag', final_do)
        return res

    @_f.addApiDocs(_api.MFnDependencyNode, 'setIcon')
    def setIcon(self, filename):
        # type: (unicode) -> None
        do, final_do, outTypes = _f.processApiArgs([filename], [('filename', 'MString', 'in', None)], self.getIcon, self.setIcon, [])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'setIcon', final_do)
        return res

    @_f.addApiDocs(_api.MFnDependencyNode, 'setLocked')
    def setLocked(self, lock):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([lock], [('lock', 'bool', 'in', None)], self.isLocked, self.setLocked, [])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'setLocked', final_do)
        return res

    @_f.addApiDocs(_api.MFnDependencyNode, 'setName')
    def setName(self, name, createNamespace=False):
        # type: (unicode, bool) -> unicode
        do, final_do, outTypes = _f.processApiArgs([name, createNamespace], [('name', 'MString', 'in', None), ('createNamespace', 'bool', 'in', None)], self.getName, self.setName, [])
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'setName', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.deprecated
    def typeName(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnDependencyNode, 'typeName')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)
# ------ Do not edit above this line --------


class ContainerBase(DependNode):
    pass
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnContainerNode
    __melnode__ = u'containerBase'
    __slots__ = ()
    MPublishNodeType = Enum('MPublishNodeType', {'parentAnchor': 0, 'kParentAnchor': 0, 'childAnchor': 1, 'kChildAnchor': 1, 'generic': 2, 'kGeneric': 2}, multiKeys=True, defaultKeys={0: 'parentAnchor', 1: 'childAnchor', 2: 'generic'})

    @_f.addApiDocs(_api.MFnContainerNode, 'getMembers')
    def getMembers(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('members', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnContainerNode, 'getMembers', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnContainerNode, 'getParentContainer')
    def getParentContainer(self):
        # type: () -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([], [('parent', 'MObject', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnContainerNode, 'getParentContainer', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnContainerNode, 'getPublishedNames')
    def getPublishedNames(self, unboundOnly):
        # type: (bool) -> List[unicode]
        do, final_do, outTypes = _f.getDoArgs([unboundOnly], [('publishedNames', 'MStringArray', 'out', None), ('unboundOnly', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnContainerNode, 'getPublishedNames', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnContainerNode, 'getPublishedNodes')
    def getPublishedNodes(self, type):
        # type: (ContainerNode.MPublishNodeType) -> Tuple[List[unicode], List[general.PyNode]]
        do, final_do, outTypes = _f.getDoArgs([type], [('type', ('MFnContainerNode', 'MPublishNodeType'), 'in', None), ('publishedNames', 'MStringArray', 'out', None), ('nodes', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnContainerNode, 'getPublishedNodes', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnContainerNode, 'getPublishedPlugs')
    def getPublishedPlugs(self):
        # type: () -> Tuple[List[general.PyNode], List[unicode]]
        do, final_do, outTypes = _f.getDoArgs([], [('publishedPlugs', 'MPlugArray', 'out', None), ('publishedNames', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnContainerNode, 'getPublishedPlugs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnContainerNode, 'getRootTransform')
    def getRootTransform(self):
        # type: () -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([], [('root', 'MObject', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnContainerNode, 'getRootTransform', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnContainerNode, 'getSubcontainers')
    def getSubcontainers(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('subcontainers', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnContainerNode, 'getSubcontainers', final_do)
        return _f.processApiResult(res, outTypes, do)
# ------ Do not edit above this line --------


class Entity(ContainerBase):
    pass
# ------ Do not edit below this line --------
    __melnode__ = u'entity'
    __slots__ = ()
# ------ Do not edit above this line --------


class DagNode(Entity):

    #:group Path Info and Modification: ``*parent*``, ``*Parent*``, ``*child*``, ``*Child*``
    """
    """

    __apicls__ = _api.MFnDagNode

#    def __init__(self, *args, **kwargs ):
#        self.apicls.__init__(self, self.__apimdagpath__() )
    _componentAttributes = {}

    def comp(self, compName):
        # type: (Any) -> general.Component
        """
        Will retrieve a Component object for this node; similar to
        DependNode.attr(), but for components.

        Returns
        -------
        general.Component
        """
        if compName in self._componentAttributes:
            compClass = self._componentAttributes[compName]
            if isinstance(compClass, tuple):
                # We have something like:
                # 'uIsoparm'    : (NurbsSurfaceIsoparm, 'u')
                # need to specify what 'flavor' of the basic
                # component we need...
                return compClass[0](self, {compClass[1]: general.ComponentIndex(label=compClass[1])})
            else:
                return compClass(self)
        # if we do self.getShape(), and this is a shape node, we will
        # enter a recursive loop if compName isn't actually a comp:
        # since shape doesn't have 'getShape', it will call __getattr__
        # for 'getShape', which in turn call comp to check if it's a comp,
        # which will call __getattr__, etc
        # ..soo... check if we have a 'getShape'!
        # ...also, don't use 'hasattr', as this will also call __getattr__!
        try:
            object.__getattribute__(self, 'getShape')
        except AttributeError:
            raise general.MayaComponentError('%s.%s' % (self, compName))
        else:
            shape = self.getShape()
            if shape:
                return shape.comp(compName)

    def listComp(self, names=False):
        # type: (bool) -> None
        """Will return a list of all component objects for this object

        Is to .comp() what .listAttr() is to .attr(); will NOT check the shape
        node.

        Parameters
        ----------
        names : bool
            By default, will return a list of actual usabale pymel Component
            objects; if you just want a list of string names which would
            be compatible with .comp(), set names to True
        """
        keys = sorted(self._componentAttributes.keys())
        if names:
            return keys

        compTypes = set()
        comps = []
        # use the sorted keys, so the order matches that returned by names,
        # minus duplicate entries for aliases
        for name in keys:
            compType = self._componentAttributes[name]
            if compType not in compTypes:
                compTypes.add(compType)
                comps.append(self.comp(name))
        return comps

    def _updateName(self, long=False):
        # if _api.isValidMObjectHandle(self._apiobject) :
            #obj = self._apiobject.object()
            #dagFn = _api.MFnDagNode(obj)
            #dagPath = _api.MDagPath()
            # dagFn.getPath(dagPath)
        dag = self.__apimdagpath__()
        if dag:
            name = dag.partialPathName()
            if not name:
                raise general.MayaNodeError

            self._name = name
            if long:
                return dag.fullPathName()

        return self._name

    # TODO: unify handling of name parsing (perhaps around the name parser
    # classes?
    # TODO: support for underworld nodes
    def name(self, update=True, long=False, stripNamespace=False, levels=0,
             stripUnderWorld=False):
        # type: (bool, Optional[bool], bool, int, bool) -> unicode
        '''The name of the node

        Parameters
        ----------
        update : bool
            if True, will always query to underlying maya object to get it's
            current name (and will therefore detect renames, re-parenting, etc);
            if False, it will use a cached value if available (which is slightly
            faster, but may be out of date)
        long : Optional[bool]
            if True, will include always include the full dag path, starting
            from the world root, including leading pipe ( | ); if False, will
            return the shortest-unique path; if None, node names will always be
            returned without any parents, if if they are not unique
        stripNamespace : bool
            if True, all nodes will have their namespaces stipped off of them
            (or a certain number of them, if levels is also used)
        levels : int
            if stripNamespace is True, then this number will determine the how
            many namespaces will be removed; if 0 (the default), then all
            leading namespaces will be removed; otherwise, this value gives the
            number of left-most levels to strip
        stripUnderWorld : bool
            if stripUnderWorld is True, and the name has underworld components
            (ie, topNode|topNodeShape->underWorld|underWorldShape), then only
            the portion in the "deepest underworld" is returned (ie,
            underWorld|underWorldShape)


        Returns
        -------
        unicode


        Examples
        --------
        >>> import pymel.core as pm
        >>> pm.newFile(f=1)
        ''
        >>> cube1 = pm.polyCube()[0]
        >>> cube2 = pm.polyCube()[0]
        >>> cube3 = pm.polyCube()[0]
        >>> cube3Shape = cube3.getShape()

        >>> cube2.setParent(cube1)
        nt.Transform(u'pCube2')
        >>> cube3.setParent(cube2)
        nt.Transform(u'pCube3')

        >>> pm.namespace(add='foo')
        u'foo'
        >>> pm.namespace(add='bar', parent='foo')
        u'foo:bar'
        >>> pm.namespace(add='stuff', parent='foo:bar')
        u'foo:bar:stuff'

        >>> cube2.rename(':foo:pCube2')
        nt.Transform(u'foo:pCube2')
        >>> cube3.rename(':foo:bar:pCube3')
        nt.Transform(u'foo:bar:pCube3')
        >>> cube3Shape.rename(':foo:bar:stuff:pCubeShape3')
        nt.Mesh(u'foo:bar:stuff:pCubeShape3')

        >>> cube3Shape.name()
        u'foo:bar:stuff:pCubeShape3'
        >>> cube3Shape.name(stripNamespace=True)
        u'pCubeShape3'
        >>> cube3Shape.name(long=True)
        u'|pCube1|foo:pCube2|foo:bar:pCube3|foo:bar:stuff:pCubeShape3'
        >>> cube3Shape.name(long=True, stripNamespace=True)
        u'|pCube1|pCube2|pCube3|pCubeShape3'
        >>> cube3Shape.name(long=True, stripNamespace=True, levels=1)
        u'|pCube1|pCube2|bar:pCube3|bar:stuff:pCubeShape3'
        >>> cube3Shape.name(long=True, stripNamespace=True, levels=2)
        u'|pCube1|pCube2|pCube3|stuff:pCubeShape3'

        >>> cam = pm.camera()[0]
        >>> cam.setParent(cube2)
        nt.Transform(u'camera1')
        >>> imagePlane = pm.imagePlane(camera=cam.getShape())[1]
        >>> imagePlane.rename('foo:bar:stuff:imagePlaneShape1')
        nt.ImagePlane(u'cameraShape1->foo:bar:stuff:imagePlaneShape1')

        >>> imagePlane.name()
        u'cameraShape1->foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.name(stripUnderWorld=True)
        u'foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.name(stripNamespace=True, levels=1)
        u'cameraShape1->bar:stuff:imagePlaneShape1'
        >>> imagePlane.name(stripUnderWorld=True, long=True)
        u'|imagePlane1|foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.name(stripUnderWorld=True, stripNamespace=True, long=True)
        u'|imagePlane1|imagePlaneShape1'
        '''
        if update or long or self._name is None:
            exists = True
            if _pymel_options['deleted_pynode_name_access'] != 'ignore':
                exists = self.exists()
            try:
                name = self._updateName(long)
                # _updateName for dag nodes won't actually check if the object
                # still exists... so we do that check ourselves. Also, even
                # though we may already know the object doesn't exist, we still
                # try to update the name... because having an updated name may
                # be nice for any potential error / warning messages
                if not exists:
                    raise general.MayaObjectError
            except general.MayaObjectError:
                # if we have an error, but we're only looking for the nodeName,
                # use the non-dag version
                if long is None and exists:
                    # don't use DependNode._updateName, as that can still
                    # raise MayaInstanceError - want this to work, so people
                    # have a way to get the correct instance, assuming they know
                    # what the parent should be
                    name = _api.MFnDependencyNode(self.__apimobject__()).name()
                else:
                    if not exists:
                        general.DeletedMayaNodeError.handle(self)
                    name = self._name
                    if name is None:
                        # if we've never gotten a name, but we're set to ignore
                        # deleted node errors, then just reraise the original
                        # error
                        raise
        else:
            name = self._name

        if stripNamespace or stripUnderWorld or long is None:
            worlds = []
            underworldSplit = name.split('->')
            if stripUnderWorld:
                underworldSplit = [underworldSplit[-1]]

            for worldName in underworldSplit:
                if stripNamespace or long is None:
                    parentSplit = worldName.split('|')
                    if long is None:
                        parentSplit = [parentSplit[-1]]
                    if stripNamespace:
                        nodes = []
                        for node in parentSplit:
                            # not sure what dag node has a "." in it's name, but keeping
                            # this code here just in case...
                            dotSplit = node.split('.')
                            spaceSplit = dotSplit[0].split(':')
                            if levels:
                                dotSplit[0] = ':'.join(spaceSplit[min(len(spaceSplit) - 1,
                                                                      levels):])
                            else:
                                dotSplit[0] = spaceSplit[-1]
                            nodes.append('.'.join(dotSplit))
                    else:
                        nodes = parentSplit
                    worldName = '|'.join(nodes)
                worlds.append(worldName)
            name = '->'.join(worlds)
        return name

    def longName(self, **kwargs):
        # type: (**Any) -> unicode
        """
        The full dag path to the object, including leading pipe ( | )

        Returns
        -------
        unicode

        Examples
        --------
        >>> import pymel.core as pm
        >>> pm.newFile(f=1)
        ''
        >>> cube1 = pm.polyCube()[0]
        >>> cube2 = pm.polyCube()[0]
        >>> cube3 = pm.polyCube()[0]
        >>> cube3Shape = cube3.getShape()

        >>> cube2.setParent(cube1)
        nt.Transform(u'pCube2')
        >>> cube3.setParent(cube2)
        nt.Transform(u'pCube3')

        >>> pm.namespace(add='foo')
        u'foo'
        >>> pm.namespace(add='bar', parent='foo')
        u'foo:bar'
        >>> pm.namespace(add='stuff', parent='foo:bar')
        u'foo:bar:stuff'

        >>> cube2.rename(':foo:pCube2')
        nt.Transform(u'foo:pCube2')
        >>> cube3.rename(':foo:bar:pCube3')
        nt.Transform(u'foo:bar:pCube3')
        >>> cube3Shape.rename(':foo:bar:stuff:pCubeShape3')
        nt.Mesh(u'foo:bar:stuff:pCubeShape3')

        >>> cube3Shape.longName()
        u'|pCube1|foo:pCube2|foo:bar:pCube3|foo:bar:stuff:pCubeShape3'
        >>> cube3Shape.longName(stripNamespace=True)
        u'|pCube1|pCube2|pCube3|pCubeShape3'
        >>> cube3Shape.longName(stripNamespace=True, levels=1)
        u'|pCube1|pCube2|bar:pCube3|bar:stuff:pCubeShape3'
        >>> cube3Shape.longName(stripNamespace=True, levels=2)
        u'|pCube1|pCube2|pCube3|stuff:pCubeShape3'

        >>> cam = pm.camera()[0]
        >>> cam.setParent(cube2)
        nt.Transform(u'camera1')
        >>> imagePlane = pm.imagePlane(camera=cam.getShape())[1]
        >>> imagePlane.rename('foo:bar:stuff:imagePlaneShape1')
        nt.ImagePlane(u'cameraShape1->foo:bar:stuff:imagePlaneShape1')

        >>> imagePlane.longName()
        u'|pCube1|foo:pCube2|camera1|cameraShape1->|imagePlane1|foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.longName(stripUnderWorld=True)
        u'|imagePlane1|foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.longName(stripNamespace=True, levels=1)
        u'|pCube1|pCube2|camera1|cameraShape1->|imagePlane1|bar:stuff:imagePlaneShape1'
        >>> imagePlane.longName(stripUnderWorld=True, stripNamespace=True)
        u'|imagePlane1|imagePlaneShape1'
        """
        return self.name(long=True, **kwargs)
    fullPath = longName

    def shortName(self, **kwargs):
        # type: (**Any) -> unicode
        """
        The shortest unique name.

        Returns
        -------
        unicode

        Examples
        --------
        >>> import pymel.core as pm
        >>> pm.newFile(f=1)
        ''
        >>> cube1 = pm.polyCube()[0]
        >>> cube2 = pm.polyCube()[0]
        >>> cube3 = pm.polyCube()[0]
        >>> cube3Shape = cube3.getShape()

        >>> cube2.setParent(cube1)
        nt.Transform(u'pCube2')
        >>> cube3.setParent(cube2)
        nt.Transform(u'pCube3')

        >>> pm.namespace(add='foo')
        u'foo'
        >>> pm.namespace(add='bar', parent='foo')
        u'foo:bar'
        >>> pm.namespace(add='stuff', parent='foo:bar')
        u'foo:bar:stuff'

        >>> cube2.rename(':foo:pCube2')
        nt.Transform(u'foo:pCube2')
        >>> cube3.rename(':foo:bar:pCube3')
        nt.Transform(u'foo:bar:pCube3')
        >>> cube3Shape.rename(':foo:bar:stuff:pCubeShape3')
        nt.Mesh(u'foo:bar:stuff:pCubeShape3')

        >>> cube3Shape.shortName()
        u'foo:bar:stuff:pCubeShape3'
        >>> cube3Shape.shortName(stripNamespace=True)
        u'pCubeShape3'
        >>> cube3Shape.shortName(stripNamespace=True, levels=1)
        u'bar:stuff:pCubeShape3'
        >>> cube3Shape.shortName(stripNamespace=True, levels=2)
        u'stuff:pCubeShape3'

        >>> cam = pm.camera()[0]
        >>> cam.setParent(cube2)
        nt.Transform(u'camera1')
        >>> imagePlane = pm.imagePlane(camera=cam.getShape())[1]
        >>> imagePlane.rename('foo:bar:stuff:imagePlaneShape1')
        nt.ImagePlane(u'cameraShape1->foo:bar:stuff:imagePlaneShape1')

        >>> imagePlane.shortName()
        u'cameraShape1->foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.shortName(stripUnderWorld=True)
        u'foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.shortName(stripNamespace=True, levels=1)
        u'cameraShape1->bar:stuff:imagePlaneShape1'
        >>> imagePlane.shortName(stripUnderWorld=True)
        u'foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.shortName(stripUnderWorld=True, stripNamespace=True)
        u'imagePlaneShape1'
        """
        return self.name(long=False, **kwargs)

    # TODO: better support for underworld nodes (ie, in conjunction with
    # stripNamespace)
    def nodeName(self, stripUnderWorld=True, **kwargs):
        # type: (Any, **Any) -> unicode
        """
        Just the name of the node, without any dag path

        Returns
        -------
        unicode

        Examples
        --------
        >>> import pymel.core as pm
        >>> pm.newFile(f=1)
        ''
        >>> cube1 = pm.polyCube()[0]
        >>> cube2 = pm.polyCube()[0]
        >>> cube3 = pm.polyCube()[0]
        >>> cube3Shape = cube3.getShape()

        >>> cube2.setParent(cube1)
        nt.Transform(u'pCube2')
        >>> cube3.setParent(cube2)
        nt.Transform(u'pCube3')

        >>> pm.namespace(add='foo')
        u'foo'
        >>> pm.namespace(add='bar', parent='foo')
        u'foo:bar'
        >>> pm.namespace(add='stuff', parent='foo:bar')
        u'foo:bar:stuff'

        >>> cube2.rename(':foo:pCube2')
        nt.Transform(u'foo:pCube2')
        >>> cube3.rename(':foo:bar:pCube3')
        nt.Transform(u'foo:bar:pCube3')
        >>> cube3Shape.rename(':foo:bar:stuff:pCubeShape3')
        nt.Mesh(u'foo:bar:stuff:pCubeShape3')

        >>> # create an object with the same name as pCube3 / pCube4
        >>> cube3Twin = pm.polyCube()[0]
        >>> cube3Twin.rename('foo:bar:pCube3')
        nt.Transform(u'|foo:bar:pCube3')
        >>> cube3ShapeTwin = cube3Twin.getShape()
        >>> cube3ShapeTwin.rename('foo:bar:stuff:pCubeShape3')
        nt.Mesh(u'|foo:bar:pCube3|foo:bar:stuff:pCubeShape3')

        >>> cube3Shape.shortName()
        u'foo:pCube2|foo:bar:pCube3|foo:bar:stuff:pCubeShape3'
        >>> cube3Shape.nodeName()
        u'foo:bar:stuff:pCubeShape3'
        >>> cube3Shape.nodeName(stripNamespace=True)
        u'pCubeShape3'
        >>> cube3Shape.nodeName(stripNamespace=True, levels=1)
        u'bar:stuff:pCubeShape3'
        >>> cube3Shape.nodeName(stripNamespace=True, levels=2)
        u'stuff:pCubeShape3'

        >>> cam = pm.camera()[0]
        >>> cam.setParent(cube2)
        nt.Transform(u'camera1')
        >>> imagePlaneTrans, imagePlane = pm.imagePlane(camera=cam.getShape())
        >>> imagePlane.rename('foo:bar:stuff:imagePlaneShape1')
        nt.ImagePlane(u'cameraShape1->foo:bar:stuff:imagePlaneShape1')

        >>> # create an object with the same name as cam
        >>> pm.camera()[0].setParent(cube3Twin).rename('camera1')
        nt.Transform(u'|foo:bar:pCube3|camera1')

        >>> # create an object with the same name as imagePlane
        >>> imagePlaneTwinTrans, imagePlaneTwin = pm.imagePlane(camera=cam.getShape())
        >>> imagePlaneTwin.rename('foo:bar:stuff:imagePlaneShape1')
        nt.ImagePlane(u'foo:pCube2|camera1|cameraShape1->imagePlane2|foo:bar:stuff:imagePlaneShape1')

        >>> imagePlane.shortName()
        u'foo:pCube2|camera1|cameraShape1->imagePlane1|foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.nodeName()
        u'foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.nodeName(stripUnderWorld=False)
        u'cameraShape1->foo:bar:stuff:imagePlaneShape1'
        >>> imagePlane.nodeName(stripNamespace=True)
        u'imagePlaneShape1'
        >>> imagePlane.nodeName(stripNamespace=True, levels=1)
        u'bar:stuff:imagePlaneShape1'
        """
        return self.name(long=None, stripUnderWorld=stripUnderWorld, **kwargs)

    def __apiobject__(self):
        "get the ``maya.OpenMaya.MDagPath`` for this object if it is valid"
        return self.__apimdagpath__()

    def __apimdagpath__(self):
        "get the ``maya.OpenMaya.MDagPath`` for this object if it is valid"

        try:
            dag = self.__apiobjects__['MDagPath']
            # If we have a cached mobject, test for validity: if the object is
            # not valid an error will be raised
            # Check if MObjectHandle in self.__apiobjects__ to avoid recursive
            # loop...
            if 'MObjectHandle' in self.__apiobjects__:
                self.__apimobject__()
            if not dag.isValid():
                # Usually this only happens if the object was reparented, with
                # instancing.
                #
                # Most of the time, this makes sense - there's no way to know
                # which of the new instances we "want".  Hoever, occasionally,
                # when the object was reparented, there were multiple instances,
                # and the MDagPath was invalidated; however, subsequently, other
                # instances were removed, so it's no longer instanced. Check for
                # this...

                # in some cases, doing dag.node() will crash maya if the dag
                # isn't valid... so try using MObjectHandle
                handle = self.__apiobjects__.get('MObjectHandle')
                if handle is not None and handle.isValid():
                    mfnDag = _api.MFnDagNode(handle.object())
                    if not mfnDag.isInstanced():
                        # throw a KeyError, this will cause to regen from
                        # first MDagPath
                        raise KeyError
                    raise general.MayaInstanceError(mfnDag.name())
                else:
                    name = getattr(self, '_name', '<unknown>')
                    raise general.MayaInstanceError(name)
            return dag
        except KeyError:
            # class was instantiated from an MObject, but we can still retrieve the first MDagPath

            #assert argObj.hasFn( _api.MFn.kDagNode )
            dag = _api.MDagPath()
            # we can't use self.__apimfn__() becaue the mfn is instantiated from an MDagPath
            # which we are in the process of finding out
            mfn = _api.MFnDagNode(self.__apimobject__())
            mfn.getPath(dag)
            self.__apiobjects__['MDagPath'] = dag
            return dag
#            if dag.isValid():
#                #argObj = dag
#                if dag.fullPathName():
#                    argObj = dag
#                else:
#                    print 'produced valid MDagPath with no name: %s(%s)' % ( argObj.apiTypeStr(), _api.MFnDependencyNode(argObj).name() )

    def __apihandle__(self):
        "get the ``maya.OpenMaya.MObjectHandle`` for this node if it is valid"
        try:
            handle = self.__apiobjects__['MObjectHandle']
        except KeyError:
            try:
                handle = _api.MObjectHandle(self.__apimdagpath__().node())
            except general.MayaInstanceError:
                if 'MDagPath' in self.__apiobjects__:
                    handle = _api.MObjectHandle(self.__apiobjects__['MDagPath'].node())
                else:
                    raise general.MayaNodeError(self._name)
            except RuntimeError:
                raise general.MayaNodeError(self._name)
            self.__apiobjects__['MObjectHandle'] = handle
        return handle

#    def __apimfn__(self):
#        if self._apimfn:
#            return self._apimfn
#        elif self.__apicls__:
#            obj = self._apiobject
#            if _api.isValidMDagPath(obj):
#                try:
#                    self._apimfn = self.__apicls__(obj)
#                    return self._apimfn
#                except KeyError:
#                    pass

#    def __init__(self, *args, **kwargs):
#        if self._apiobject:
#            if isinstance(self._apiobject, _api.MObjectHandle):
#                dagPath = _api.MDagPath()
#                _api.MDagPath.getAPathTo( self._apiobject.object(), dagPath )
#                self._apiobject = dagPath
#
#            assert _api.isValidMDagPath( self._apiobject )


#    def __init__(self, *args, **kwargs) :
#        if args :
#            arg = args[0]
#            if len(args) > 1 :
#                comp = args[1]
#            if isinstance(arg, DagNode) :
#                self._name = unicode(arg.name())
#                self._apiobject = _api.MObjectHandle(arg.object())
#            elif _api.isValidMObject(arg) or _api.isValidMObjectHandle(arg) :
#                objHandle = _api.MObjectHandle(arg)
#                obj = objHandle.object()
#                if _api.isValidMDagNode(obj) :
#                    self._apiobject = objHandle
#                    self._updateName()
#                else :
#                    raise TypeError, "%r might be a dependencyNode, but not a dagNode" % arg
#            elif isinstance(arg, basestring) :
#                obj = _api.toMObject (arg)
#                if obj :
#                    # creation for existing object
#                    if _api.isValidMDagNode (obj):
#                        self._apiobject = _api.MObjectHandle(obj)
#                        self._updateName()
#                    else :
#                        raise TypeError, "%r might be a dependencyNode, but not a dagNode" % arg
#                else :
#                    # creation for inexistent object
#                    self._name = arg
#            else :
#                raise TypeError, "don't know how to make a DagNode out of a %s : %r" % (type(arg), arg)


# -------------------------------
# xxx{  Path Info and Modification
# -------------------------------
    def root(self):
        # type: () -> unicode
        """rootOf

        Returns
        -------
        unicode
        """
        return DagNode('|' + self.longName()[1:].split('|')[0])

    # For some reason, this wasn't defined on Transform...?
    # maya seems to have a bug right now (2016.53) that causes crashes when
    # accessing MDagPaths after creating an instance, so not enabling this
    # at the moment...
    # def getAllPaths(self):
    #     dagPaths = _api.MDagPathArray()
    #     self.__apimfn__().getAllPaths(dagPaths)
    #     return [DagNode(dagPaths[i]) for i in xrange(dagPaths.length())]

    def hasParent(self, parent):
        '''
        Modifications:
        - handles underworld nodes correctly
        '''
        toMObj = _factories.ApiTypeRegister.inCast['MObject']
        # This will error if parent is not a dag, or not a node, like default
        # wrapped implementation
        parentMObj = toMObj(parent)
        thisMFn = self.__apimfn__()
        if thisMFn.hasParent(parentMObj):
            return True

        # quick out... MFnDagNode handles things right if all instances aren't
        # underworld nodes

        if not thisMFn.isInstanced() and not thisMFn.inUnderWorld():
            return False

        # See if it's underworld parent is the given parent...
        # Note that MFnDagPath implementation considers all instances, so we
        # should too...
        allPaths = _api.MDagPathArray()
        thisMFn.getAllPaths(allPaths)
        for i in xrange(allPaths.length()):
            path = allPaths[i]
            pathCount = path.pathCount()
            if pathCount <= 1:
                continue
            # if there's an underworld, there should be at least 3 nodes -
            # the top parent, the underworld root, and the node in the
            # underworld
            assert path.length() >= 3
            # if they are in the same underworld, MFnDagNode.hasParent would
            # work - only care about the case where the "immediate" parent is
            # outside of this node's underworld
            # Unfortunately, MDagPath.pop() has some strange behavior   - ie, if
            #     path = |camera1|cameraShape1->|imagePlane1
            # Then popping it once gives:
            #     path = |camera1|cameraShape1->|
            # ...and again gives:
            #     path = |camera1|cameraShape1
            # So, we check that popping once has the same pathCount, but twice
            # has a different path count
            path.pop()
            if path.pathCount() != pathCount:
                continue
            path.pop()
            if path.pathCount() != pathCount - 1:
                continue
            if path.node() == parentMObj:
                return True
        return False

    def hasChild(self, child):
        '''
        Modifications:
        - handles underworld nodes correctly
        '''
        toMObj = _factories.ApiTypeRegister.inCast['MObject']
        # This will error if parent is not a dag, or not a node, like default
        # wrapped implementation
        childMObj = toMObj(child)
        thisMFn = self.__apimfn__()
        if self.__apimfn__().hasChild(childMObj):
            return True

        # because hasChild / hasParent consider all instances,
        # self.hasChild(child) is equivalent to child.hasParent(self)...
        if not isinstance(child, general.PyNode):
            child = DagNode(childMObj)
        return child.hasParent(self)

    def isChildOf(self, parent):
        '''
        Modifications:
        - handles underworld nodes correctly
        '''
        toMObj = _factories.ApiTypeRegister.inCast['MObject']
        # This will error if parent is not a dag, or not a node, like default
        # wrapped implementation
        parentMObj = toMObj(parent)
        thisMFn = self.__apimfn__()
        if thisMFn.isChildOf(parentMObj):
            return True

        # quick out... MFnDagNode handles things right if all instances aren't
        # underworld nodes
        if not thisMFn.isInstanced() and not thisMFn.inUnderWorld():
            return False

        # For each instance path, if it's in the underworld, check to see
        # if the parent at the same "underworld" level as the parent is the
        # parent, or a child of it
        dagArray = _api.MDagPathArray()
        _api.MDagPath.getAllPathsTo(parentMObj, dagArray)
        allParentLevels = set()
        for i in xrange(dagArray.length()):
            parentMDag = dagArray[i]
            allParentLevels.add(parentMDag.pathCount())
        # we only get one parentMFn, but this should be fine as (aside from
        # not dealing with underworld correctly), MFnDagNode.isParentOf works
        # correctly for all instances...
        parentMFn = _api.MFnDagNode(parentMObj)

        dagArray.clear()
        thisMFn.getAllPaths(dagArray)
        for i in xrange(dagArray.length()):
            childMDag = dagArray[i]
            childPathLevels = childMDag.pathCount()
            if childPathLevels <= 1:
                continue
            for parentUnderworldLevel in allParentLevels:
                if childMDag.pathCount() <= parentUnderworldLevel:
                    # standard MFnDagNode.isChildOf would have handled this...
                    continue
                sameLevelMDag = _api.MDagPath()
                childMDag.getPath(sameLevelMDag, parentUnderworldLevel - 1)
                sameLevelMObj = sameLevelMDag.node()
                if sameLevelMObj == parentMObj:
                    return True
                if parentMFn.isParentOf(sameLevelMObj):
                    return True
        return False

    def isParentOf(self, child):
        '''
        Modifications:
        - handles underworld nodes correctly
        '''
        toMObj = _factories.ApiTypeRegister.inCast['MObject']
        # This will error if parent is not a dag, or not a node, like default
        # wrapped implementation
        childMObj = toMObj(child)
        thisMFn = self.__apimfn__()
        if thisMFn.isParentOf(childMObj):
            return True

        # because isChildOf / isParentOf consider all instances,
        # self.isParentOf(child) is equivalent to child.isChildOf(self)...
        if not isinstance(child, general.PyNode):
            child = DagNode(childMObj)
        return child.isChildOf(self)

    def isInstanceOf(self, other):
        # type: (Any) -> bool
        """
        Returns
        -------
        bool
        """
        if isinstance(other, general.PyNode):
            return self.__apimobject__() == other.__apimobject__()
        else:
            try:
                return self.__apimobject__() == general.PyNode(other).__apimobject__()
            except:
                return False

    def instanceNumber(self):
        # type: () -> int
        """
        returns the instance number that this path represents in the DAG. The instance number can be used to determine which
        element of the world space array attributes of a DAG node to connect to get information regarding this instance.

        Returns
        -------
        int
        """
        return self.__apimdagpath__().instanceNumber()

    def getInstances(self, includeSelf=True):
        # type: (Any) -> List[DagNode]
        """
        Returns
        -------
        List[DagNode]

        Examples
        --------
        >>> from pymel.core import *
        >>> f=newFile(f=1) #start clean
        >>>
        >>> s = polyPlane()[0]
        >>> instance(s)
        [nt.Transform(u'pPlane2')]
        >>> instance(s)
        [nt.Transform(u'pPlane3')]
        >>> s.getShape().getInstances()
        [nt.Mesh(u'pPlane1|pPlaneShape1'), nt.Mesh(u'pPlane2|pPlaneShape1'), nt.Mesh(u'pPlane3|pPlaneShape1')]
        >>> s.getShape().getInstances(includeSelf=False)
        [nt.Mesh(u'pPlane2|pPlaneShape1'), nt.Mesh(u'pPlane3|pPlaneShape1')]

        """
        d = _api.MDagPathArray()
        self.__apimfn__().getAllPaths(d)
        thisDagPath = self.__apimdagpath__()
        result = [general.PyNode(_api.MDagPath(d[i])) for i in range(d.length()) if includeSelf or not d[i] == thisDagPath]

        return result

    def getOtherInstances(self):
        # type: () -> List[DagNode]
        """
        same as `DagNode.getInstances` with includeSelf=False.

        Returns
        -------
        List[DagNode]
        """
        return self.getInstances(includeSelf=False)

    def firstParent(self):
        # type: () -> DagNode
        """firstParentOf

        Returns
        -------
        DagNode
        """
        try:
            return DagNode('|'.join(self.longName().split('|')[:-1]))
        except TypeError:
            return DagNode('|'.join(self.split('|')[:-1]))

#    def numChildren(self):
#        """
#        see also `childCount`
#
#        :rtype: `int`
#        """
#        return self.__apimdagpath__().childCount()

#    def getParent(self, **kwargs):
#        # TODO : print warning regarding removal of kwargs, test speed difference
#        parent = _api.MDagPath( self.__apiobject__() )
#        try:
#            parent.pop()
#            return general.PyNode(parent)
#        except RuntimeError:
#            pass
#
#    def getChildren(self, **kwargs):
#        # TODO : print warning regarding removal of kwargs
#        children = []
#        thisDag = self.__apiobject__()
#        for i in range( thisDag.childCount() ):
#            child = _api.MDagPath( thisDag )
#            child.push( thisDag.child(i) )
#            children.append( general.PyNode(child) )
#        return children

    def firstParent2(self, **kwargs):
        """unlike the firstParent command which determines the parent via string formatting, this
        command uses the listRelatives command
        """

        kwargs['parent'] = True
        kwargs.pop('p', None)
        # if longNames:
        kwargs['fullPath'] = True
        kwargs.pop('f', None)

        try:
            res = cmds.listRelatives(self, **kwargs)[0]
        except TypeError:
            return None

        res = general.PyNode(res)
        return res

    @staticmethod
    def _getDagParent(dag):
        if dag.length() <= 1:
            return None
        # Need a copy as we'll be modifying it...
        parentDag = _api.MDagPath(dag)
        parentDag.pop()

        # do a check for underworld paths - if we have a path:
        # |rootTrans|rootShape -> |underwoldTrans|underworldShape
        # then two parents up, we will get:
        # |rootTrans|rootShape ->
        # ...whose .node() will be unusable. check for this scenario, and if
        # we get it, skip this dag path, so we go straight to:
        # |rootTrans|rootShape

        pathCount = parentDag.pathCount()
        if pathCount > 1:
            # get just the last "path piece" - if it is "empty", do an extra
            # pop, to get out of the underworld
            underworldPath = _api.MDagPath()
            parentDag.getPath(underworldPath, pathCount - 1)
            if underworldPath.length() == 0:
                parentDag.pop()

        return parentDag

    def getParent(self, generations=1):
        # type: (Any) -> Union[DagNode, List[DagNode]]
        """
        Modifications:
            - added optional generations flag, which gives the number of levels up that you wish to go for the parent;
              ie:
                  >>> from pymel.core import *
                  >>> select(cl=1)
                  >>> bottom = group(n='bottom')
                  >>> group(n='almostThere')
                  nt.Transform(u'almostThere')
                  >>> group(n='nextLevel')
                  nt.Transform(u'nextLevel')
                  >>> group(n='topLevel')
                  nt.Transform(u'topLevel')
                  >>> bottom.longName()
                  u'|topLevel|nextLevel|almostThere|bottom'
                  >>> bottom.getParent(2)
                  nt.Transform(u'nextLevel')

              Negative values will traverse from the top:

                  >>> bottom.getParent(generations=-3)
                  nt.Transform(u'almostThere')

              A value of 0 will return the same node.
              The default value is 1.

              If generations is None, it will be interpreted as 'return all
              parents', and a list will be returned.

              Since the original command returned None if there is no parent, to sync with this behavior, None will
              be returned if generations is out of bounds (no IndexError will be thrown).

        Returns
        -------
        Union[DagNode, List[DagNode]]
        """

        # Get the parent through the api - listRelatives doesn't handle instances correctly,
        # and string processing seems unreliable...

        res = general._getParent(self._getDagParent, self.__apimdagpath__(), generations)

        if generations is None:
            if res is None:
                return []
            return [general.PyNode(x) for x in res]
        elif res is not None:
            return general.PyNode(res)

    def getAllParents(self):
        # type: () -> List[DagNode]
        """
        Return a list of all parents above this.

        Starts from the parent immediately above, going up.

        Returns
        -------
        List[DagNode]
        """
        return self.getParent(generations=None)

    def getChildren(self, **kwargs):
        # type: (**Any) -> List[DagNode]
        """
        see also `childAtIndex`

        for flags, see ``pymel.core.general.listRelatives``

        Returns
        -------
        List[DagNode]
        """
        kwargs['children'] = True
        kwargs.pop('c', None)

        return general.listRelatives(self, **kwargs)

    def getSiblings(self, **kwargs):
        # type: (**Any) -> List[DagNode]
        """
        for flags, see ``pymel.core.general.listRelatives``

        Returns
        -------
        List[DagNode]
        """
        # pass
        try:
            return [x for x in self.getParent().getChildren(**kwargs) if x != self]
        except:
            return []

    def listRelatives(self, **kwargs):
        # type: (**Any) -> List[DagNode]
        """
        for flags, see ``pymel.core.general.listRelatives``

        Returns
        -------
        List[DagNode]
        """
        return general.listRelatives(self, **kwargs)

    def setParent(self, *args, **kwargs):
        """
        parent

        Modifications:
            - if parent is 'None', world=True is automatically set
            - if the given parent is the current parent, don't error

        """
        result = general.parent(self, *args, **kwargs)
        if result:
            result = result[0]
        return result

    def addChild(self, child, **kwargs):
        # type: (Any, **Any) -> DagNode
        """parent (reversed)

        Returns
        -------
        DagNode
        """
        cmds.parent(child, self, **kwargs)
        if not isinstance(child, general.PyNode):
            child = general.PyNode(child)
        return child

    def __or__(self, child, **kwargs):
        # type: (Any, **Any) -> DagNode
        """
        operator for `addChild`. Use to easily daisy-chain together parenting operations.
        The operation order visually mimics the resulting dag path:

            >>> from pymel.core import *
            >>> s = polySphere(name='sphere')[0]
            >>> c = polyCube(name='cube')[0]
            >>> t = polyTorus(name='torus')[0]
            >>> s | c | t
            nt.Transform(u'torus')
            >>> print t.fullPath()
            |sphere|cube|torus

        Returns
        -------
        DagNode
        """
        return self.addChild(child, **kwargs)

#}
    #instance = instance

    # -------------------------
    #    Shading
    # -------------------------

    def isDisplaced(self):
        # type: () -> bool
        """
        Returns whether any of this object's shading groups have a
        displacement shader input

        Returns
        -------
        bool
        """
        for sg in self.shadingGroups():
            if len(sg.attr('displacementShader').inputs()):
                return True
        return False

    def hide(self):
        self.visibility.set(0)

    def show(self):
        self.visibility.set(1)

    def isVisible(self, checkOverride=True):
        if not self.attr('visibility').get():
            return False
        if (checkOverride and self.attr('overrideEnabled').get()
                and not self.attr('overrideVisibility').get()):
            return False
        parent = self.getParent()
        if not parent:
            return True
        else:
            return parent.isVisible(checkOverride=checkOverride)

    def setObjectColor(self, color=None):
        """
        This command sets the dormant wireframe color of the specified objects
        to an integer representing one of the user defined colors, or, if set
        to None, to the default class color
        """

        kwargs = {}
        if color:
            kwargs['userDefined'] = color
        cmds.color(self, **kwargs)

    def makeLive(self, state=True):
        if not state:
            cmds.makeLive(none=True)
        else:
            cmds.makeLive(self)
# ------ Do not edit below this line --------
    __melnode__ = u'dagNode'
    __slots__ = ()
    MObjectColorType = Enum('MObjectColorType', {'defaultColor': 0, 'kUseDefaultColor': 0, 'kUseIndexColor': 1, 'indexColor': 1, 'RGBColor': 2, 'kUseRGBColor': 2}, multiKeys=True, defaultKeys={0: 'defaultColor', 1: 'indexColor', 2: 'RGBColor'})

    @_f.addApiDocs(_api.MFnDagNode, 'activeColor')
    def activeColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnDagNode, 'activeColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnDagNode, 'boundingBox')
    def boundingBox(self):
        # type: () -> BoundingBox
        res = _f.getProxyResult(self, _api.MFnDagNode, 'boundingBox')
        return _f.ApiArgUtil._castResult(self, res, 'MBoundingBox', None)

    @_f.deprecated
    def child(self, i):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([i], [('i', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'child', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnDagNode, 'child')
    def childAtIndex(self, i):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([i], [('i', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'child', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.deprecated
    def childCount(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnDagNode, 'childCount')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.deprecated
    def dagPath(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnDagNode, 'dagPath')
        return _f.ApiArgUtil._castResult(self, res, 'MDagPath', None)

    @_f.deprecated
    def dagRoot(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnDagNode, 'dagRoot')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnDagNode, 'dormantColor')
    def dormantColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnDagNode, 'dormantColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnDagNode, 'drawOverrideColor')
    def drawOverrideColor(self):
        # type: () -> Tuple[bool, Color]
        do, final_do, outTypes = _f.getDoArgs([], [('color', 'MColor', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'drawOverrideColor', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnDagNode, 'drawOverrideEnabled')
    def drawOverrideEnabled(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'drawOverrideEnabled')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDagNode, 'drawOverrideIsReference')
    def drawOverrideIsReference(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'drawOverrideIsReference')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDagNode, 'drawOverrideIsTemplate')
    def drawOverrideIsTemplate(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'drawOverrideIsTemplate')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.deprecated
    def fullPathName(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnDagNode, 'fullPathName')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.deprecated
    def getAllPaths(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('paths', 'MDagPathArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'getAllPaths', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnDagNode, 'getConnectedSetsAndMembers')
    def getConnectedSetsAndMembers(self, instanceNumber, renderableSetsOnly):
        # type: (int, bool) -> Tuple[List[general.PyNode], List[general.PyNode]]
        do, final_do, outTypes = _f.getDoArgs([instanceNumber, renderableSetsOnly], [('instanceNumber', 'uint', 'in', None), ('sets', 'MObjectArray', 'out', None), ('comps', 'MObjectArray', 'out', None), ('renderableSetsOnly', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'getConnectedSetsAndMembers', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def getObjectColor(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnDagNode, 'objectColor')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnDagNode, 'objectColorType')
    def getObjectColorType(self):
        # type: () -> DagNode.MObjectColorType
        res = _f.getProxyResult(self, _api.MFnDagNode, 'objectColorType')
        return _f.ApiArgUtil._castResult(self, res, ('MFnDagNode', 'MObjectColorType'), None)

    @_f.deprecated
    def getPath(self):
        # type: () -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([], [('path', 'MDagPath', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'getPath', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnDagNode, 'hiliteColor')
    def hiliteColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnDagNode, 'hiliteColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnDagNode, 'inModel')
    def inModel(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'inModel')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDagNode, 'inUnderWorld')
    def inUnderWorld(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'inUnderWorld')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDagNode, 'instanceCount')
    def instanceCount(self, total=True):
        # type: (bool) -> int
        do, final_do, outTypes = _f.getDoArgs([total], [('total', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'instanceCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnDagNode, 'isInstanceable')
    def isInstanceable(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'isInstanceable')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDagNode, 'isInstanced')
    def isInstanced(self, indirect=True):
        # type: (bool) -> bool
        do, final_do, outTypes = _f.getDoArgs([indirect], [('indirect', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'isInstanced', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.deprecated
    def isInstancedAttribute(self, attribute):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([attribute], [('attribute', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'isInstancedAttribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnDagNode, 'isIntermediateObject')
    def isIntermediate(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'isIntermediateObject')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.deprecated
    def isIntermediateObject(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'isIntermediateObject')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.deprecated
    def isUsingObjectColor(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'usingObjectColor')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.deprecated
    def model(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnDagNode, 'model')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnDagNode, 'childCount')
    def numChildren(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnDagNode, 'childCount')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnDagNode, 'objectColorIndex')
    def objectColorIndex(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnDagNode, 'objectColorIndex')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnDagNode, 'objectColorRGB')
    def objectColorRGB(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnDagNode, 'objectColorRGB')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.deprecated
    def parent(self, i):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([i], [('i', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'parent', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnDagNode, 'parent')
    def parentAtIndex(self, i):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([i], [('i', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'parent', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnDagNode, 'parentCount')
    def parentCount(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnDagNode, 'parentCount')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.deprecated
    def partialPathName(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnDagNode, 'partialPathName')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.deprecated
    def removeChild(self, child):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([child], [('child', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'removeChild', final_do)
        return res

    @_f.deprecated
    def removeChildAt(self, index):
        # type: (int) -> None
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'removeChildAt', final_do)
        return res

    @_f.deprecated
    def setInstanceable(self, how):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([how], [('how', 'bool', 'in', None)], self.isInstanceable, self.setInstanceable, [])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'setInstanceable', final_do)
        return res

    @_f.addApiDocs(_api.MFnDagNode, 'setIntermediateObject')
    def setIntermediate(self, isIntermediate):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([isIntermediate], [('isIntermediate', 'bool', 'in', None)], self.isIntermediate, self.setIntermediate, [])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'setIntermediateObject', final_do)
        return res

    @_f.deprecated
    def setIntermediateObject(self, isIntermediate):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([isIntermediate], [('isIntermediate', 'bool', 'in', None)], self.isIntermediate, self.setIntermediateObject, [])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'setIntermediateObject', final_do)
        return res

    @_f.deprecated
    def setObject(self, objectPath):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([objectPath], [('objectPath', 'MDagPath', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'setObject', final_do)
        return res

    @_f.addApiDocs(_api.MFnDagNode, 'setObjectColorType')
    def setObjectColorType(self, type):
        # type: (DagNode.MObjectColorType) -> None
        do, final_do, outTypes = _f.processApiArgs([type], [('type', ('MFnDagNode', 'MObjectColorType'), 'in', None)], self.getObjectColorType, self.setObjectColorType, [])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'setObjectColorType', final_do)
        return res

    @_f.deprecated
    def setUseObjectColor(self, useObjectColor):
        # type: (bool) -> None
        do, final_do, outTypes = _f.getDoArgs([useObjectColor], [('useObjectColor', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnDagNode, 'setUseObjectColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnDagNode, 'transformationMatrix')
    def transformationMatrix(self):
        # type: () -> Matrix
        res = _f.getProxyResult(self, _api.MFnDagNode, 'transformationMatrix')
        return _f.ApiArgUtil._castResult(self, res, 'MMatrix', None)

    @_f.addApiDocs(_api.MFnDagNode, 'usingHiliteColor')
    def usingHiliteColor(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'usingHiliteColor')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.deprecated
    def usingObjectColor(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDagNode, 'usingObjectColor')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)
# ------ Do not edit above this line --------


class Shape(DagNode):

    def getTransform(self):
        return self.getParent(generations=1)

    def setParent(self, *args, **kwargs):
        if 'shape' not in kwargs and 's' not in kwargs:
            kwargs['s'] = True
        super(Shape, self).setParent(*args, **kwargs)
# ------ Do not edit below this line --------
    __melnode__ = u'shape'
    __slots__ = ()
# ------ Do not edit above this line --------


# class Joint(Transform):
#    pass


class Camera(Shape):
    # FIXME: the functionFactory is causing these methods to have their docs doubled-up,  in both pymel.track, and pymel.Camera.track
    if not _factories.building:
        orbit = rendering.orbit
        track = rendering.track
        tumble = rendering.tumble

    def applyBookmark(self, bookmark):
        kwargs = {}
        kwargs['camera'] = self
        kwargs['edit'] = True
        kwargs['setCamera'] = True

        cmds.cameraView(bookmark, **kwargs)

    def addBookmark(self, bookmark=None):
        kwargs = {}
        kwargs['camera'] = self
        kwargs['addBookmark'] = True
        if bookmark:
            kwargs['name'] = bookmark

        cmds.cameraView(**kwargs)

    def removeBookmark(self, bookmark):
        kwargs = {}
        kwargs['camera'] = self
        kwargs['removeBookmark'] = True
        kwargs['name'] = bookmark

        cmds.cameraView(**kwargs)

    def updateBookmark(self, bookmark):
        kwargs = {}
        kwargs['camera'] = self
        kwargs['edit'] = True
        kwargs['setView'] = True

        cmds.cameraView(bookmark, **kwargs)

    def listBookmarks(self):
        return self.bookmarks.inputs()

    @_factories.addMelDocs('dolly')
    def dolly(self, distance, relative=True):
        kwargs = {}
        kwargs['distance'] = distance
        if relative:
            kwargs['relative'] = True
        else:
            kwargs['absolute'] = True
        cmds.dolly(self, **kwargs)

    @_factories.addMelDocs('roll')
    def roll(self, degree, relative=True):
        kwargs = {}
        kwargs['degree'] = degree
        if relative:
            kwargs['relative'] = True
        else:
            kwargs['absolute'] = True
        cmds.roll(self, **kwargs)
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnCamera
    __melcmd__ = staticmethod(rendering.camera)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'camera'
    __melnode__ = u'camera'
    __slots__ = ()
    FilmFit = Enum('FilmFit', {'kFillFilmFit': 0, 'fillFilmFit': 0, 'horizontalFilmFit': 1, 'kHorizontalFilmFit': 1, 'kVerticalFilmFit': 2, 'verticalFilmFit': 2, 'overscanFilmFit': 3, 'kOverscanFilmFit': 3, 'kInvalid': 4, 'invalid': 4}, multiKeys=True, defaultKeys={0: 'fillFilmFit', 1: 'horizontalFilmFit', 2: 'verticalFilmFit', 3: 'overscanFilmFit', 4: 'invalid'})
    RollOrder = Enum('RollOrder', {'rotateTranslate': 0, 'kRotateTranslate': 0, 'translateRotate': 1, 'kTranslateRotate': 1}, multiKeys=True, defaultKeys={0: 'rotateTranslate', 1: 'translateRotate'})

    @_f.addApiDocs(_api.MFnCamera, 'computeDepthOfField')
    def computeDepthOfField(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnCamera, 'computeDepthOfField')
        return res

    @_f.addApiDocs(_api.MFnCamera, 'copyViewFrom')
    def copyViewFrom(self, otherCamera):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([otherCamera], [('otherCamera', 'MDagPath', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'copyViewFrom', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'aspectRatio')
    def getAspectRatio(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'aspectRatio')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'getAspectRatioLimits')
    def getAspectRatioLimits(self):
        # type: () -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('min', 'double', 'out', None), ('max', 'double', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'getAspectRatioLimits', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCamera, 'cameraScale')
    def getCameraScale(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'cameraScale')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'centerOfInterest')
    def getCenterOfInterest(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'centerOfInterest')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnCamera, 'centerOfInterestPoint')
    def getCenterOfInterestPoint(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'centerOfInterestPoint', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPoint', None)
        return res

    @_f.addMelDocs('camera', 'displayFieldChart')
    def getDisplayFieldChart(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'displayFieldChart')
        return res

    @_f.addMelDocs('camera', 'displayFilmOrigin')
    def getDisplayFilmOrigin(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'displayFilmOrigin')
        return res

    @_f.addMelDocs('camera', 'displayFilmPivot')
    def getDisplayFilmPivot(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'displayFilmPivot')
        return res

    @_f.addMelDocs('camera', 'displayGateMask')
    def getDisplayGateMask(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'displayGateMask')
        return res

    @_f.addMelDocs('camera', 'displayResolution')
    def getDisplayResolution(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'displayResolution')
        return res

    @_f.addMelDocs('camera', 'displaySafeAction')
    def getDisplaySafeAction(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'displaySafeAction')
        return res

    @_f.addMelDocs('camera', 'displaySafeTitle')
    def getDisplaySafeTitle(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'displaySafeTitle')
        return res

    @_f.addApiDocs(_api.MFnCamera, 'eyePoint')
    def getEyePoint(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'eyePoint', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPoint', None)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'fStop')
    def getFStop(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'fStop')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'farClippingPlane')
    def getFarClipPlane(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'farClippingPlane')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnCamera, 'farFocusDistance')
    def getFarFocusDistance(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'farFocusDistance')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnCamera, 'getFilmApertureLimits')
    def getFilmApertureLimits(self):
        # type: () -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('min', 'double', 'out', None), ('max', 'double', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'getFilmApertureLimits', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCamera, 'filmFit')
    def getFilmFit(self):
        # type: () -> Camera.FilmFit
        res = _f.getProxyResult(self, _api.MFnCamera, 'filmFit')
        return _f.ApiArgUtil._castResult(self, res, ('MFnCamera', 'FilmFit'), None)

    @_f.addApiDocs(_api.MFnCamera, 'filmFitOffset')
    def getFilmFitOffset(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'filmFitOffset')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'getFilmFrustum')
    def getFilmFrustum(self, distance, applyPanZoom=False):
        # type: (float, bool) -> Tuple[float, float, float, float]
        do, final_do, outTypes = _f.getDoArgs([distance, applyPanZoom], [('distance', 'double', 'in', u'linear'), ('hSize', 'double', 'out', None), ('vSize', 'double', 'out', None), ('hOffset', 'double', 'out', None), ('vOffset', 'double', 'out', None), ('applyPanZoom', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'getFilmFrustum', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCamera, 'filmRollOrder')
    def getFilmRollOrder(self):
        # type: () -> Camera.RollOrder
        res = _f.getProxyResult(self, _api.MFnCamera, 'filmRollOrder')
        return _f.ApiArgUtil._castResult(self, res, ('MFnCamera', 'RollOrder'), None)

    @_f.addApiDocs(_api.MFnCamera, 'filmRollValue')
    def getFilmRollValue(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'filmRollValue')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'filmTranslateH')
    def getFilmTranslateH(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'filmTranslateH')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'filmTranslateV')
    def getFilmTranslateV(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'filmTranslateV')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'focalLength')
    def getFocalLength(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'focalLength')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'getFocalLengthLimits')
    def getFocalLengthLimits(self):
        # type: () -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('min', 'double', 'out', None), ('max', 'double', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'getFocalLengthLimits', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCamera, 'focusDistance')
    def getFocusDistance(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'focusDistance')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addMelDocs('camera', 'homeCommand')
    def getHomeCommand(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'homeCommand')
        return res

    @_f.addApiDocs(_api.MFnCamera, 'horizontalFieldOfView')
    def getHorizontalFieldOfView(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'horizontalFieldOfView')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'angular')

    @_f.addApiDocs(_api.MFnCamera, 'horizontalFilmAperture')
    def getHorizontalFilmAperture(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'horizontalFilmAperture')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'horizontalFilmOffset')
    def getHorizontalFilmOffset(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'horizontalFilmOffset')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'horizontalPan')
    def getHorizontalPan(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'horizontalPan')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'horizontalRollPivot')
    def getHorizontalRollPivot(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'horizontalRollPivot')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnCamera, 'horizontalShake')
    def getHorizontalShake(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'horizontalShake')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('camera', 'journalCommand')
    def getJournalCommand(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'journalCommand')
        return res

    @_f.addApiDocs(_api.MFnCamera, 'lensSqueezeRatio')
    def getLensSqueezeRatio(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'lensSqueezeRatio')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('camera', 'lockTransform')
    def getLockTransform(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'lockTransform')
        return res

    @_f.addApiDocs(_api.MFnCamera, 'nearClippingPlane')
    def getNearClipPlane(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'nearClippingPlane')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnCamera, 'nearFocusDistance')
    def getNearFocusDistance(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'nearFocusDistance')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnCamera, 'orthoWidth')
    def getOrthoWidth(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'orthoWidth')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'overscan')
    def getOverscan(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'overscan')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'panZoomEnabled')
    def getPanZoomEnabled(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'panZoomEnabled')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'getPortFieldOfView')
    def getPortFieldOfView(self, width, height):
        # type: (int, int) -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([width, height], [('width', 'int', 'in', None), ('height', 'int', 'in', None), ('horizontalFOV', 'double', 'out', u'angular'), ('verticalFOV', 'double', 'out', u'angular')])
        res = _f.getProxyResult(self, _api.MFnCamera, 'getPortFieldOfView', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCamera, 'postScale')
    def getPostScale(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'postScale')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'preScale')
    def getPreScale(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'preScale')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'renderPanZoom')
    def getRenderPanZoom(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'renderPanZoom')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'getRenderingFrustum')
    def getRenderingFrustum(self, windowAspect):
        # type: (float) -> Tuple[float, float, float, float]
        do, final_do, outTypes = _f.getDoArgs([windowAspect], [('windowAspect', 'double', 'in', None), ('left', 'double', 'out', None), ('right', 'double', 'out', None), ('bottom', 'double', 'out', None), ('top', 'double', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'getRenderingFrustum', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCamera, 'shakeEnabled')
    def getShakeEnabled(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'shakeEnabled')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'shakeOverscan')
    def getShakeOverscan(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'shakeOverscan')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'shakeOverscanEnabled')
    def getShakeOverscanEnabled(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'shakeOverscanEnabled')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'shutterAngle')
    def getShutterAngle(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'shutterAngle')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'angular')

    @_f.addMelDocs('camera', 'startupCamera')
    def getStartupCamera(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'startupCamera')
        return res

    @_f.addApiDocs(_api.MFnCamera, 'stereoHIT')
    def getStereoHIT(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'stereoHIT')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'stereoHITEnabled')
    def getStereoHITEnabled(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'stereoHITEnabled')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'tumblePivot')
    def getTumblePivot(self):
        # type: () -> Point
        res = _f.getProxyResult(self, _api.MFnCamera, 'tumblePivot')
        return _f.ApiArgUtil._castResult(self, res, 'MPoint', None)

    @_f.addApiDocs(_api.MFnCamera, 'usePivotAsLocalSpace')
    def getUsePivotAsLocalSpace(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'usePivotAsLocalSpace')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'verticalFieldOfView')
    def getVerticalFieldOfView(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'verticalFieldOfView')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'angular')

    @_f.addApiDocs(_api.MFnCamera, 'verticalFilmAperture')
    def getVerticalFilmAperture(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'verticalFilmAperture')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'verticalFilmOffset')
    def getVerticalFilmOffset(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'verticalFilmOffset')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'verticalPan')
    def getVerticalPan(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'verticalPan')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'verticalRollPivot')
    def getVerticalRollPivot(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'verticalRollPivot')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnCamera, 'verticalShake')
    def getVerticalShake(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'verticalShake')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'getViewParameters')
    def getViewParameters(self, windowAspect, applyOverscan=False, applySqueeze=False, applyPanZoom=False):
        # type: (float, bool, bool, bool) -> Tuple[float, float, float, float]
        do, final_do, outTypes = _f.getDoArgs([windowAspect, applyOverscan, applySqueeze, applyPanZoom], [('windowAspect', 'double', 'in', None), ('apertureX', 'double', 'out', None), ('apertureY', 'double', 'out', None), ('offsetX', 'double', 'out', None), ('offsetY', 'double', 'out', None), ('applyOverscan', 'bool', 'in', None), ('applySqueeze', 'bool', 'in', None), ('applyPanZoom', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'getViewParameters', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCamera, 'getViewingFrustum')
    def getViewingFrustum(self, windowAspect, applyOverscan=False, applySqueeze=False, applyPanZoom=False):
        # type: (float, bool, bool, bool) -> Tuple[float, float, float, float]
        do, final_do, outTypes = _f.getDoArgs([windowAspect, applyOverscan, applySqueeze, applyPanZoom], [('windowAspect', 'double', 'in', None), ('left', 'double', 'out', None), ('right', 'double', 'out', None), ('bottom', 'double', 'out', None), ('top', 'double', 'out', None), ('applyOverscan', 'bool', 'in', None), ('applySqueeze', 'bool', 'in', None), ('applyPanZoom', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'getViewingFrustum', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('camera', 'worldCenterOfInterest')
    def getWorldCenterOfInterest(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'worldCenterOfInterest')
        return res

    @_f.addMelDocs('camera', 'worldUp')
    def getWorldUp(self, **kwargs):
        res = _f.asQuery(self, rendering.camera, kwargs, 'worldUp')
        return res

    @_f.addApiDocs(_api.MFnCamera, 'zoom')
    def getZoom(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnCamera, 'zoom')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnCamera, 'hasSamePerspective')
    def hasSamePerspective(self, otherCamera):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([otherCamera], [('otherCamera', 'MDagPath', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'hasSamePerspective', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'isClippingPlanes')
    def isClippingPlanes(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'isClippingPlanes')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'isDepthOfField')
    def isDepthOfField(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'isDepthOfField')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'isDisplayFilmGate')
    def isDisplayFilmGate(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'isDisplayFilmGate')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'isDisplayGateMask')
    def isDisplayGateMask(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'isDisplayGateMask')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.deprecated
    def isMotionBlur(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'isMotionBlur')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'isMotionBlur')
    def isMotionBlurred(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'isMotionBlur')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'isOrtho')
    def isOrtho(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'isOrtho')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'isVerticalLock')
    def isVerticalLock(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnCamera, 'isVerticalLock')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnCamera, 'postProjectionMatrix')
    def postProjectionMatrix(self):
        # type: () -> FloatMatrix
        res = _f.getProxyResult(self, _api.MFnCamera, 'postProjectionMatrix')
        return _f.ApiArgUtil._castResult(self, res, 'MFloatMatrix', None)

    @_f.addApiDocs(_api.MFnCamera, 'projectionMatrix')
    def projectionMatrix(self):
        # type: () -> FloatMatrix
        res = _f.getProxyResult(self, _api.MFnCamera, 'projectionMatrix')
        return _f.ApiArgUtil._castResult(self, res, 'MFloatMatrix', None)

    @_f.addApiDocs(_api.MFnCamera, 'rightDirection')
    def rightDirection(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'rightDirection', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', None)
        return res

    @_f.deprecated
    def set(self, wsEyeLocation, wsViewDirection, wsUpDirection, horizFieldOfView, aspectRatio):
        # type: (Point, Vector, Vector, float, float) -> None
        do, final_do, outTypes = _f.getDoArgs([wsEyeLocation, wsViewDirection, wsUpDirection, horizFieldOfView, aspectRatio], [('wsEyeLocation', 'MPoint', 'in', None), ('wsViewDirection', 'MVector', 'in', None), ('wsUpDirection', 'MVector', 'in', None), ('horizFieldOfView', 'double', 'in', None), ('aspectRatio', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'set', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setAspectRatio')
    def setAspectRatio(self, aspectRatio):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([aspectRatio], [('aspectRatio', 'double', 'in', None)], self.getAspectRatio, self.setAspectRatio, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setAspectRatio', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setCameraScale')
    def setCameraScale(self, scale):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([scale], [('scale', 'double', 'in', None)], self.getCameraScale, self.setCameraScale, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setCameraScale', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setCenterOfInterest')
    def setCenterOfInterest(self, dist):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([dist], [('dist', 'double', 'in', u'linear')], self.getCenterOfInterest, self.setCenterOfInterest, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setCenterOfInterest', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setCenterOfInterestPoint')
    def setCenterOfInterestPoint(self, centerOfInterest, space='preTransform'):
        # type: (Point, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([centerOfInterest, space], [('centerOfInterest', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getCenterOfInterestPoint, self.setCenterOfInterestPoint, ['space'])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setCenterOfInterestPoint', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setClippingPlanes')
    def setClippingPlanes(self, ClippingPlanes):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([ClippingPlanes], [('ClippingPlanes', 'bool', 'in', None)], self.isClippingPlanes, self.setClippingPlanes, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setClippingPlanes', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setDepthOfField')
    def setDepthOfField(self, depthOfField):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([depthOfField], [('depthOfField', 'bool', 'in', None)], self.isDepthOfField, self.setDepthOfField, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setDepthOfField', final_do)
        return res

    @_f.addMelDocs('camera', 'displayFieldChart')
    def setDisplayFieldChart(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'displayFieldChart', val)

    @_f.addApiDocs(_api.MFnCamera, 'setDisplayFilmGate')
    def setDisplayFilmGate(self, displayFilmGate):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([displayFilmGate], [('displayFilmGate', 'bool', 'in', None)], self.isDisplayFilmGate, self.setDisplayFilmGate, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setDisplayFilmGate', final_do)
        return res

    @_f.addMelDocs('camera', 'displayFilmOrigin')
    def setDisplayFilmOrigin(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'displayFilmOrigin', val)

    @_f.addMelDocs('camera', 'displayFilmPivot')
    def setDisplayFilmPivot(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'displayFilmPivot', val)

    @_f.addApiDocs(_api.MFnCamera, 'setDisplayGateMask')
    def setDisplayGateMask(self, displayGateMask):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([displayGateMask], [('displayGateMask', 'bool', 'in', None)], self.isDisplayGateMask, self.setDisplayGateMask, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setDisplayGateMask', final_do)
        return res

    @_f.addMelDocs('camera', 'displayResolution')
    def setDisplayResolution(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'displayResolution', val)

    @_f.addMelDocs('camera', 'displaySafeAction')
    def setDisplaySafeAction(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'displaySafeAction', val)

    @_f.addMelDocs('camera', 'displaySafeTitle')
    def setDisplaySafeTitle(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'displaySafeTitle', val)

    @_f.addApiDocs(_api.MFnCamera, 'setEyePoint')
    def setEyePoint(self, eyeLocation, space='preTransform'):
        # type: (Point, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([eyeLocation, space], [('eyeLocation', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getEyePoint, self.setEyePoint, ['space'])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setEyePoint', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFStop')
    def setFStop(self, fStop):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([fStop], [('fStop', 'double', 'in', None)], self.getFStop, self.setFStop, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFStop', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFarClippingPlane')
    def setFarClipPlane(self, dFar):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([dFar], [('dFar', 'double', 'in', u'linear')], self.getFarClipPlane, self.setFarClipPlane, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFarClippingPlane', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFarFocusDistance')
    def setFarFocusDistance(self, farFocusDistance):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([farFocusDistance], [('farFocusDistance', 'double', 'in', u'linear')], self.getFarFocusDistance, self.setFarFocusDistance, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFarFocusDistance', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFilmFit')
    def setFilmFit(self, filmFit):
        # type: (Camera.FilmFit) -> None
        do, final_do, outTypes = _f.processApiArgs([filmFit], [('filmFit', ('MFnCamera', 'FilmFit'), 'in', None)], self.getFilmFit, self.setFilmFit, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFilmFit', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFilmFitOffset')
    def setFilmFitOffset(self, filmFitOffset):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([filmFitOffset], [('filmFitOffset', 'double', 'in', None)], self.getFilmFitOffset, self.setFilmFitOffset, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFilmFitOffset', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFilmRollOrder')
    def setFilmRollOrder(self, filmRollOrder):
        # type: (Camera.RollOrder) -> None
        do, final_do, outTypes = _f.processApiArgs([filmRollOrder], [('filmRollOrder', ('MFnCamera', 'RollOrder'), 'in', None)], self.getFilmRollOrder, self.setFilmRollOrder, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFilmRollOrder', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFilmRollValue')
    def setFilmRollValue(self, filmRollValue):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([filmRollValue], [('filmRollValue', 'double', 'in', None)], self.getFilmRollValue, self.setFilmRollValue, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFilmRollValue', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFilmTranslateH')
    def setFilmTranslateH(self, translate):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([translate], [('translate', 'double', 'in', None)], self.getFilmTranslateH, self.setFilmTranslateH, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFilmTranslateH', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFilmTranslateV')
    def setFilmTranslateV(self, translate):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([translate], [('translate', 'double', 'in', None)], self.getFilmTranslateV, self.setFilmTranslateV, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFilmTranslateV', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFocalLength')
    def setFocalLength(self, focalLength):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([focalLength], [('focalLength', 'double', 'in', None)], self.getFocalLength, self.setFocalLength, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFocalLength', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setFocusDistance')
    def setFocusDistance(self, distance):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([distance], [('distance', 'double', 'in', u'linear')], self.getFocusDistance, self.setFocusDistance, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setFocusDistance', final_do)
        return res

    @_f.addMelDocs('camera', 'homeCommand')
    def setHomeCommand(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'homeCommand', val)

    @_f.addApiDocs(_api.MFnCamera, 'setHorizontalFieldOfView')
    def setHorizontalFieldOfView(self, fov):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([fov], [('fov', 'double', 'in', u'angular')], self.getHorizontalFieldOfView, self.setHorizontalFieldOfView, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setHorizontalFieldOfView', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setHorizontalFilmAperture')
    def setHorizontalFilmAperture(self, hFilmAperture):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([hFilmAperture], [('hFilmAperture', 'double', 'in', None)], self.getHorizontalFilmAperture, self.setHorizontalFilmAperture, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setHorizontalFilmAperture', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setHorizontalFilmOffset')
    def setHorizontalFilmOffset(self, hOffset):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([hOffset], [('hOffset', 'double', 'in', None)], self.getHorizontalFilmOffset, self.setHorizontalFilmOffset, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setHorizontalFilmOffset', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setHorizontalPan')
    def setHorizontalPan(self, hPan):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([hPan], [('hPan', 'double', 'in', None)], self.getHorizontalPan, self.setHorizontalPan, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setHorizontalPan', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setHorizontalRollPivot')
    def setHorizontalRollPivot(self, horizontalRollPivot):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([horizontalRollPivot], [('horizontalRollPivot', 'double', 'in', u'linear')], self.getHorizontalRollPivot, self.setHorizontalRollPivot, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setHorizontalRollPivot', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setHorizontalShake')
    def setHorizontalShake(self, hOffset):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([hOffset], [('hOffset', 'double', 'in', None)], self.getHorizontalShake, self.setHorizontalShake, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setHorizontalShake', final_do)
        return res

    @_f.addMelDocs('camera', 'journalCommand')
    def setJournalCommand(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'journalCommand', val)

    @_f.addApiDocs(_api.MFnCamera, 'setLensSqueezeRatio')
    def setLensSqueezeRatio(self, aspectRatio):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([aspectRatio], [('aspectRatio', 'double', 'in', None)], self.getLensSqueezeRatio, self.setLensSqueezeRatio, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setLensSqueezeRatio', final_do)
        return res

    @_f.addMelDocs('camera', 'lockTransform')
    def setLockTransform(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'lockTransform', val)

    @_f.deprecated
    def setMotionBlur(self, motionBlur):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([motionBlur], [('motionBlur', 'bool', 'in', None)], self.isMotionBlurred, self.setMotionBlur, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setMotionBlur', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setMotionBlur')
    def setMotionBlurred(self, motionBlur):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([motionBlur], [('motionBlur', 'bool', 'in', None)], self.isMotionBlurred, self.setMotionBlurred, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setMotionBlur', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setNearClippingPlane')
    def setNearClipPlane(self, dNear):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([dNear], [('dNear', 'double', 'in', u'linear')], self.getNearClipPlane, self.setNearClipPlane, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setNearClippingPlane', final_do)
        return res

    @_f.deprecated
    def setNearFarClippingPlanes(self, dNear, dFar):
        # type: (float, float) -> None
        do, final_do, outTypes = _f.getDoArgs([dNear, dFar], [('dNear', 'double', 'in', u'linear'), ('dFar', 'double', 'in', u'linear')])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setNearFarClippingPlanes', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setNearFocusDistance')
    def setNearFocusDistance(self, nearFocusDistance):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([nearFocusDistance], [('nearFocusDistance', 'double', 'in', u'linear')], self.getNearFocusDistance, self.setNearFocusDistance, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setNearFocusDistance', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setIsOrtho')
    def setOrtho(self, orthoState):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([orthoState], [('orthoState', 'bool', 'in', None)], self.isOrtho, self.setOrtho, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setIsOrtho', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setOrthoWidth')
    def setOrthoWidth(self, orthoWidth):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([orthoWidth], [('orthoWidth', 'double', 'in', None)], self.getOrthoWidth, self.setOrthoWidth, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setOrthoWidth', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setOverscan')
    def setOverscan(self, overscan):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([overscan], [('overscan', 'double', 'in', None)], self.getOverscan, self.setOverscan, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setOverscan', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setPanZoomEnabled')
    def setPanZoomEnabled(self, enabled):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enabled], [('enabled', 'bool', 'in', None)], self.getPanZoomEnabled, self.setPanZoomEnabled, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setPanZoomEnabled', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setPostScale')
    def setPostScale(self, sf):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([sf], [('sf', 'double', 'in', None)], self.getPostScale, self.setPostScale, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setPostScale', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setPreScale')
    def setPreScale(self, sf):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([sf], [('sf', 'double', 'in', None)], self.getPreScale, self.setPreScale, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setPreScale', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setRenderPanZoom')
    def setRenderPanZoom(self, render):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([render], [('render', 'bool', 'in', None)], self.getRenderPanZoom, self.setRenderPanZoom, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setRenderPanZoom', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setShakeEnabled')
    def setShakeEnabled(self, enabled):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enabled], [('enabled', 'bool', 'in', None)], self.getShakeEnabled, self.setShakeEnabled, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setShakeEnabled', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setShakeOverscan')
    def setShakeOverscan(self, overscan):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([overscan], [('overscan', 'double', 'in', None)], self.getShakeOverscan, self.setShakeOverscan, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setShakeOverscan', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setShakeOverscanEnabled')
    def setShakeOverscanEnabled(self, enabled):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enabled], [('enabled', 'bool', 'in', None)], self.getShakeOverscanEnabled, self.setShakeOverscanEnabled, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setShakeOverscanEnabled', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setShutterAngle')
    def setShutterAngle(self, shutterAngle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([shutterAngle], [('shutterAngle', 'double', 'in', u'angular')], self.getShutterAngle, self.setShutterAngle, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setShutterAngle', final_do)
        return res

    @_f.addMelDocs('camera', 'startupCamera')
    def setStartupCamera(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'startupCamera', val)

    @_f.addApiDocs(_api.MFnCamera, 'setStereoHIT')
    def setStereoHIT(self, hit):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([hit], [('hit', 'double', 'in', None)], self.getStereoHIT, self.setStereoHIT, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setStereoHIT', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setStereoHITEnabled')
    def setStereoHITEnabled(self, enabled):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enabled], [('enabled', 'bool', 'in', None)], self.getStereoHITEnabled, self.setStereoHITEnabled, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setStereoHITEnabled', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setTumblePivot')
    def setTumblePivot(self, point):
        # type: (Point) -> None
        do, final_do, outTypes = _f.processApiArgs([point], [('point', 'MPoint', 'in', None)], self.getTumblePivot, self.setTumblePivot, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setTumblePivot', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setUsePivotAsLocalSpace')
    def setUsePivotAsLocalSpace(self, how):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([how], [('how', 'bool', 'in', None)], self.getUsePivotAsLocalSpace, self.setUsePivotAsLocalSpace, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setUsePivotAsLocalSpace', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setVerticalFieldOfView')
    def setVerticalFieldOfView(self, fov):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([fov], [('fov', 'double', 'in', u'angular')], self.getVerticalFieldOfView, self.setVerticalFieldOfView, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setVerticalFieldOfView', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setVerticalFilmAperture')
    def setVerticalFilmAperture(self, vFilmAperture):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([vFilmAperture], [('vFilmAperture', 'double', 'in', None)], self.getVerticalFilmAperture, self.setVerticalFilmAperture, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setVerticalFilmAperture', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setVerticalFilmOffset')
    def setVerticalFilmOffset(self, vOffset):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([vOffset], [('vOffset', 'double', 'in', None)], self.getVerticalFilmOffset, self.setVerticalFilmOffset, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setVerticalFilmOffset', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setVerticalLock')
    def setVerticalLock(self, lockFlag):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([lockFlag], [('lockFlag', 'bool', 'in', None)], self.isVerticalLock, self.setVerticalLock, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setVerticalLock', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setVerticalPan')
    def setVerticalPan(self, vPan):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([vPan], [('vPan', 'double', 'in', None)], self.getVerticalPan, self.setVerticalPan, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setVerticalPan', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setVerticalRollPivot')
    def setVerticalRollPivot(self, verticalRollPivot):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([verticalRollPivot], [('verticalRollPivot', 'double', 'in', u'linear')], self.getVerticalRollPivot, self.setVerticalRollPivot, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setVerticalRollPivot', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'setVerticalShake')
    def setVerticalShake(self, vOffset):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([vOffset], [('vOffset', 'double', 'in', None)], self.getVerticalShake, self.setVerticalShake, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setVerticalShake', final_do)
        return res

    @_f.addMelDocs('camera', 'worldCenterOfInterest')
    def setWorldCenterOfInterest(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'worldCenterOfInterest', val)

    @_f.addMelDocs('camera', 'worldUp')
    def setWorldUp(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.camera, kwargs, 'worldUp', val)

    @_f.addApiDocs(_api.MFnCamera, 'setZoom')
    def setZoom(self, zoom):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([zoom], [('zoom', 'double', 'in', None)], self.getZoom, self.setZoom, [])
        res = _f.getProxyResult(self, _api.MFnCamera, 'setZoom', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'set')
    def setupCamera(self, wsEyeLocation, wsViewDirection, wsUpDirection, horizFieldOfView, aspectRatio):
        # type: (Point, Vector, Vector, float, float) -> None
        do, final_do, outTypes = _f.getDoArgs([wsEyeLocation, wsViewDirection, wsUpDirection, horizFieldOfView, aspectRatio], [('wsEyeLocation', 'MPoint', 'in', None), ('wsViewDirection', 'MVector', 'in', None), ('wsUpDirection', 'MVector', 'in', None), ('horizFieldOfView', 'double', 'in', None), ('aspectRatio', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'set', final_do)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'upDirection')
    def upDirection(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'upDirection', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', None)
        return res

    @_f.addApiDocs(_api.MFnCamera, 'viewDirection')
    def viewDirection(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCamera, 'viewDirection', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', None)
        return res
# ------ Do not edit above this line --------


class Transform(DagNode):
    _componentAttributes = {'rotatePivot': (general.Pivot, 'rotatePivot'),
                            'scalePivot': (general.Pivot, 'scalePivot')}
#    def __getattr__(self, attr):
#        try :
#            return super(general.PyNode, self).__getattr__(attr)
#        except AttributeError, msg:
#            try:
#                return self.getShape().attr(attr)
#            except AttributeError:
#                pass
#
#            # it doesn't exist on the class
#            try:
#                return self.attr(attr)
#            except MayaAttributeError, msg:
#                # try the shape
#                try: return self.getShape().attr(attr)
#                except AttributeError: pass
#                # since we're being called via __getattr__ we don't know whether the user was trying
#                # to get a class method or a maya attribute, so we raise a more generic AttributeError
#                raise AttributeError, msg

    def __getattr__(self, attr):
        """
        Checks in the following order:
            1. Functions on this node class
            2. Attributes on this node class
            3. Functions on this node class's shape
            4. Attributes on this node class's shape
        """
        try:
            # print "Transform.__getattr__(%r)" % attr
            # Functions through normal inheritance
            res = DependNode.__getattr__(self, attr)
        except AttributeError, e:
            # Functions via shape inheritance , and then, implicitly, Attributes
            for shape in self.getShapes():
                try:
                    return getattr(shape, attr)
                except AttributeError:
                    pass
            raise e
        return res

    def __setattr__(self, attr, val):
        """
        Checks in the following order:
            1. Functions on this node class
            2. Attributes on this node class
            3. Functions on this node class's shape
            4. Attributes on this node class's shape
        """
        try:
            # print "Transform.__setattr__", attr, val
            # Functions through normal inheritance
            return DependNode.__setattr__(self, attr, val)
        except AttributeError, e:
            # Functions via shape inheritance , and then, implicitly, Attributes
            # print "Trying shape"
            shape = self.getShape()
            if shape:
                try:
                    return setattr(shape, attr, val)
                except AttributeError:
                    pass
            raise e

    def attr(self, attr, checkShape=True):
        # type: (Any, Any) -> Attribute
        """
        when checkShape is enabled, if the attribute does not exist the
        transform but does on the shape, then the shape's attribute will
        be returned.

        Returns
        -------
        Attribute
        """
        # print "ATTR: Transform"
        try:
            res = self._attr(attr, checkShape)
        except general.MayaAttributeError, e:
            if checkShape:
                try:
                    res = self.getShape().attr(attr)
                except AttributeError:
                    raise e
            raise e
        return res

#    def __getattr__(self, attr):
#        if attr.startswith('__') and attr.endswith('__'):
#            return super(general.PyNode, self).__getattr__(attr)
#
#        at = Attribute( '%s.%s' % (self, attr) )
#
#        # if the attribute does not exist on this node try the shape node
#        if not at.exists():
#            try:
#                childAttr = getattr( self.getShape(), attr)
#                try:
#                    if childAttr.exists():
#                        return childAttr
#                except AttributeError:
#                    return childAttr
#            except (AttributeError,TypeError):
#                pass
#
#        return at
#
#    def __setattr__(self, attr,val):
#        if attr.startswith('_'):
#            attr = attr[1:]
#
#        at = Attribute( '%s.%s' % (self, attr) )
#
#        # if the attribute does not exist on this node try the shape node
#        if not at.exists():
#            try:
#                childAttr = getattr( self.getShape(), attr )
#                try:
#                    if childAttr.exists():
#                        return childAttr.set(val)
#                except AttributeError:
#                    return childAttr.set(val)
#            except (AttributeError,TypeError):
#                pass
#
#        return at.set(val)

    """
    def move( self, *args, **kwargs ):
        return move( self, *args, **kwargs )
    def scale( self, *args, **kwargs ):
        return scale( self, *args, **kwargs )
    def rotate( self, *args, **kwargs ):
        return rotate( self, *args, **kwargs )
    def align( self, *args, **kwargs):
        args = (self,) + args
        cmds.align(self, *args, **kwargs)
    """
    # NOTE : removed this via proxyClass
#    # workaround for conflict with translate method on basestring
#    def _getTranslate(self):
#        return self.__getattr__("translate")
#    def _setTranslate(self, val):
#        return self.__setattr__("translate", val)
#    translate = property( _getTranslate , _setTranslate )

    def getShape(self, **kwargs):
        # type: (**Any) -> DagNode
        """
        Returns
        -------
        DagNode
        """
        kwargs['shapes'] = True
        try:
            return self.getChildren(**kwargs)[0]
        except IndexError:
            pass

    def getShapes(self, **kwargs):
        # type: (**Any) -> List[DagNode]
        """
        Returns
        -------
        List[DagNode]
        """
        kwargs['shapes'] = True
        return self.getChildren(**kwargs)

    def ungroup(self, **kwargs):
        return cmds.ungroup(self, **kwargs)


#    @_factories.editflag('xform','scale')
#    def setScale( self, val, **kwargs ):
#        cmds.xform( self, **kwargs )

#    @_factories.editflag('xform','rotation')
#    def setRotationOld( self, val, **kwargs ):
#        cmds.xform( self, **kwargs )
#
#    @_factories.editflag('xform','translation')
#    def setTranslationOld( self, val, **kwargs ):
#        cmds.xform( self, **kwargs )
#
#    @_factories.editflag('xform','scalePivot')
#    def setScalePivotOld( self, val, **kwargs ):
#        cmds.xform( self, **kwargs )
#
#    @_factories.editflag('xform','rotatePivot')
#    def setRotatePivotOld( self, val, **kwargs ):
#        cmds.xform( self, **kwargs )

#    @_factories.editflag('xform','pivots')
#    def setPivots( self, val, **kwargs ):
#        cmds.xform( self, **kwargs )

#    @_factories.editflag('xform','rotateAxis')
#    def setRotateAxisOld( self, val, **kwargs ):
#        cmds.xform( self, **kwargs )
#
#    @_factories.editflag('xform','shear')
#    def setShearingOld( self, val, **kwargs ):
#        cmds.xform( self, **kwargs )

    @_factories.addMelDocs('xform', 'rotateAxis')
    def setMatrix(self, val, **kwargs):
        """xform -scale"""
        kwargs['matrix'] = val
        cmds.xform(self, **kwargs)

#    @_factories.queryflag('xform','scale')
#    def getScaleOld( self, **kwargs ):
#        return datatypes.Vector( cmds.xform( self, **kwargs ) )

    def _getSpaceArg(self, space, kwargs):
        """for internal use only"""
        if kwargs.pop('worldSpace', kwargs.pop('ws', False)):
            space = 'world'
        elif kwargs.pop('objectSpace', kwargs.pop('os', False)):
            space = 'object'
        return space

    def _isRelativeArg(self, kwargs):

        isRelative = kwargs.pop('relative', kwargs.pop('r', None))
        if isRelative is None:
            isRelative = not kwargs.pop('absolute', kwargs.pop('a', True))
        return isRelative

#    @_factories.queryflag('xform','translation')
#    def getTranslationOld( self, **kwargs ):
#        return datatypes.Vector( cmds.xform( self, **kwargs ) )

    @_factories.addApiDocs(_api.MFnTransform, 'setTranslation')
    def setTranslation(self, vector, space='object', **kwargs):
        if self._isRelativeArg(kwargs):
            return self.translateBy(vector, space, **kwargs)
        space = self._getSpaceArg(space, kwargs)
        return self._setTranslation(vector, space=space)

    @_factories.addApiDocs(_api.MFnTransform, 'getTranslation')
    def getTranslation(self, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._getTranslation(space=space)

    @_factories.addApiDocs(_api.MFnTransform, 'translateBy')
    def translateBy(self, vector, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        curr = self._getTranslation(space)
        self._translateBy(vector, space)
        new = self._getTranslation(space)
        undoItem = _factories.ApiUndoItem(Transform.setTranslation, (self, new, space), (self, curr, space))
        _factories.apiUndo.append(undoItem)

    @_factories.addApiDocs(_api.MFnTransform, 'setScale')
    def setScale(self, scale, **kwargs):
        if self._isRelativeArg(kwargs):
            return self.scaleBy(scale, **kwargs)
        return self._setScale(scale)

    @_factories.addApiDocs(_api.MFnTransform, 'scaleBy')
    def scaleBy(self, scale, **kwargs):
        curr = self.getScale()
        self._scaleBy(scale)
        new = self.getScale()
        undoItem = _factories.ApiUndoItem(Transform.setScale, (self, new), (self, curr))
        _factories.apiUndo.append(undoItem)

    @_factories.addApiDocs(_api.MFnTransform, 'setShear')
    def setShear(self, shear, **kwargs):
        if self._isRelativeArg(kwargs):
            return self.shearBy(shear, **kwargs)
        return self._setShear(shear)

    @_factories.addApiDocs(_api.MFnTransform, 'shearBy')
    def shearBy(self, shear, **kwargs):
        curr = self.getShear()
        self._shearBy(shear)
        new = self.getShear()
        undoItem = _factories.ApiUndoItem(Transform.setShear, (self, new), (self, curr))
        _factories.apiUndo.append(undoItem)


#    @_factories.queryflag('xform','rotatePivot')
#    def getRotatePivotOld( self, **kwargs ):
#        return datatypes.Vector( cmds.xform( self, **kwargs ) )

    @_factories.addApiDocs(_api.MFnTransform, 'setRotatePivot')
    def setRotatePivot(self, point, space='object', balance=True, **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._setRotatePivot(point, space=space, balance=balance)

    @_factories.addApiDocs(_api.MFnTransform, 'rotatePivot')
    def getRotatePivot(self, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._getRotatePivot(space=space)

    @_factories.addApiDocs(_api.MFnTransform, 'setRotatePivotTranslation')
    def setRotatePivotTranslation(self, vector, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._setRotatePivotTranslation(vector, space=space)

    @_factories.addApiDocs(_api.MFnTransform, 'rotatePivotTranslation')
    def getRotatePivotTranslation(self, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._getRotatePivotTranslation(space=space)


#    @_factories.queryflag('xform','rotation')
#    def getRotationOld( self, **kwargs ):
#        return datatypes.Vector( cmds.xform( self, **kwargs ) )

    @_factories.addApiDocs(_api.MFnTransform, 'setRotation')
    def setRotation(self, rotation, space='object', **kwargs):
        '''
    Modifications:
      - rotation may be given as an EulerRotation, Quaternion, or iterable of 3
        or 4 components (to specify an euler/quaternion, respectively)
        '''
        # quaternions are the only method that support a space parameter
        if self._isRelativeArg(kwargs):
            return self.rotateBy(rotation, space, **kwargs)
        spaceIndex = datatypes.Spaces.getIndex(self._getSpaceArg(space, kwargs))

        if not isinstance(rotation, (_api.MQuaternion, _api.MEulerRotation)):
            rotation = list(rotation)
            if len(rotation) == 3:
                # using datatypes.Angle(x) means current angle-unit should be
                # respected
                rotation = [datatypes.Angle(x).asRadians() for x in rotation]
                rotation = _api.MEulerRotation(*rotation)
            elif len(rotation) == 4:
                rotation = _api.MQuaternion(*rotation)
            else:
                raise ValueError(
                    "rotation given to setRotation must have either 3 or 4 "
                    "elements (for euler or quaternion, respectively)")
        if isinstance(rotation, _api.MEulerRotation):
            # MFnTransform.setRotation doesn't have a (non-deprecated) override
            # which takes euler angles AND a transform space... this sort of
            # makes sense, since the "unique" information that euler angles can
            # potentially carry - ie, rotation > 360 degress - only really makes
            # sense within the "transform" space. So, only use EulerRotation if
            # we're using transform space...
            if datatypes.equivalentSpace(spaceIndex, _api.MSpace.kTransform,
                                         rotationOnly=True):
                self.__apimfn__().setRotation(rotation)
                return
            else:
                rotation = rotation.asQuaternion()
        self.__apimfn__().setRotation(rotation, spaceIndex)

#    @_factories.addApiDocs( _api.MFnTransform, 'getRotation' )
#    def getRotation(self, space='object', **kwargs):
#        # quaternions are the only method that support a space parameter
#        space = self._getSpaceArg(space, kwargs )
#        quat = _api.MQuaternion()
#        _api.MFnTransform(self.__apimfn__()).getRotation(quat, datatypes.Spaces.getIndex(space) )
#        return datatypes.EulerRotation( quat.asEulerRotation() )

    @_factories.addApiDocs(_api.MFnTransform, 'getRotation', overloadIndex=1)
    def getRotation(self, space='object', quaternion=False, **kwargs):
        '''
    Modifications:
      - added 'quaternion' keyword arg, to specify whether the result
        be returned as a Quaternion object, as opposed to the default
        EulerRotation object
      - added 'space' keyword arg, which defaults to 'object'
        '''
        # quaternions are the only method that support a space parameter
        space = self._getSpaceArg(space, kwargs)
        if space.lower() in ('object', 'pretransform', 'transform') and not quaternion:
            # In this case, we can just go straight to the EulerRotation,
            # without having to go through Quaternion - this means we will
            # get information like angles > 360 degrees
            euler = _api.MEulerRotation()
            self.__apimfn__().getRotation(euler)
            rot = datatypes.EulerRotation(euler)
        else:
            rot = self._getRotation(space=space)
            if not quaternion:
                rot = rot.asEulerRotation()
        if isinstance(rot, datatypes.EulerRotation):
            rot.setDisplayUnit(datatypes.Angle.getUIUnit())
        return rot

    @_factories.addApiDocs(_api.MFnTransform, 'rotateBy')
    def rotateBy(self, rotation, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        curr = self.getRotation(space)
        self._rotateBy(rotation, space)
        new = self.getRotation(space)
        undoItem = _factories.ApiUndoItem(Transform.setRotation,
                                          (self, new, space),
                                          (self, curr, space))
        _factories.apiUndo.append(undoItem)


#    @_factories.queryflag('xform','scalePivot')
#    def getScalePivotOld( self, **kwargs ):
#        return datatypes.Vector( cmds.xform( self, **kwargs ) )

    @_factories.addApiDocs(_api.MFnTransform, 'setScalePivot')
    def setScalePivot(self, point, space='object', balance=True, **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._setScalePivot(point, space=space, balance=balance)

    @_factories.addApiDocs(_api.MFnTransform, 'scalePivot')
    def getScalePivot(self, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._getScalePivot(space=space)

    @_factories.addApiDocs(_api.MFnTransform, 'setScalePivotTranslation')
    def setScalePivotTranslation(self, vector, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._setScalePivotTranslation(vector, space=space)

    @_factories.addApiDocs(_api.MFnTransform, 'scalePivotTranslation')
    def getScalePivotTranslation(self, space='object', **kwargs):
        space = self._getSpaceArg(space, kwargs)
        return self._getScalePivotTranslation(space=space)

    @_factories.queryflag('xform', 'pivots')
    def getPivots(self, **kwargs):
        res = cmds.xform(self, **kwargs)
        return (datatypes.Vector(res[:3]), datatypes.Vector(res[3:]))

    @_factories.queryflag('xform', 'rotateAxis')
    def getRotateAxis(self, **kwargs):
        return datatypes.Vector(cmds.xform(self, **kwargs))

#    @_factories.queryflag('xform','shear')
#    def getShearOld( self, **kwargs ):
#        return datatypes.Vector( cmds.xform( self, **kwargs ) )

    @_factories.queryflag('xform', 'matrix')
    def getMatrix(self, **kwargs):
        return datatypes.Matrix(cmds.xform(self, **kwargs))

    # TODO: create API equivalent of `xform -boundingBoxInvisible` so we can replace this with _api.
    def getBoundingBox(self, invisible=False, space='object'):
        # type: (Any, Any) -> BoundingBox
        """xform -boundingBox and xform -boundingBoxInvisible

        Returns
        -------
        BoundingBox
        """
        kwargs = {'query': True}
        if invisible:
            kwargs['boundingBoxInvisible'] = True
        else:
            kwargs['boundingBox'] = True
        if space == 'object':
            kwargs['objectSpace'] = True
        elif space == 'world':
            kwargs['worldSpace'] = True
        else:
            raise ValueError('unknown space %r' % space)

        res = cmds.xform(self, **kwargs)
        # return ( datatypes.Vector(res[:3]), datatypes.Vector(res[3:]) )
        return datatypes.BoundingBox(res[:3], res[3:])

    def getBoundingBoxMin(self, invisible=False, space='object'):
        # type: (Any, Any) -> Vector
        """
        Returns
        -------
        Vector
        """
        return self.getBoundingBox(invisible, space)[0]
        # return self.getBoundingBox(invisible).min()

    def getBoundingBoxMax(self, invisible=False, space='object'):
        # type: (Any, Any) -> Vector
        """
        Returns
        -------
        Vector
        """
        return self.getBoundingBox(invisible, space)[1]
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnTransform
    __melcmd__ = staticmethod(general.xform)
    __melcmd_isinfo__ = True
    __melcmdname__ = 'xform'
    __melnode__ = u'transform'
    __slots__ = ()
    LimitType = Enum('LimitType', {'scaleMinX': 0, 'kScaleMinX': 0, 'kScaleMaxX': 1, 'scaleMaxX': 1, 'scaleMinY': 2, 'kScaleMinY': 2, 'kScaleMaxY': 3, 'scaleMaxY': 3, 'scaleMinZ': 4, 'kScaleMinZ': 4, 'kScaleMaxZ': 5, 'scaleMaxZ': 5, 'shearMinXY': 6, 'kShearMinXY': 6, 'kShearMaxXY': 7, 'shearMaxXY': 7, 'shearMinXZ': 8, 'kShearMinXZ': 8, 'kShearMaxXZ': 9, 'shearMaxXZ': 9, 'shearMinYZ': 10, 'kShearMinYZ': 10, 'shearMaxYZ': 11, 'kShearMaxYZ': 11, 'rotateMinX': 12, 'kRotateMinX': 12, 'rotateMaxX': 13, 'kRotateMaxX': 13, 'rotateMinY': 14, 'kRotateMinY': 14, 'rotateMaxY': 15, 'kRotateMaxY': 15, 'rotateMinZ': 16, 'kRotateMinZ': 16, 'rotateMaxZ': 17, 'kRotateMaxZ': 17, 'translateMinX': 18, 'kTranslateMinX': 18, 'kTranslateMaxX': 19, 'translateMaxX': 19, 'translateMinY': 20, 'kTranslateMinY': 20, 'kTranslateMaxY': 21, 'translateMaxY': 21, 'translateMinZ': 22, 'kTranslateMinZ': 22, 'kTranslateMaxZ': 23, 'translateMaxZ': 23}, multiKeys=True, defaultKeys={0: 'scaleMinX', 1: 'scaleMaxX', 2: 'scaleMinY', 3: 'scaleMaxY', 4: 'scaleMinZ', 5: 'scaleMaxZ', 6: 'shearMinXY', 7: 'shearMaxXY', 8: 'shearMinXZ', 9: 'shearMaxXZ', 10: 'shearMinYZ', 11: 'shearMaxYZ', 12: 'rotateMinX', 13: 'rotateMaxX', 14: 'rotateMinY', 15: 'rotateMaxY', 16: 'rotateMinZ', 17: 'rotateMaxZ', 18: 'translateMinX', 19: 'translateMaxX', 20: 'translateMinY', 21: 'translateMaxY', 22: 'translateMinZ', 23: 'translateMaxZ'})

    @_f.addApiDocs(_api.MFnTransform, 'rotatePivot')
    def _getRotatePivot(self, space):
        # type: (datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'rotatePivot', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPoint', None)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'rotatePivotTranslation')
    def _getRotatePivotTranslation(self, space):
        # type: (datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'rotatePivotTranslation', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', 'linear')
        return res

    @_f.addApiDocs(_api.MFnTransform, 'getRotation')
    def _getRotation(self, space='transform'):
        # type: (datatypes.Space.Space) -> Quaternion
        do, final_do, outTypes = _f.getDoArgs([space], [('quaternion', 'MQuaternion', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'getRotation', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnTransform, 'scalePivot')
    def _getScalePivot(self, space):
        # type: (datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'scalePivot', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPoint', None)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'scalePivotTranslation')
    def _getScalePivotTranslation(self, space):
        # type: (datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'scalePivotTranslation', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', 'linear')
        return res

    @_f.addApiDocs(_api.MFnTransform, 'getTranslation')
    def _getTranslation(self, space):
        # type: (datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'getTranslation', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', 'linear')
        return res

    @_f.addApiDocs(_api.MFnTransform, 'rotateBy')
    def _rotateBy(self, rotation, space='transform'):
        # type: (EulerRotation, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.getDoArgs([rotation, space], [('rotation', 'MEulerRotation', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'rotateBy', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'scaleBy')
    def _scaleBy(self, scale):
        # type: (Tuple[float, float, float]) -> None
        do, final_do, outTypes = _f.getDoArgs([scale], [('scale', 'double__array3', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'scaleBy', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setRotatePivot')
    def _setRotatePivot(self, point, space, balance=True):
        # type: (Point, datatypes.Space.Space, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([point, space, balance], [('point', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None), ('balance', 'bool', 'in', None)], self._getRotatePivot, self._setRotatePivot, ['space'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setRotatePivot', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setRotatePivotTranslation')
    def _setRotatePivotTranslation(self, vector, space):
        # type: (Vector, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([vector, space], [('vector', 'MVector', 'in', u'linear'), ('space', ('MSpace', 'Space'), 'in', None)], self._getRotatePivotTranslation, self._setRotatePivotTranslation, ['space'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setRotatePivotTranslation', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setRotation')
    def _setRotation(self, quaternion, space='transform'):
        # type: (Quaternion, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([quaternion, space], [('quaternion', 'MQuaternion', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self._getRotation, self._setRotation, ['space'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setRotation', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setScale')
    def _setScale(self, scale):
        # type: (Tuple[float, float, float]) -> None
        do, final_do, outTypes = _f.processApiArgs([scale], [('scale', 'double__array3', 'in', None)], self.getScale, self._setScale, [])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setScale', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setScalePivot')
    def _setScalePivot(self, point, space, balance=True):
        # type: (Point, datatypes.Space.Space, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([point, space, balance], [('point', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None), ('balance', 'bool', 'in', None)], self._getScalePivot, self._setScalePivot, ['space'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setScalePivot', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setScalePivotTranslation')
    def _setScalePivotTranslation(self, vector, space):
        # type: (Vector, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([vector, space], [('vector', 'MVector', 'in', u'linear'), ('space', ('MSpace', 'Space'), 'in', None)], self._getScalePivotTranslation, self._setScalePivotTranslation, ['space'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setScalePivotTranslation', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setShear')
    def _setShear(self, shear):
        # type: (Tuple[float, float, float]) -> None
        do, final_do, outTypes = _f.processApiArgs([shear], [('shear', 'double__array3', 'in', None)], self.getShear, self._setShear, [])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setShear', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setTranslation')
    def _setTranslation(self, vector, space):
        # type: (Vector, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([vector, space], [('vector', 'MVector', 'in', u'linear'), ('space', ('MSpace', 'Space'), 'in', None)], self._getTranslation, self._setTranslation, ['space'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setTranslation', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'shearBy')
    def _shearBy(self, shear):
        # type: (Tuple[float, float, float]) -> None
        do, final_do, outTypes = _f.getDoArgs([shear], [('shear', 'double__array3', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'shearBy', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'translateBy')
    def _translateBy(self, vector, space):
        # type: (Vector, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.getDoArgs([vector, space], [('vector', 'MVector', 'in', u'linear'), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'translateBy', final_do)
        return res

    @_f.addMelDocs('xform', 'centerPivots')
    def centerPivots(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'centerPivots', val)

    @_f.addMelDocs('xform', 'centerPivotsOnComponents')
    def centerPivotsOnComponents(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'centerPivotsOnComponents', val)

    @_f.addApiDocs(_api.MFnTransform, 'clearRestPosition')
    def clearRestPosition(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnTransform, 'clearRestPosition')
        return res

    @_f.addMelDocs('xform', 'deletePriorHistory')
    def deletePriorHistory(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'deletePriorHistory', val)

    @_f.deprecated
    def enableLimit(self, type, flag):
        # type: (Transform.LimitType, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([type, flag], [('type', ('MFnTransform', 'LimitType'), 'in', None), ('flag', 'bool', 'in', None)], self.isLimited, self.enableLimit, ['type'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'enableLimit', final_do)
        return res

    @_f.addMelDocs('xform', 'boundingBoxInvisible')
    def getBoundingBoxInvisible(self, **kwargs):
        res = _f.asQuery(self, general.xform, kwargs, 'boundingBoxInvisible')
        return res

    @_f.addApiDocs(_api.MFnTransform, 'limitValue')
    def getLimit(self, type):
        # type: (Transform.LimitType) -> float
        do, final_do, outTypes = _f.getDoArgs([type], [('type', ('MFnTransform', 'LimitType'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'limitValue', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'restPosition')
    def getRestPosition(self):
        # type: () -> TransformationMatrix
        res = _f.getProxyResult(self, _api.MFnTransform, 'restPosition')
        return _f.ApiArgUtil._castResult(self, res, 'MTransformationMatrix', None)

    @_f.addApiDocs(_api.MFnTransform, 'rotationOrder')
    def getRotationOrder(self):
        # type: () -> datatypes.TransformationMatrix.RotationOrder
        res = _f.getProxyResult(self, _api.MFnTransform, 'rotationOrder')
        return _f.ApiArgUtil._castResult(self, res, ('MTransformationMatrix', 'RotationOrder'), None)

    @_f.deprecated
    def getRotationQuaternion(self, space='transform'):
        # type: (datatypes.Space.Space) -> Tuple[float, float, float, float]
        do, final_do, outTypes = _f.getDoArgs([space], [('x', 'double', 'out', None), ('y', 'double', 'out', None), ('z', 'double', 'out', None), ('w', 'double', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'getRotationQuaternion', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnTransform, 'getScale')
    def getScale(self):
        # type: () -> Tuple[float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('scale', 'double__array3', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'getScale', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnTransform, 'getShear')
    def getShear(self):
        # type: () -> Tuple[float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('shear', 'double__array3', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'getShear', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnTransform, 'transformation')
    def getTransformation(self):
        # type: () -> TransformationMatrix
        res = _f.getProxyResult(self, _api.MFnTransform, 'transformation')
        return _f.ApiArgUtil._castResult(self, res, 'MTransformationMatrix', None)

    @_f.addApiDocs(_api.MFnTransform, 'isLimited')
    def isLimited(self, type):
        # type: (Transform.LimitType) -> bool
        do, final_do, outTypes = _f.getDoArgs([type], [('type', ('MFnTransform', 'LimitType'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'isLimited', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.deprecated
    def limitValue(self, type):
        # type: (Transform.LimitType) -> float
        do, final_do, outTypes = _f.getDoArgs([type], [('type', ('MFnTransform', 'LimitType'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'limitValue', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addMelDocs('xform', 'preserveUV')
    def preserveUV(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'preserveUV', val)

    @_f.addMelDocs('xform', 'reflection')
    def reflection(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'reflection', val)

    @_f.addMelDocs('xform', 'reflectionAboutBBox')
    def reflectionAboutBBox(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'reflectionAboutBBox', val)

    @_f.addMelDocs('xform', 'reflectionAboutOrigin')
    def reflectionAboutOrigin(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'reflectionAboutOrigin', val)

    @_f.addMelDocs('xform', 'reflectionAboutX')
    def reflectionAboutX(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'reflectionAboutX', val)

    @_f.addMelDocs('xform', 'reflectionAboutY')
    def reflectionAboutY(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'reflectionAboutY', val)

    @_f.addMelDocs('xform', 'reflectionAboutZ')
    def reflectionAboutZ(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'reflectionAboutZ', val)

    @_f.addMelDocs('xform', 'reflectionTolerance')
    def reflectionTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'reflectionTolerance', val)

    @_f.addApiDocs(_api.MFnTransform, 'resetFromRestPosition')
    def resetFromRestPosition(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnTransform, 'resetFromRestPosition')
        return res

    @_f.deprecated
    def rotateByQuaternion(self, x, y, z, w, space='transform'):
        # type: (float, float, float, float, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.getDoArgs([x, y, z, w, space], [('x', 'double', 'in', None), ('y', 'double', 'in', None), ('z', 'double', 'in', None), ('w', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'rotateByQuaternion', final_do)
        return res

    @_f.deprecated
    def set(self, transform):
        # type: (TransformationMatrix) -> None
        do, final_do, outTypes = _f.processApiArgs([transform], [('transform', 'MTransformationMatrix', 'in', None)], self.getTransformation, self.set, [])
        res = _f.getProxyResult(self, _api.MFnTransform, 'set', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setLimit')
    def setLimit(self, type, value):
        # type: (Transform.LimitType, float) -> None
        do, final_do, outTypes = _f.processApiArgs([type, value], [('type', ('MFnTransform', 'LimitType'), 'in', None), ('value', 'double', 'in', u'linear')], self.getLimit, self.setLimit, ['type'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setLimit', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'enableLimit')
    def setLimited(self, type, flag):
        # type: (Transform.LimitType, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([type, flag], [('type', ('MFnTransform', 'LimitType'), 'in', None), ('flag', 'bool', 'in', None)], self.isLimited, self.setLimited, ['type'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'enableLimit', final_do)
        return res

    @_f.addMelDocs('xform', 'pivots')
    def setPivots(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'pivots', val)

    @_f.addApiDocs(_api.MFnTransform, 'setRestPosition')
    def setRestPosition(self, matrix):
        # type: (TransformationMatrix) -> None
        do, final_do, outTypes = _f.processApiArgs([matrix], [('matrix', 'MTransformationMatrix', 'in', None)], self.getRestPosition, self.setRestPosition, [])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setRestPosition', final_do)
        return res

    @_f.addMelDocs('xform', 'rotateAxis')
    def setRotateAxis(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'rotateAxis', val)

    @_f.deprecated
    def setRotateOrientation(self, quat, space, balance=True):
        # type: (Quaternion, datatypes.Space.Space, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([quat, space, balance], [('quat', 'MQuaternion', 'in', None), ('space', ('MSpace', 'Space'), 'in', None), ('balance', 'bool', 'in', None)], self._getRotateOrientation, self.setRotateOrientation, ['space'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setRotateOrientation', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'setRotationOrder')
    def setRotationOrder(self, order, reorder):
        # type: (datatypes.TransformationMatrix.RotationOrder, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([order, reorder], [('order', ('MTransformationMatrix', 'RotationOrder'), 'in', None), ('reorder', 'bool', 'in', None)], self.getRotationOrder, self.setRotationOrder, [])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setRotationOrder', final_do)
        return res

    @_f.deprecated
    def setRotationQuaternion(self, x, y, z, w, space='transform'):
        # type: (float, float, float, float, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([x, y, z, w, space], [('x', 'double', 'in', None), ('y', 'double', 'in', None), ('z', 'double', 'in', None), ('w', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getRotationQuaternion, self.setRotationQuaternion, ['space'])
        res = _f.getProxyResult(self, _api.MFnTransform, 'setRotationQuaternion', final_do)
        return res

    @_f.addApiDocs(_api.MFnTransform, 'set')
    def setTransformation(self, transform):
        # type: (TransformationMatrix) -> None
        do, final_do, outTypes = _f.processApiArgs([transform], [('transform', 'MTransformationMatrix', 'in', None)], self.getTransformation, self.setTransformation, [])
        res = _f.getProxyResult(self, _api.MFnTransform, 'set', final_do)
        return res

    @_f.deprecated
    def transformation(self):
        # type: () -> TransformationMatrix
        res = _f.getProxyResult(self, _api.MFnTransform, 'transformation')
        return _f.ApiArgUtil._castResult(self, res, 'MTransformationMatrix', None)

    @_f.addMelDocs('xform', 'zeroTransformPivots')
    def zeroTransformPivots(self, val=True, **kwargs):
        return _f.asEdit(self, general.xform, kwargs, 'zeroTransformPivots', val)
# ------ Do not edit above this line --------
        # return self.getBoundingBox(invisible).max()

#    def centerPivots(self, **kwargs):
#        """xform -centerPivots"""
#        kwargs['centerPivots'] = True
#        cmds.xform( self, **kwargs )
#
#    def zeroTransformPivots(self, **kwargs):
#        """xform -zeroTransformPivots"""
#        kwargs['zeroTransformPivots'] = True
#        cmds.xform( self, **kwargs )


class Joint(Transform):
    if not _factories.building:
        connect = animation.connectJoint
        disconnect = animation.disconnectJoint
        insert = animation.insertJoint
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnIkJoint
    __melcmd__ = staticmethod(animation.joint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'joint'
    __melnode__ = u'joint'
    __slots__ = ()
    if versions.current() >= versions.v2019:
        Axis = Enum('Axis', {'kXAxis': 0, 'XAxis': 0, 'YAxis': 1, 'kYAxis': 1, 'kZAxis': 2, 'ZAxis': 2, 'none': 3, 'kNone': 3}, multiKeys=True, defaultKeys={0: 'XAxis', 1: 'YAxis', 2: 'ZAxis', 3: 'none'})

    @_f.addMelDocs('joint', 'assumePreferredAngles')
    def assumePreferredAngles(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'assumePreferredAngles', val)

    @_f.addMelDocs('joint', 'children')
    def children(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'children', val)

    @_f.addMelDocs('joint', 'component')
    def component(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'component', val)

    @_f.addMelDocs('joint', 'angleX')
    def getAngleX(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'angleX')
        return res

    @_f.addMelDocs('joint', 'angleY')
    def getAngleY(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'angleY')
        return res

    @_f.addMelDocs('joint', 'angleZ')
    def getAngleZ(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'angleZ')
        return res

    @_f.addMelDocs('joint', 'degreeOfFreedom')
    def getDegreeOfFreedom(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'degreeOfFreedom')
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'getDegreesOfFreedom')
    def getDegreesOfFreedom(self):
        # type: () -> Tuple[bool, bool, bool]
        do, final_do, outTypes = _f.getDoArgs([], [('freeInX', 'bool', 'out', None), ('freeInY', 'bool', 'out', None), ('freeInZ', 'bool', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'getDegreesOfFreedom', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('joint', 'exists')
    def getExists(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'exists')
        return res

    @_f.addMelDocs('joint', 'limitSwitchX')
    def getLimitSwitchX(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'limitSwitchX')
        return res

    @_f.addMelDocs('joint', 'limitSwitchY')
    def getLimitSwitchY(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'limitSwitchY')
        return res

    @_f.addMelDocs('joint', 'limitSwitchZ')
    def getLimitSwitchZ(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'limitSwitchZ')
        return res

    @_f.addMelDocs('joint', 'limitX')
    def getLimitX(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'limitX')
        return res

    @_f.addMelDocs('joint', 'limitY')
    def getLimitY(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'limitY')
        return res

    @_f.addMelDocs('joint', 'limitZ')
    def getLimitZ(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'limitZ')
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'maxRotateDampXRange')
    def getMaxRotateDampXRange(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'maxRotateDampXRange')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'maxRotateDampXStrength')
    def getMaxRotateDampXStrength(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'maxRotateDampXStrength')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'maxRotateDampYRange')
    def getMaxRotateDampYRange(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'maxRotateDampYRange')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'maxRotateDampYStrength')
    def getMaxRotateDampYStrength(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'maxRotateDampYStrength')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'maxRotateDampZRange')
    def getMaxRotateDampZRange(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'maxRotateDampZRange')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'maxRotateDampZStrength')
    def getMaxRotateDampZStrength(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'maxRotateDampZStrength')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'minRotateDampXRange')
    def getMinRotateDampXRange(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'minRotateDampXRange')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'minRotateDampXStrength')
    def getMinRotateDampXStrength(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'minRotateDampXStrength')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'minRotateDampYRange')
    def getMinRotateDampYRange(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'minRotateDampYRange')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'minRotateDampYStrength')
    def getMinRotateDampYStrength(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'minRotateDampYStrength')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'minRotateDampZRange')
    def getMinRotateDampZRange(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'minRotateDampZRange')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'minRotateDampZStrength')
    def getMinRotateDampZStrength(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'minRotateDampZStrength')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkJoint, 'getOrientation')
    def getOrientation(self):
        # type: () -> Quaternion
        do, final_do, outTypes = _f.getDoArgs([], [('quaternion', 'MQuaternion', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'getOrientation', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('joint', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'radius')
        return res

    @_f.addMelDocs('joint', 'scaleCompensate')
    def getScaleCompensate(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'scaleCompensate')
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'getScaleOrientation')
    def getScaleOrientation(self):
        # type: () -> Quaternion
        do, final_do, outTypes = _f.getDoArgs([], [('quaternion', 'MQuaternion', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'getScaleOrientation', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnIkJoint, 'getSegmentScale')
    def getSegmentScale(self):
        # type: () -> Tuple[float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('scale', 'double__array3', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'getSegmentScale', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnIkJoint, 'getStiffness')
    def getStiffness(self):
        # type: () -> Tuple[float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('stiffness', 'double__array3', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'getStiffness', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('joint', 'stiffnessX')
    def getStiffnessX(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'stiffnessX')
        return res

    @_f.addMelDocs('joint', 'stiffnessY')
    def getStiffnessY(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'stiffnessY')
        return res

    @_f.addMelDocs('joint', 'stiffnessZ')
    def getStiffnessZ(self, **kwargs):
        res = _f.asQuery(self, animation.joint, kwargs, 'stiffnessZ')
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'hikJointName')
    def hikJointName(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'hikJointName')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.addMelDocs('joint', 'orientJoint')
    def orientJoint(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'orientJoint', val)

    @_f.addMelDocs('joint', 'secondaryAxisOrient')
    def secondaryAxisOrient(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'secondaryAxisOrient', val)

    @_f.addMelDocs('joint', 'angleX')
    def setAngleX(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'angleX', val)

    @_f.addMelDocs('joint', 'angleY')
    def setAngleY(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'angleY', val)

    @_f.addMelDocs('joint', 'angleZ')
    def setAngleZ(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'angleZ', val)

    @_f.addMelDocs('joint', 'degreeOfFreedom')
    def setDegreeOfFreedom(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'degreeOfFreedom', val)

    @_f.addApiDocs(_api.MFnIkJoint, 'setDegreesOfFreedom')
    def setDegreesOfFreedom(self, freeInX, freeInY, freeInZ):
        # type: (bool, bool, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([freeInX, freeInY, freeInZ], [('freeInX', 'bool', 'in', None), ('freeInY', 'bool', 'in', None), ('freeInZ', 'bool', 'in', None)], self.getDegreesOfFreedom, self.setDegreesOfFreedom, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setDegreesOfFreedom', final_do)
        return res

    @_f.addMelDocs('joint', 'limitSwitchX')
    def setLimitSwitchX(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'limitSwitchX', val)

    @_f.addMelDocs('joint', 'limitSwitchY')
    def setLimitSwitchY(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'limitSwitchY', val)

    @_f.addMelDocs('joint', 'limitSwitchZ')
    def setLimitSwitchZ(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'limitSwitchZ', val)

    @_f.addMelDocs('joint', 'limitX')
    def setLimitX(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'limitX', val)

    @_f.addMelDocs('joint', 'limitY')
    def setLimitY(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'limitY', val)

    @_f.addMelDocs('joint', 'limitZ')
    def setLimitZ(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'limitZ', val)

    @_f.addApiDocs(_api.MFnIkJoint, 'setMaxRotateDampXRange')
    def setMaxRotateDampXRange(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMaxRotateDampXRange, self.setMaxRotateDampXRange, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMaxRotateDampXRange', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMaxRotateDampXStrength')
    def setMaxRotateDampXStrength(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMaxRotateDampXStrength, self.setMaxRotateDampXStrength, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMaxRotateDampXStrength', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMaxRotateDampYRange')
    def setMaxRotateDampYRange(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMaxRotateDampYRange, self.setMaxRotateDampYRange, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMaxRotateDampYRange', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMaxRotateDampYStrength')
    def setMaxRotateDampYStrength(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMaxRotateDampYStrength, self.setMaxRotateDampYStrength, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMaxRotateDampYStrength', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMaxRotateDampZRange')
    def setMaxRotateDampZRange(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMaxRotateDampZRange, self.setMaxRotateDampZRange, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMaxRotateDampZRange', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMaxRotateDampZStrength')
    def setMaxRotateDampZStrength(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMaxRotateDampZStrength, self.setMaxRotateDampZStrength, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMaxRotateDampZStrength', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMinRotateDampXRange')
    def setMinRotateDampXRange(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMinRotateDampXRange, self.setMinRotateDampXRange, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMinRotateDampXRange', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMinRotateDampXStrength')
    def setMinRotateDampXStrength(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMinRotateDampXStrength, self.setMinRotateDampXStrength, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMinRotateDampXStrength', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMinRotateDampYRange')
    def setMinRotateDampYRange(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMinRotateDampYRange, self.setMinRotateDampYRange, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMinRotateDampYRange', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMinRotateDampYStrength')
    def setMinRotateDampYStrength(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMinRotateDampYStrength, self.setMinRotateDampYStrength, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMinRotateDampYStrength', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMinRotateDampZRange')
    def setMinRotateDampZRange(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMinRotateDampZRange, self.setMinRotateDampZRange, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMinRotateDampZRange', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setMinRotateDampZStrength')
    def setMinRotateDampZStrength(self, angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([angle], [('angle', 'double', 'in', None)], self.getMinRotateDampZStrength, self.setMinRotateDampZStrength, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setMinRotateDampZStrength', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setOrientation')
    def setOrientation(self, quaternion):
        # type: (Quaternion) -> None
        do, final_do, outTypes = _f.processApiArgs([quaternion], [('quaternion', 'MQuaternion', 'in', None)], self.getOrientation, self.setOrientation, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setOrientation', final_do)
        return res

    @_f.addMelDocs('joint', 'setPreferredAngles')
    def setPreferredAngles(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'setPreferredAngles', val)

    @_f.addMelDocs('joint', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'radius', val)

    @_f.addMelDocs('joint', 'scaleCompensate')
    def setScaleCompensate(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'scaleCompensate', val)

    @_f.addApiDocs(_api.MFnIkJoint, 'setScaleOrientation')
    def setScaleOrientation(self, quaternion):
        # type: (Quaternion) -> None
        do, final_do, outTypes = _f.processApiArgs([quaternion], [(u'quaternion', 'MQuaternion', u'in', None)], self.getScaleOrientation, self.setScaleOrientation, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setScaleOrientation', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setSegmentScale')
    def setSegmentScale(self, scale):
        # type: (Tuple[float, float, float]) -> None
        do, final_do, outTypes = _f.processApiArgs([scale], [('scale', 'double__array3', 'in', None)], self.getSegmentScale, self.setSegmentScale, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setSegmentScale', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkJoint, 'setStiffness')
    def setStiffness(self, stiffness):
        # type: (Tuple[float, float, float]) -> None
        do, final_do, outTypes = _f.processApiArgs([stiffness], [('stiffness', 'double__array3', 'in', None)], self.getStiffness, self.setStiffness, [])
        res = _f.getProxyResult(self, _api.MFnIkJoint, 'setStiffness', final_do)
        return res

    @_f.addMelDocs('joint', 'stiffnessX')
    def setStiffnessX(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'stiffnessX', val)

    @_f.addMelDocs('joint', 'stiffnessY')
    def setStiffnessY(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'stiffnessY', val)

    @_f.addMelDocs('joint', 'stiffnessZ')
    def setStiffnessZ(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'stiffnessZ', val)

    @_f.addMelDocs('joint', 'symmetry')
    def symmetry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'symmetry', val)

    @_f.addMelDocs('joint', 'symmetryAxis')
    def symmetryAxis(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'symmetryAxis', val)

    @_f.addMelDocs('joint', 'zeroScaleOrient')
    def zeroScaleOrient(self, val=True, **kwargs):
        return _f.asEdit(self, animation.joint, kwargs, 'zeroScaleOrient', val)
# ------ Do not edit above this line --------


class FluidEmitter(Transform):
    if not _factories.building:
        fluidVoxelInfo = effects.fluidVoxelInfo
        loadFluid = effects.loadFluid
        resampleFluid = effects.resampleFluid
        saveFluid = effects.saveFluid
        setFluidAttr = effects.setFluidAttr
        getFluidAttr = effects.getFluidAttr


class RenderLayer(DependNode):

    def listMembers(self, fullNames=True):
        if fullNames:
            return map(general.PyNode, _util.listForNone(cmds.editRenderLayerMembers(self, q=1, fullNames=True)))
        else:
            return _util.listForNone(cmds.editRenderLayerMembers(self, q=1, fullNames=False))

    def addMembers(self, members, noRecurse=True):
        cmds.editRenderLayerMembers(self, members, noRecurse=noRecurse)

    def removeMembers(self, members):
        cmds.editRenderLayerMembers(self, members, remove=True)

    def listAdjustments(self):
        return map(general.PyNode, _util.listForNone(cmds.editRenderLayerAdjustment(self, layer=1, q=1)))

    def addAdjustments(self, members):
        return cmds.editRenderLayerAdjustment(members, layer=self)

    def removeAdjustments(self, members):
        return cmds.editRenderLayerAdjustment(members, layer=self, remove=True)

    def setCurrent(self):
        cmds.editRenderLayerGlobals(currentRenderLayer=self)
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnRenderLayer
    __melnode__ = u'renderLayer'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnRenderLayer, 'adjustmentPlug')
    def adjustmentPlug(self, scenePlug):
        # type: (Attribute) -> Attribute
        do, final_do, outTypes = _f.getDoArgs([scenePlug], [('scenePlug', 'MPlug', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnRenderLayer, 'adjustmentPlug', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPlug', None)
        return res

    @classmethod
    @_f.addApiDocs(_api.MFnRenderLayer, 'currentLayer')
    def currentLayer(self):
        # type: () -> general.PyNode
        res = _api.MFnRenderLayer.currentLayer()
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @classmethod
    @_f.addApiDocs(_api.MFnRenderLayer, 'defaultRenderLayer')
    def defaultRenderLayer(self):
        # type: () -> general.PyNode
        res = _api.MFnRenderLayer.defaultRenderLayer()
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnRenderLayer, 'externalRenderPasses')
    def externalRenderPasses(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [(u'renderPassArray', 'MObjectArray', u'out', None)])
        res = _f.getProxyResult(self, _api.MFnRenderLayer, 'externalRenderPasses', final_do)
        return _f.processApiResult(res, outTypes, do)

    @classmethod
    @_f.addApiDocs(_api.MFnRenderLayer, 'findLayerByName')
    def findLayerByName(self, renderLayer):
        # type: (unicode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([renderLayer], [('renderLayer', 'MString', 'in', None)])
        res = _api.MFnRenderLayer.findLayerByName(*final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnRenderLayer, 'inCurrentRenderLayer')
    def inCurrentRenderLayer(self, objectPath):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([objectPath], [('objectPath', 'MDagPath', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnRenderLayer, 'inCurrentRenderLayer', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnRenderLayer, 'inLayer')
    def inLayer(self, transform):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([transform], [('transform', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnRenderLayer, 'inLayer', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnRenderLayer, 'isPlugAdjusted')
    def isPlugAdjusted(self, scenePlug):
        # type: (Attribute) -> bool
        do, final_do, outTypes = _f.getDoArgs([scenePlug], [('scenePlug', 'MPlug', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnRenderLayer, 'isPlugAdjusted', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnRenderLayer, 'layerChildren')
    def layerChildren(self, recurse=False):
        # type: (bool) -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([recurse], [(u'array', 'MObjectArray', u'out', None), (u'recurse', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnRenderLayer, 'layerChildren', final_do)
        return _f.processApiResult(res, outTypes, do)

    @classmethod
    @_f.addApiDocs(_api.MFnRenderLayer, 'listAllRenderLayers')
    def listAllRenderLayers(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [(u'array', 'MObjectArray', u'out', None)])
        res = _api.MFnRenderLayer.listAllRenderLayers(*final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnRenderLayer, 'passHasLight')
    def passHasLight(self, renderPass, light):
        # type: (general.PyNode, general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([renderPass, light], [('renderPass', 'MObject', 'in', None), ('light', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnRenderLayer, 'passHasLight', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnRenderLayer, 'passHasObject')
    def passHasObject(self, renderPass, objectInstance):
        # type: (general.PyNode, general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([renderPass, objectInstance], [('renderPass', 'MObject', 'in', None), ('objectInstance', 'MDagPath', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnRenderLayer, 'passHasObject', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res
# ------ Do not edit above this line --------


class DisplayLayer(DependNode):

    def listMembers(self, fullNames=True):
        if fullNames:
            return map(general.PyNode, _util.listForNone(cmds.editDisplayLayerMembers(self, q=1, fullNames=True)))
        else:
            return _util.listForNone(cmds.editDisplayLayerMembers(self, q=1, fullNames=False))

    def addMembers(self, members, noRecurse=True):
        cmds.editDisplayLayerMembers(self, members, noRecurse=noRecurse)

    def removeMembers(self, members):
        cmds.editDisplayLayerMembers(self, members, remove=True)

    def setCurrent(self):
        cmds.editDisplayLayerMembers(currentDisplayLayer=self)
# ------ Do not edit below this line --------
    __melnode__ = u'displayLayer'
    __slots__ = ()
# ------ Do not edit above this line --------


class Constraint(Transform):

    def setWeight(self, weight, *targetObjects):
        inFunc = getattr(cmds, self.type())
        if not targetObjects:
            targetObjects = self.getTargetList()

        constraintObj = self.constraintParentInverseMatrix.inputs()[0]
        args = list(targetObjects) + [constraintObj]
        return inFunc(*args, **{'edit': True, 'weight': weight})

    def getWeight(self, *targetObjects):
        inFunc = getattr(cmds, self.type())
        if not targetObjects:
            targetObjects = self.getTargetList()

        constraintObj = self.constraintParentInverseMatrix.inputs()[0]
        args = list(targetObjects) + [constraintObj]
        return inFunc(*args, **{'query': True, 'weight': True})
# ------ Do not edit below this line --------
    __melnode__ = u'constraint'
    __slots__ = ()
# ------ Do not edit above this line --------


class GeometryShape(Shape):

    def __getattr__(self, attr):
        # print "Mesh.__getattr__", attr
        try:
            return self.comp(attr)
        except general.MayaComponentError:
            # print "getting super", attr
            return super(GeometryShape, self).__getattr__(attr)
# ------ Do not edit below this line --------
    __melnode__ = u'geometryShape'
    __slots__ = ()
# ------ Do not edit above this line --------


class DeformableShape(GeometryShape):

    @classmethod
    def _numCVsFunc_generator(cls, formFunc, spansPlusDegreeFunc, spansFunc,
                              name=None, doc=None):
        """
        Intended to be used by NurbsCurve / NurbsSurface to generate
        functions which give the 'true' number of editable CVs,
        as opposed to just numSpans + degree.
        (The two values will differ if we have a periodic curve).

        Note that this will usually need to be called outside/after the
        class definition, as formFunc/spansFunc/etc will not be defined
        until then, as they are added by the metaclass.
        """

        def _numCvs_generatedFunc(self, editableOnly=True):
            if editableOnly and formFunc(self) == self.Form.periodic:
                return spansFunc(self)
            else:
                return spansPlusDegreeFunc(self)
        if name:
            _numCvs_generatedFunc.__name__ = name
        if doc:
            _numCvs_generatedFunc.__doc__ = doc
        return _numCvs_generatedFunc

    @classmethod
    def _numEPsFunc_generator(cls, formFunc, spansFunc,
                              name=None, doc=None):
        """
        Intended to be used by NurbsCurve / NurbsSurface to generate
        functions which give the 'true' number of editable EPs,
        as opposed to just numSpans.
        (The two values will differ if we have a periodic curve).

        Note that this will usually need to be called outside/after the
        class definition, as formFunc/spansFunc will not be defined
        until then, as they are added by the metaclass.
        """

        def _numEPs_generatedFunc(self, editableOnly=True):
            if editableOnly and formFunc(self) == self.Form.periodic:
                return spansFunc(self)
            else:
                return spansFunc(self) + 1
        if name:
            _numEPs_generatedFunc.__name__ = name
        if doc:
            _numEPs_generatedFunc.__doc__ = doc
        return _numEPs_generatedFunc
# ------ Do not edit below this line --------
    __melnode__ = u'deformableShape'
    __slots__ = ()
# ------ Do not edit above this line --------


class ControlPoint(DeformableShape):
    pass
# ------ Do not edit below this line --------
    __melnode__ = u'controlPoint'
    __slots__ = ()
# ------ Do not edit above this line --------


class CurveShape(DeformableShape):
    pass
# ------ Do not edit below this line --------
    __melnode__ = u'curveShape'
    __slots__ = ()
# ------ Do not edit above this line --------


class NurbsCurve(CurveShape):
    _componentAttributes = {'u': general.NurbsCurveParameter,
                            'cv': general.NurbsCurveCV,
                            'controlVerts': general.NurbsCurveCV,
                            'ep': general.NurbsCurveEP,
                            'editPoints': general.NurbsCurveEP,
                            'knot': general.NurbsCurveKnot,
                            'knots': general.NurbsCurveKnot}
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnNurbsCurve
    __melcmd__ = staticmethod(modeling.curve)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'curve'
    __melnode__ = u'nurbsCurve'
    __slots__ = ()
    Form = Enum('Form', {'kInvalid': 0, 'invalid': 0, 'kOpen': 1, 'open': 1, 'kClosed': 2, 'closed': 2, 'periodic': 3, 'kPeriodic': 3, 'last': 4, 'kLast': 4}, multiKeys=True, defaultKeys={0: 'invalid', 1: 'open', 2: 'closed', 3: 'periodic', 4: 'last'})

    @_f.addApiDocs(_api.MFnNurbsCurve, 'numCVs')
    def _numCVsApi(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'numCVs')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'area')
    def area(self, tolerance=0.001):
        # type: (float) -> float
        do, final_do, outTypes = _f.getDoArgs([tolerance], [('tolerance', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'area', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'closestPoint')
    def closestPoint(self, toThisPoint, param=None, tolerance=0.001, space='preTransform'):
        # type: (Point, float, float, datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([toThisPoint, param, tolerance, space], [('toThisPoint', 'MPoint', 'in', None), ('param', 'double', 'in', None), ('tolerance', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'closestPoint', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPoint', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'copy')
    def copy(self, source, parentOrOwner='MObject::kNullObj'):
        # type: (general.PyNode, general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([source, parentOrOwner], [('source', 'MObject', 'in', None), ('parentOrOwner', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'copy', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'createWithEditPoints')
    def createWithEditPoints(self, editPoints, degree, form, create2D, createRational, uniformParam, parentOrOwner='MObject::kNullObj'):
        # type: (List[Point], int, NurbsCurve.Form, bool, bool, bool, general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([editPoints, degree, form, create2D, createRational, uniformParam, parentOrOwner], [('editPoints', 'MPointArray', 'in', None), ('degree', 'uint', 'in', None), ('form', ('MFnNurbsCurve', 'Form'), 'in', None), ('create2D', 'bool', 'in', None), ('createRational', 'bool', 'in', None), ('uniformParam', 'bool', 'in', None), ('parentOrOwner', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'createWithEditPoints', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'cvs')
    def cvs(self, startIndex, endIndex):
        # type: (int, int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([startIndex, endIndex], [('startIndex', 'uint', 'in', None), ('endIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'cvs', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'degree')
    def degree(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'degree')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'distanceToPoint')
    def distanceToPoint(self, pt, space='preTransform'):
        # type: (Point, datatypes.Space.Space) -> float
        do, final_do, outTypes = _f.getDoArgs([pt, space], [('pt', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'distanceToPoint', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'findParamFromLength')
    def findParamFromLength(self, partLength):
        # type: (float) -> float
        do, final_do, outTypes = _f.getDoArgs([partLength], [('partLength', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'findParamFromLength', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'form')
    def form(self):
        # type: () -> NurbsCurve.Form
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'form')
        return _f.ApiArgUtil._castResult(self, res, ('MFnNurbsCurve', 'Form'), None)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'getCV')
    def getCV(self, index, space='preTransform'):
        # type: (int, datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([index, space], [('index', 'uint', 'in', None), ('pt', 'MPoint', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'getCV', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'getCVs')
    def getCVs(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> List[Point]
        do, final_do, outTypes = _f.getDoArgs([space], [('array', 'MPointArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'getCVs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'getDerivativesAtParm')
    def getDerivativesAtParm(self, param, space):
        # type: (float, datatypes.Space.Space) -> Tuple[Point, Vector, Vector]
        do, final_do, outTypes = _f.getDoArgs([param, space], [('param', 'double', 'in', None), ('pos', 'MPoint', 'out', None), ('dU', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('dUU', 'MVector', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'getDerivativesAtParm', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'knot')
    def getKnot(self, index):
        # type: (int) -> float
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'knot', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'getKnotDomain')
    def getKnotDomain(self):
        # type: () -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('start', 'double', 'out', None), ('end', 'double', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'getKnotDomain', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'getKnots')
    def getKnots(self):
        # type: () -> List[float]
        do, final_do, outTypes = _f.getDoArgs([], [('array', 'MDoubleArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'getKnots', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'getParamAtPoint')
    def getParamAtPoint(self, atThisPoint, space='preTransform'):
        # type: (Point, datatypes.Space.Space) -> float
        do, final_do, outTypes = _f.getDoArgs([atThisPoint, space], [('atThisPoint', 'MPoint', 'in', None), ('param', 'double', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'getParamAtPoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'getPointAtParam')
    def getPointAtParam(self, param, space='preTransform'):
        # type: (float, datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([param, space], [('param', 'double', 'in', None), ('point', 'MPoint', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'getPointAtParam', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'hasHistoryOnCreate')
    def hasHistoryOnCreate(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'hasHistoryOnCreate')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'isParamOnCurve')
    def isParamOnCurve(self, param):
        # type: (float) -> bool
        do, final_do, outTypes = _f.getDoArgs([param], [('param', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'isParamOnCurve', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'isPlanar')
    def isPlanar(self, planeNormal=None):
        # type: (Vector) -> bool
        do, final_do, outTypes = _f.getDoArgs([planeNormal], [('planeNormal', 'MVector', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'isPlanar', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'isPointOnCurve')
    def isPointOnCurve(self, point, tolerance=0.001, space='preTransform'):
        # type: (Point, float, datatypes.Space.Space) -> bool
        do, final_do, outTypes = _f.getDoArgs([point, tolerance, space], [('point', 'MPoint', 'in', None), ('tolerance', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'isPointOnCurve', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'length')
    def length(self, tolerance=0.001):
        # type: (float) -> float
        do, final_do, outTypes = _f.getDoArgs([tolerance], [('tolerance', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'length', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'makeMultipleEndKnots')
    def makeMultipleEndKnots(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'makeMultipleEndKnots')
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'normal')
    def normal(self, param, space='preTransform'):
        # type: (float, datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([param, space], [('param', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'normal', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', None)
        return res

    @_f.deprecated
    def numCVs(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'numCVs')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'numKnots')
    def numKnots(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'numKnots')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'numSpans')
    def numSpans(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'numSpans')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsCurve, 'removeKnot')
    def removeKnot(self, atThisParam, removeAll=False):
        # type: (float, bool) -> None
        do, final_do, outTypes = _f.getDoArgs([atThisParam, removeAll], [('atThisParam', 'double', 'in', None), ('removeAll', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'removeKnot', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'reverse')
    def reverse(self, constructionHistory=False):
        # type: (bool) -> None
        do, final_do, outTypes = _f.getDoArgs([constructionHistory], [('constructionHistory', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'reverse', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'setCV')
    def setCV(self, index, pt, space='preTransform'):
        # type: (int, Point, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([index, pt, space], [('index', 'uint', 'in', None), ('pt', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getCV, self.setCV, ['index', 'space'])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'setCV', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'setCVs')
    def setCVs(self, array, space='preTransform'):
        # type: (List[Point], datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([array, space], [('array', 'MPointArray', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getCVs, self.setCVs, ['space'])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'setCVs', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'setKnot')
    def setKnot(self, index, param):
        # type: (int, float) -> None
        do, final_do, outTypes = _f.processApiArgs([index, param], [('index', 'uint', 'in', None), ('param', 'double', 'in', None)], self.getKnot, self.setKnot, ['index'])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'setKnot', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'setKnots')
    def setKnots(self, array, startIndex, endIndex):
        # type: (List[float], int, int) -> None
        do, final_do, outTypes = _f.processApiArgs([array, startIndex, endIndex], [('array', 'MDoubleArray', 'in', None), ('startIndex', 'uint', 'in', None), ('endIndex', 'uint', 'in', None)], self.getKnots, self.setKnots, [])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'setKnots', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'tangent')
    def tangent(self, param, space='preTransform'):
        # type: (float, datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([param, space], [('param', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'tangent', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsCurve, 'updateCurve')
    def updateCurve(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnNurbsCurve, 'updateCurve')
        return res
# ------ Do not edit above this line --------


if not _factories.building:
    # keep this safe to load if the templates have not been built yet

    # apiToMelBridge maps MFnNurbsCurve.numCVs => NurbsCurve._numCVsApi
    NurbsCurve.numCVs = \
        NurbsCurve._numCVsFunc_generator(NurbsCurve.form,
                                         NurbsCurve._numCVsApi,
                                         NurbsCurve.numSpans,
                                         name='numCVs',
                                         doc="""
            Returns the number of CVs.
    
            :Parameters:
            editableOnly : `bool`
                If editableOnly evaluates to True (default), then this will return
                the number of cvs that can be actually edited (and also the highest
                index that may be used for cv's - ie, if
                    myCurve.numCVs(editableOnly=True) == 4
                then allowable cv indices go from
                    myCurve.cv[0] to mySurf.cv[3]
    
                If editablyOnly is False, then this will return the underlying
                number of cvs used to define the mathematical curve -
                degree + numSpans.
    
                These will only differ if the form is 'periodic', in which
                case the editable number will be numSpans (as the last 'degree'
                cv's are 'locked' to be the same as the first 'degree' cvs).
                In all other cases, the number of cvs will be degree + numSpans.
    
            :Examples:
                >>> from pymel.core import *
                >>> # a periodic curve
                >>> myCurve = curve(name='periodicCurve1', d=3, periodic=True, k=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), pw=[(4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (0, 5.5, 0, 1), (-4, 4, 0, 1), (-5.5, 0, 0, 1), (-4, -4, 0, 1), (0, -5.5, 0, 1), (4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1)] )
                >>> myCurve.cv
                NurbsCurveCV(u'periodicCurveShape1.cv[0:7]')
                >>> myCurve.numCVs()
                8
                >>> myCurve.numCVs(editableOnly=False)
                11
                >>>
                >>> # an open curve
                >>> myCurve = curve(name='openCurve1', d=3, periodic=False, k=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), pw=[(4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (0, 5.5, 0, 1), (-4, 4, 0, 1), (-5.5, 0, 0, 1), (-4, -4, 0, 1), (0, -5.5, 0, 1), (4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1)] )
                >>> myCurve.cv
                NurbsCurveCV(u'openCurveShape1.cv[0:10]')
                >>> myCurve.numCVs()
                11
                >>> myCurve.numCVs(editableOnly=False)
                11
    
            :rtype: `int`
            """)

    NurbsCurve.numEPs = \
        NurbsCurve._numEPsFunc_generator(NurbsCurve.form,
                                         NurbsCurve.numSpans,
                                         name='numEPs',
                                         doc="""
            Returns the number of EPs.
    
            :Examples:
                >>> from pymel.core import *
                >>> # a periodic curve
                >>> myCurve = curve(name='periodicCurve2', d=3, periodic=True, k=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), pw=[(4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (0, 5.5, 0, 1), (-4, 4, 0, 1), (-5.5, 0, 0, 1), (-4, -4, 0, 1), (0, -5.5, 0, 1), (4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1)] )
                >>> myCurve.ep
                NurbsCurveEP(u'periodicCurveShape2.ep[0:7]')
                >>> myCurve.numEPs()
                8
                >>>
                >>> # an open curve
                >>> myCurve = curve(name='openCurve2', d=3, periodic=False, k=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), pw=[(4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (0, 5.5, 0, 1), (-4, 4, 0, 1), (-5.5, 0, 0, 1), (-4, -4, 0, 1), (0, -5.5, 0, 1), (4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1)] )
                >>> myCurve.ep
                NurbsCurveEP(u'openCurveShape2.ep[0:8]')
                >>> myCurve.numEPs()
                9
    
            Returns
            -------
            int
            """)


class SurfaceShape(ControlPoint):
    pass
# ------ Do not edit below this line --------
    __melnode__ = u'surfaceShape'
    __slots__ = ()
# ------ Do not edit above this line --------


class NurbsSurface(SurfaceShape):
    _componentAttributes = {'u': (general.NurbsSurfaceRange, 'u'),
                            'uIsoparm': (general.NurbsSurfaceRange, 'u'),
                            'v': (general.NurbsSurfaceRange, 'v'),
                            'vIsoparm': (general.NurbsSurfaceRange, 'v'),
                            'uv': (general.NurbsSurfaceRange, 'uv'),
                            'cv': general.NurbsSurfaceCV,
                            'controlVerts': general.NurbsSurfaceCV,
                            'ep': general.NurbsSurfaceEP,
                            'editPoints': general.NurbsSurfaceEP,
                            'knot': general.NurbsSurfaceKnot,
                            'knots': general.NurbsSurfaceKnot,
                            'sf': general.NurbsSurfaceFace,
                            'faces': general.NurbsSurfaceFace}
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnNurbsSurface
    __melcmd__ = staticmethod(modeling.surface)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'surface'
    __melnode__ = u'nurbsSurface'
    __slots__ = ()
    BoundaryType = Enum('BoundaryType', {'invalidBoundary': 0, 'kInvalidBoundary': 0, 'outer': 1, 'kOuter': 1, 'kInner': 2, 'inner': 2, 'kSegment': 3, 'segment': 3, 'closedSegment': 4, 'kClosedSegment': 4}, multiKeys=True, defaultKeys={0: 'invalidBoundary', 1: 'outer', 2: 'inner', 3: 'segment', 4: 'closedSegment'})
    Form = Enum('Form', {'kInvalid': 0, 'invalid': 0, 'kOpen': 1, 'open': 1, 'kClosed': 2, 'closed': 2, 'periodic': 3, 'kPeriodic': 3, 'last': 4, 'kLast': 4}, multiKeys=True, defaultKeys={0: 'invalid', 1: 'open', 2: 'closed', 3: 'periodic', 4: 'last'})

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numCVsInU')
    def _numCVsInUApi(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numCVsInU')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numCVsInV')
    def _numCVsInVApi(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numCVsInV')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'area')
    def area(self, tolerance=0.001):
        # type: (float) -> float
        do, final_do, outTypes = _f.getDoArgs([tolerance], [('tolerance', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'area', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'assignUV')
    def assignUV(self, patchId, cornerIndex, uvId):
        # type: (int, int, int) -> None
        do, final_do, outTypes = _f.getDoArgs([patchId, cornerIndex, uvId], [('patchId', 'int', 'in', None), ('cornerIndex', 'int', 'in', None), ('uvId', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'assignUV', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'assignUVs')
    def assignUVs(self, uvCounts, uvIds):
        # type: (List[int], List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([uvCounts, uvIds], [('uvCounts', 'MIntArray', 'in', None), ('uvIds', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'assignUVs', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'boundaryType')
    def boundaryType(self, region, boundary):
        # type: (int, int) -> NurbsSurface.BoundaryType
        do, final_do, outTypes = _f.getDoArgs([region, boundary], [('region', 'uint', 'in', None), ('boundary', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'boundaryType', final_do)
        res = _f.ApiArgUtil._castResult(self, res, ('MFnNurbsSurface', 'BoundaryType'), None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'clearUVs')
    def clearUVs(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'clearUVs')
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'closestPoint')
    def closestPoint(self, toThisPoint, ignoreTrimBoundaries=False, tolerance=0.001, space='preTransform'):
        # type: (Point, bool, float, datatypes.Space.Space) -> Tuple[Point, float, float]
        do, final_do, outTypes = _f.getDoArgs([toThisPoint, ignoreTrimBoundaries, tolerance, space], [('toThisPoint', 'MPoint', 'in', None), ('paramU', 'double', 'out', None), ('paramV', 'double', 'out', None), ('ignoreTrimBoundaries', 'bool', 'in', None), ('tolerance', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'closestPoint', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPoint', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'copy')
    def copy(self, source, parentOrOwner='MObject::kNullObj'):
        # type: (general.PyNode, general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([source, parentOrOwner], [('source', 'MObject', 'in', None), ('parentOrOwner', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'copy', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'cvsInU')
    def cvsInU(self, startIndex, endIndex, rowIndex):
        # type: (int, int, int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([startIndex, endIndex, rowIndex], [('startIndex', 'uint', 'in', None), ('endIndex', 'uint', 'in', None), ('rowIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'cvsInU', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'cvsInV')
    def cvsInV(self, startIndex, endIndex, rowIndex):
        # type: (int, int, int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([startIndex, endIndex, rowIndex], [('startIndex', 'uint', 'in', None), ('endIndex', 'uint', 'in', None), ('rowIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'cvsInV', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'degreeU')
    def degreeU(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'degreeU')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'degreeV')
    def degreeV(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'degreeV')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'distanceToPoint')
    def distanceToPoint(self, pt, space='preTransform'):
        # type: (Point, datatypes.Space.Space) -> float
        do, final_do, outTypes = _f.getDoArgs([pt, space], [('pt', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'distanceToPoint', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'edge')
    def edge(self, region, boundary, edge, paramEdge=False):
        # type: (int, int, int, bool) -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([region, boundary, edge, paramEdge], [('region', 'uint', 'in', None), ('boundary', 'uint', 'in', None), ('edge', 'uint', 'in', None), ('paramEdge', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'edge', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObjectArray', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'formInU')
    def formInU(self):
        # type: () -> NurbsSurface.Form
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'formInU')
        return _f.ApiArgUtil._castResult(self, res, ('MFnNurbsSurface', 'Form'), None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'formInV')
    def formInV(self):
        # type: () -> NurbsSurface.Form
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'formInV')
        return _f.ApiArgUtil._castResult(self, res, ('MFnNurbsSurface', 'Form'), None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getAssignedUVs')
    def getAssignedUVs(self):
        # type: () -> Tuple[List[int], List[int]]
        do, final_do, outTypes = _f.getDoArgs([], [('uvCounts', 'MIntArray', 'out', None), ('uvIds', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getAssignedUVs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getCV')
    def getCV(self, indexU, indexV, space='preTransform'):
        # type: (int, int, datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([indexU, indexV, space], [('indexU', 'uint', 'in', None), ('indexV', 'uint', 'in', None), ('pnt', 'MPoint', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getCV', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getCVs')
    def getCVs(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> List[Point]
        do, final_do, outTypes = _f.getDoArgs([space], [('array', 'MPointArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getCVs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getConnectedShaders')
    def getConnectedShaders(self, instanceNumber):
        # type: (int) -> Tuple[List[general.PyNode], List[int]]
        do, final_do, outTypes = _f.getDoArgs([instanceNumber], [('instanceNumber', 'uint', 'in', None), ('shaders', 'MObjectArray', 'out', None), ('indices', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getConnectedShaders', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getDataObject')
    def getDataObject(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getDataObject')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getDerivativesAtParm')
    def getDerivativesAtParm(self, paramInU, paramInV, space):
        # type: (float, float, datatypes.Space.Space) -> Tuple[Point, Vector, Vector, Vector, Vector, Vector]
        do, final_do, outTypes = _f.getDoArgs([paramInU, paramInV, space], [('paramInU', 'double', 'in', None), ('paramInV', 'double', 'in', None), ('pos', 'MPoint', 'out', None), ('dU', 'MVector', 'out', None), ('dV', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('dUU', 'MVector', 'out', None), ('dVV', 'MVector', 'out', None), ('dUV', 'MVector', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getDerivativesAtParm', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getKnotDomain')
    def getKnotDomain(self):
        # type: () -> Tuple[float, float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('startU', 'double', 'out', None), ('endU', 'double', 'out', None), ('startV', 'double', 'out', None), ('endV', 'double', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getKnotDomain', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'knotInU')
    def getKnotInU(self, index):
        # type: (int) -> float
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'knotInU', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'knotInV')
    def getKnotInV(self, index):
        # type: (int) -> float
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'knotInV', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getKnotsInU')
    def getKnotsInU(self):
        # type: () -> List[float]
        do, final_do, outTypes = _f.getDoArgs([], [('array', 'MDoubleArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getKnotsInU', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getKnotsInV')
    def getKnotsInV(self):
        # type: () -> List[float]
        do, final_do, outTypes = _f.getDoArgs([], [('array', 'MDoubleArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getKnotsInV', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def getParamAtPoint(self, atThisPoint, space='preTransform'):
        # type: (Point, datatypes.Space.Space) -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([atThisPoint, space], [('atThisPoint', 'MPoint', 'in', None), ('paramU', 'double', 'out', None), ('paramV', 'double', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getParamAtPoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getPatchUV')
    def getPatchUV(self, patchId, cornerIndex):
        # type: (int, int) -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([patchId, cornerIndex], [('patchId', 'int', 'in', None), ('cornerIndex', 'int', 'in', None), ('u', 'float', 'out', None), ('v', 'float', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getPatchUV', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getPatchUVid')
    def getPatchUVid(self, patchId, cornerIndex):
        # type: (int, int) -> int
        do, final_do, outTypes = _f.getDoArgs([patchId, cornerIndex], [('patchId', 'int', 'in', None), ('cornerIndex', 'int', 'in', None), ('uvId', 'int', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getPatchUVid', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getPatchUVs')
    def getPatchUVs(self, patchId):
        # type: (int) -> Tuple[List[float], List[float]]
        do, final_do, outTypes = _f.getDoArgs([patchId], [('patchId', 'int', 'in', None), ('uArray', 'MFloatArray', 'out', None), ('vArray', 'MFloatArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getPatchUVs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getPointAtParam')
    def getPointAtParam(self, paramU, paramV, space='preTransform'):
        # type: (float, float, datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([paramU, paramV, space], [('paramU', 'double', 'in', None), ('paramV', 'double', 'in', None), ('point', 'MPoint', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getPointAtParam', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'getTangents')
    def getTangents(self, paramInU, paramInV, space='preTransform'):
        # type: (float, float, datatypes.Space.Space) -> Tuple[Vector, Vector]
        do, final_do, outTypes = _f.getDoArgs([paramInU, paramInV, space], [('paramInU', 'double', 'in', None), ('paramInV', 'double', 'in', None), ('vectorInU', 'MVector', 'out', None), ('vectorInV', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'getTangents', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'hasHistoryOnCreate')
    def hasHistoryOnCreate(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'hasHistoryOnCreate')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'intersect')
    def intersect(self, rayStartingPoint, alongThisDirection, tolerance=0.001, space='preTransform', calculateDistance=False, calculateExactHit=False):
        # type: (Point, Vector, float, datatypes.Space.Space, bool, bool) -> Tuple[bool, float, float, Point, float, bool]
        do, final_do, outTypes = _f.getDoArgs([rayStartingPoint, alongThisDirection, tolerance, space, calculateDistance, calculateExactHit], [('rayStartingPoint', 'MPoint', 'in', None), ('alongThisDirection', 'MVector', 'in', None), ('u', 'double', 'out', None), ('v', 'double', 'out', None), ('pntOfIntersection', 'MPoint', 'out', None), ('tolerance', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None), ('calculateDistance', 'bool', 'in', None), ('distance', 'double', 'out', None), ('calculateExactHit', 'bool', 'in', None), ('wasExactHit', 'bool', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'intersect', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isBezier')
    def isBezier(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isBezier')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isFlipNorm')
    def isFlipNorm(self, region):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([region], [('region', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isFlipNorm', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isFoldedOnBispan')
    def isFoldedOnBispan(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isFoldedOnBispan')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isKnotU')
    def isKnotU(self, param):
        # type: (float) -> bool
        do, final_do, outTypes = _f.getDoArgs([param], [('param', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isKnotU', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isKnotV')
    def isKnotV(self, param):
        # type: (float) -> bool
        do, final_do, outTypes = _f.getDoArgs([param], [('param', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isKnotV', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isParamOnSurface')
    def isParamOnSurface(self, paramU, paramV):
        # type: (float, float) -> bool
        do, final_do, outTypes = _f.getDoArgs([paramU, paramV], [('paramU', 'double', 'in', None), ('paramV', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isParamOnSurface', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isPointInTrimmedRegion')
    def isPointInTrimmedRegion(self, u, v):
        # type: (float, float) -> bool
        do, final_do, outTypes = _f.getDoArgs([u, v], [('u', 'double', 'in', None), ('v', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isPointInTrimmedRegion', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isPointOnSurface')
    def isPointOnSurface(self, point, tolerance=0.001, space='preTransform'):
        # type: (Point, float, datatypes.Space.Space) -> bool
        do, final_do, outTypes = _f.getDoArgs([point, tolerance, space], [('point', 'MPoint', 'in', None), ('tolerance', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isPointOnSurface', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isTrimmedSurface')
    def isTrimmedSurface(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isTrimmedSurface')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'isUniform')
    def isUniform(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'isUniform')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'normal')
    def normal(self, paramInU, paramInV, space='preTransform'):
        # type: (float, float, datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([paramInU, paramInV, space], [('paramInU', 'double', 'in', None), ('paramInV', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'normal', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MVector', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numBoundaries')
    def numBoundaries(self, region):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([region], [('region', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numBoundaries', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.deprecated
    def numCVsInU(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numCVsInU')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.deprecated
    def numCVsInV(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numCVsInV')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numEdges')
    def numEdges(self, region, boundary):
        # type: (int, int) -> int
        do, final_do, outTypes = _f.getDoArgs([region, boundary], [('region', 'uint', 'in', None), ('boundary', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numEdges', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numKnotsInU')
    def numKnotsInU(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numKnotsInU')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numKnotsInV')
    def numKnotsInV(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numKnotsInV')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numNonZeroSpansInU')
    def numNonZeroSpansInU(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numNonZeroSpansInU')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numNonZeroSpansInV')
    def numNonZeroSpansInV(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numNonZeroSpansInV')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numPatches')
    def numPatches(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numPatches')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numPatchesInU')
    def numPatchesInU(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numPatchesInU')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numPatchesInV')
    def numPatchesInV(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numPatchesInV')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numRegions')
    def numRegions(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numRegions')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numSpansInU')
    def numSpansInU(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numSpansInU')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numSpansInV')
    def numSpansInV(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numSpansInV')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'numUVs')
    def numUVs(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'numUVs')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnNurbsSurface, 'projectCurve')
    def projectCurve(self, curve, direction=None, constructionHistory=False):
        # type: (general.PyNode, Vector, bool) -> None
        do, final_do, outTypes = _f.getDoArgs([curve, direction, constructionHistory], [('curve', 'MDagPath', 'in', None), ('direction', 'MVector', 'in', None), ('constructionHistory', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'projectCurve', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'removeKnotInU')
    def removeKnotInU(self, atThisParam, removeAll=False):
        # type: (float, bool) -> None
        do, final_do, outTypes = _f.getDoArgs([atThisParam, removeAll], [('atThisParam', 'double', 'in', None), ('removeAll', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'removeKnotInU', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'removeKnotInV')
    def removeKnotInV(self, atThisParam, removeAll=False):
        # type: (float, bool) -> None
        do, final_do, outTypes = _f.getDoArgs([atThisParam, removeAll], [('atThisParam', 'double', 'in', None), ('removeAll', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'removeKnotInV', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'removeOneKnotInU')
    def removeOneKnotInU(self, atThisParam):
        # type: (float) -> None
        do, final_do, outTypes = _f.getDoArgs([atThisParam], [('atThisParam', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'removeOneKnotInU', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'removeOneKnotInV')
    def removeOneKnotInV(self, atThisParam):
        # type: (float) -> None
        do, final_do, outTypes = _f.getDoArgs([atThisParam], [('atThisParam', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'removeOneKnotInV', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'setCV')
    def setCV(self, indexU, indexV, pt, space='preTransform'):
        # type: (int, int, Point, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([indexU, indexV, pt, space], [('indexU', 'uint', 'in', None), ('indexV', 'uint', 'in', None), ('pt', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getCV, self.setCV, ['indexU', 'indexV', 'space'])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'setCV', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'setCVs')
    def setCVs(self, array, space='preTransform'):
        # type: (List[Point], datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([array, space], [('array', 'MPointArray', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getCVs, self.setCVs, ['space'])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'setCVs', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'setKnotInU')
    def setKnotInU(self, index, param):
        # type: (int, float) -> None
        do, final_do, outTypes = _f.processApiArgs([index, param], [(u'index', 'int', 'in', None), (u'param', 'double', u'in', None)], self.getKnotInU, self.setKnotInU, ['index'])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'setKnotInU', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'setKnotInV')
    def setKnotInV(self, index, param):
        # type: (int, float) -> None
        do, final_do, outTypes = _f.processApiArgs([index, param], [('index', 'uint', 'in', None), ('param', 'double', 'in', None)], self.getKnotInV, self.setKnotInV, ['index'])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'setKnotInV', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'setKnotsInU')
    def setKnotsInU(self, array, startIndex, endIndex):
        # type: (List[float], int, int) -> None
        do, final_do, outTypes = _f.processApiArgs([array, startIndex, endIndex], [('array', 'MDoubleArray', 'in', None), ('startIndex', 'uint', 'in', None), ('endIndex', 'uint', 'in', None)], self.getKnotsInU, self.setKnotsInU, [])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'setKnotsInU', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'setKnotsInV')
    def setKnotsInV(self, array, startIndex, endIndex):
        # type: (List[float], int, int) -> None
        do, final_do, outTypes = _f.processApiArgs([array, startIndex, endIndex], [('array', 'MDoubleArray', 'in', None), ('startIndex', 'uint', 'in', None), ('endIndex', 'uint', 'in', None)], self.getKnotsInV, self.setKnotsInV, [])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'setKnotsInV', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'tesselate')
    def tesselate(self, parms='MTesselationParams::fsDefaultTesselationParams', parentOrOwner='MObject::kNullObj'):
        # type: (datatypes.TesselationParams, general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([parms, parentOrOwner], [('parms', 'MTesselationParams', 'in', None), ('parentOrOwner', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'tesselate', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'trim')
    def trim(self, locatorU, locatorV, constructionHistory=False):
        # type: (List[float], List[float], bool) -> None
        do, final_do, outTypes = _f.getDoArgs([locatorU, locatorV, constructionHistory], [('locatorU', 'MDoubleArray', 'in', None), ('locatorV', 'MDoubleArray', 'in', None), ('constructionHistory', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'trim', final_do)
        return res

    @_f.addApiDocs(_api.MFnNurbsSurface, 'updateSurface')
    def updateSurface(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnNurbsSurface, 'updateSurface')
        return res
# ------ Do not edit above this line --------


if not _factories.building:
    # keep this safe to load if the templates have not been built yet

    # apiToMelBridge maps MFnNurbsCurve._numCVsInU => NurbsCurve._numCVsInUApi
    NurbsSurface.numCVsInU = \
        NurbsSurface._numCVsFunc_generator(NurbsSurface.formInU,
                                           NurbsSurface._numCVsInUApi,
                                           NurbsSurface.numSpansInU,
                                           name='numCVsInU',
                                           doc="""
            Returns the number of CVs in the U direction.
    
            :Parameters:
            editableOnly : `bool`
                If editableOnly evaluates to True (default), then this will return
                the number of cvs that can be actually edited (and also the highest
                index that may be used for u - ie, if
                    mySurf.numCVsInU(editableOnly=True) == 4
                then allowable u indices go from
                    mySurf.cv[0][*] to mySurf.cv[3][*]
    
                If editablyOnly is False, then this will return the underlying
                number of cvs used to define the mathematical curve in u -
                degreeU + numSpansInU.
    
                These will only differ if the form in u is 'periodic', in which
                case the editable number will be numSpansInU (as the last 'degree'
                cv's are 'locked' to be the same as the first 'degree' cvs).
                In all other cases, the number of cvs will be degreeU + numSpansInU.
    
            :Examples:
                >>> from pymel.core import *
                >>> # a periodic surface
                >>> mySurf = surface(name='periodicSurf1', du=3, dv=1, fu='periodic', fv='open', ku=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), kv=(0, 1), pw=[(4, -4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, 0, 1), (5.5, 0, -2.5, 1), (4, 4, 0, 1), (4, 4, -2.5, 1), (0, 5.5, 0, 1), (0, 5.5, -2.5, 1), (-4, 4, 0, 1), (-4, 4, -2.5, 1), (-5.5, 0, 0, 1), (-5.5, 0, -2.5, 1), (-4, -4, 0, 1), (-4, -4, -2.5, 1), (0, -5.5, 0, 1), (0, -5.5, -2.5, 1), (4, -4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, 0, 1), (5.5, 0, -2.5, 1), (4, 4, 0, 1), (4, 4, -2.5, 1)] )
                >>> sorted(mySurf.cv[:][0].indices())        # doctest: +ELLIPSIS
                [ComponentIndex((0, 0), ... ComponentIndex((7, 0), label=None)]
                >>> mySurf.numCVsInU()
                8
                >>> mySurf.numCVsInU(editableOnly=False)
                11
                >>>
                >>> # an open surface
                >>> mySurf = surface(name='openSurf1', du=3, dv=1, fu='open', fv='open', ku=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), kv=(0, 1), pw=((4, -4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, 0, 1), (5.5, 0, -2.5, 1), (4, 4, 0, 1), (4, 4, -2.5, 1), (0, 5.5, 0, 1), (0, 5.5, -2.5, 1), (-4, 4, 0, 1), (-4, 4, -2.5, 1), (-5.5, 0, 0, 1), (-5.5, 0, -2.5, 1), (-4, -4, 0, 1), (-4, -4, -2.5, 1), (0, -5.5, 0, 1), (0, -5.5, -2.5, 1), (4, -4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, 0, 1), (5.5, 0, -2.5, 1), (4, 4, 0, 1), (4, 4, -2.5, 1)) )
                >>> sorted(mySurf.cv[:][0].indices())        # doctest: +ELLIPSIS
                [ComponentIndex((0, 0), ... ComponentIndex((10, 0), label=None)]
                >>> mySurf.numCVsInU()
                11
                >>> mySurf.numCVsInU(editableOnly=False)
                11
    
            :rtype: `int`
            """)

    # apiToMelBridge maps MFnNurbsCurve._numCVsInV => NurbsCurve._numCVsInVApi
    NurbsSurface.numCVsInV = \
        NurbsSurface._numCVsFunc_generator(NurbsSurface.formInV,
                                           NurbsSurface._numCVsInVApi,
                                           NurbsSurface.numSpansInV,
                                           name='numCVsInV',
                                           doc="""
            Returns the number of CVs in the V direction.
    
            :Parameters:
            editableOnly : `bool`
                If editableOnly evaluates to True (default), then this will return
                the number of cvs that can be actually edited (and also the highest
                index that may be used for v - ie, if
                    mySurf.numCVsInV(editableOnly=True) == 4
                then allowable v indices go from
                    mySurf.cv[*][0] to mySurf.cv[*][3]
    
                If editablyOnly is False, then this will return the underlying
                number of cvs used to define the mathematical curve in v -
                degreeV + numSpansInV.
    
                These will only differ if the form in v is 'periodic', in which
                case the editable number will be numSpansInV (as the last 'degree'
                cv's are 'locked' to be the same as the first 'degree' cvs).
                In all other cases, the number of cvs will be degreeV + numSpansInV.
    
            :Examples:
                >>> from pymel.core import *
                >>> # a periodic surface
                >>> mySurf = surface(name='periodicSurf2', du=1, dv=3, fu='open', fv='periodic', ku=(0, 1), kv=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), pw=[(4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (0, 5.5, 0, 1), (-4, 4, 0, 1), (-5.5, 0, 0, 1), (-4, -4, 0, 1), (0, -5.5, 0, 1), (4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, -2.5, 1), (4, 4, -2.5, 1), (0, 5.5, -2.5, 1), (-4, 4, -2.5, 1), (-5.5, 0, -2.5, 1), (-4, -4, -2.5, 1), (0, -5.5, -2.5, 1), (4, -4, -2.5, 1), (5.5, 0, -2.5, 1), (4, 4, -2.5, 1)] )
                >>> sorted(mySurf.cv[0].indices())         # doctest: +ELLIPSIS
                [ComponentIndex((0, 0), ... ComponentIndex((0, 7), label='cv')]
                >>> mySurf.numCVsInV()
                8
                >>> mySurf.numCVsInV(editableOnly=False)
                11
                >>>
                >>> # an open surface
                >>> mySurf = surface(name='openSurf2', du=1, dv=3, fu='open', fv='open', ku=(0, 1), kv=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), pw=[(4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (0, 5.5, 0, 1), (-4, 4, 0, 1), (-5.5, 0, 0, 1), (-4, -4, 0, 1), (0, -5.5, 0, 1), (4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, -2.5, 1), (4, 4, -2.5, 1), (0, 5.5, -2.5, 1), (-4, 4, -2.5, 1), (-5.5, 0, -2.5, 1), (-4, -4, -2.5, 1), (0, -5.5, -2.5, 1), (4, -4, -2.5, 1), (5.5, 0, -2.5, 1), (4, 4, -2.5, 1)] )
                >>> sorted(mySurf.cv[0].indices())          # doctest: +ELLIPSIS
                [ComponentIndex((0, 0), ... ComponentIndex((0, 10), label='cv')]
                >>> mySurf.numCVsInV()
                11
                >>> mySurf.numCVsInV(editableOnly=False)
                11
    
            :rtype: `int`
            """)

    NurbsSurface.numEPsInU = \
        NurbsSurface._numEPsFunc_generator(NurbsSurface.formInU,
                                           NurbsSurface.numSpansInU,
                                           name='numEPsInU',
                                           doc="""
            Returns the number of EPs in the U direction.
    
            :Examples:
                >>> from pymel.core import *
                >>> # a periodic surface
                >>> mySurf = surface(name='periodicSurf3', du=3, dv=1, fu='periodic', fv='open', ku=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), kv=(0, 1), pw=[(4, -4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, 0, 1), (5.5, 0, -2.5, 1), (4, 4, 0, 1), (4, 4, -2.5, 1), (0, 5.5, 0, 1), (0, 5.5, -2.5, 1), (-4, 4, 0, 1), (-4, 4, -2.5, 1), (-5.5, 0, 0, 1), (-5.5, 0, -2.5, 1), (-4, -4, 0, 1), (-4, -4, -2.5, 1), (0, -5.5, 0, 1), (0, -5.5, -2.5, 1), (4, -4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, 0, 1), (5.5, 0, -2.5, 1), (4, 4, 0, 1), (4, 4, -2.5, 1)] )
                >>> sorted(mySurf.ep[:][0].indices())      # doctest: +ELLIPSIS
                [ComponentIndex((0, 0), ... ComponentIndex((7, 0), label=None)]
                >>> mySurf.numEPsInU()
                8
                >>>
                >>> # an open surface
                >>> mySurf = surface(name='openSurf3', du=3, dv=1, fu='open', fv='open', ku=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), kv=(0, 1), pw=[(4, -4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, 0, 1), (5.5, 0, -2.5, 1), (4, 4, 0, 1), (4, 4, -2.5, 1), (0, 5.5, 0, 1), (0, 5.5, -2.5, 1), (-4, 4, 0, 1), (-4, 4, -2.5, 1), (-5.5, 0, 0, 1), (-5.5, 0, -2.5, 1), (-4, -4, 0, 1), (-4, -4, -2.5, 1), (0, -5.5, 0, 1), (0, -5.5, -2.5, 1), (4, -4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, 0, 1), (5.5, 0, -2.5, 1), (4, 4, 0, 1), (4, 4, -2.5, 1)] )
                >>> sorted(mySurf.ep[:][0].indices())      # doctest: +ELLIPSIS
                [ComponentIndex((0, 0), ... ComponentIndex((8, 0), label=None)]
                >>> mySurf.numEPsInU()
                9
    
            :rtype: `int`
            """)

    NurbsSurface.numEPsInV = \
        NurbsSurface._numEPsFunc_generator(NurbsSurface.formInV,
                                           NurbsSurface.numSpansInV,
                                           name='numEPsInV',
                                           doc="""
            Returns the number of EPs in the V direction.
    
            :Examples:
                >>> from pymel.core import *
                >>> # a periodic surface
                >>> mySurf = surface(name='periodicSurf4', du=1, dv=3, fu='open', fv='periodic', ku=(0, 1), kv=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), pw=[(4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (0, 5.5, 0, 1), (-4, 4, 0, 1), (-5.5, 0, 0, 1), (-4, -4, 0, 1), (0, -5.5, 0, 1), (4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, -2.5, 1), (4, 4, -2.5, 1), (0, 5.5, -2.5, 1), (-4, 4, -2.5, 1), (-5.5, 0, -2.5, 1), (-4, -4, -2.5, 1), (0, -5.5, -2.5, 1), (4, -4, -2.5, 1), (5.5, 0, -2.5, 1), (4, 4, -2.5, 1)] )
                >>> sorted(mySurf.ep[0][:].indices())      # doctest: +ELLIPSIS
                [ComponentIndex((0, 0), ... ComponentIndex((0, 7), label=None)]
                >>> mySurf.numEPsInV()
                8
                >>>
                >>> # an open surface
                >>> mySurf = surface(name='openSurf4', du=1, dv=3, fu='open', fv='open', ku=(0, 1), kv=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), pw=[(4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (0, 5.5, 0, 1), (-4, 4, 0, 1), (-5.5, 0, 0, 1), (-4, -4, 0, 1), (0, -5.5, 0, 1), (4, -4, 0, 1), (5.5, 0, 0, 1), (4, 4, 0, 1), (4, -4, -2.5, 1), (5.5, 0, -2.5, 1), (4, 4, -2.5, 1), (0, 5.5, -2.5, 1), (-4, 4, -2.5, 1), (-5.5, 0, -2.5, 1), (-4, -4, -2.5, 1), (0, -5.5, -2.5, 1), (4, -4, -2.5, 1), (5.5, 0, -2.5, 1), (4, 4, -2.5, 1)] )
                >>> sorted(mySurf.ep[0][:].indices())      # doctest: +ELLIPSIS
                [ComponentIndex((0, 0), ... ComponentIndex((0, 8), label=None)]
                >>> mySurf.numEPsInV()
                9
    
            :rtype: `int`
            """)


class Mesh(SurfaceShape):

    """
    The Mesh class provides wrapped access to many API methods for querying and modifying meshes.  Be aware that
    modifying meshes using API commands outside of the context of a plugin is still somewhat uncharted territory,
    so proceed at our own risk.


    The component types can be accessed from the `Mesh` type (or it's transform) using the names you are
    familiar with from MEL:

        >>> from pymel.core import *
        >>> p = polySphere( name='theMoon', sa=7, sh=7 )[0]
        >>> p.vtx
        MeshVertex(u'theMoonShape.vtx[0:43]')
        >>> p.e
        MeshEdge(u'theMoonShape.e[0:90]')
        >>> p.f
        MeshFace(u'theMoonShape.f[0:48]')

    They are also accessible from their more descriptive alternatives:

        >>> p.verts
        MeshVertex(u'theMoonShape.vtx[0:43]')
        >>> p.edges
        MeshEdge(u'theMoonShape.e[0:90]')
        >>> p.faces
        MeshFace(u'theMoonShape.f[0:48]')

    As you'd expect, these components are all indexible:

        >>> p.vtx[0]
        MeshVertex(u'theMoonShape.vtx[0]')

    The classes themselves contain methods for getting information about the component.

        >>> p.vtx[0].connectedEdges()
        MeshEdge(u'theMoonShape.e[0,6,42,77]')

    This class provides support for python's extended slice notation. Typical maya ranges express a start and stop value separated
    by a colon.  Extended slices add a step parameter and can also represent multiple ranges separated by commas.
    Thus, a single component object can represent any collection of indices.

    This includes start, stop, and step values.

        >>> # do every other edge between 0 and 10
        >>> for edge in p.e[0:10:2]:
        ...     print edge
        ...
        theMoonShape.e[0]
        theMoonShape.e[2]
        theMoonShape.e[4]
        theMoonShape.e[6]
        theMoonShape.e[8]
        theMoonShape.e[10]

    Negative indices can be used for getting indices relative to the end:

        >>> p.edges  # the full range
        MeshEdge(u'theMoonShape.e[0:90]')
        >>> p.edges[5:-10]  # index 5 through to 10 from the last
        MeshEdge(u'theMoonShape.e[5:80]')

    Just like with python ranges, you can leave an index out, and the logical result will follow:

        >>> p.edges[:-10]  # from the beginning
        MeshEdge(u'theMoonShape.e[0:80]')
        >>> p.edges[20:]
        MeshEdge(u'theMoonShape.e[20:90]')

    Or maybe you want the position of every tenth vert:

        >>> for x in p.vtx[::10]:
        ...     print x, x.getPosition()
        ...
        theMoonShape.vtx[0] [0.270522117615, -0.900968849659, -0.339223951101]
        theMoonShape.vtx[10] [-0.704405844212, -0.623489797115, 0.339223951101]
        theMoonShape.vtx[20] [0.974927902222, -0.222520858049, 0.0]
        theMoonShape.vtx[30] [-0.704405784607, 0.623489797115, -0.339224010706]
        theMoonShape.vtx[40] [0.270522087812, 0.900968849659, 0.339223980904]


    To be compatible with Maya's range notation, these slices are inclusive of the stop index.

        >>> # face at index 8 will be included in the sequence
        >>> for f in p.f[4:8]: print f
        ...
        theMoonShape.f[4]
        theMoonShape.f[5]
        theMoonShape.f[6]
        theMoonShape.f[7]
        theMoonShape.f[8]

    >>> from pymel.core import *
    >>> obj = polyTorus()[0]
    >>> colors = []
    >>> for i, vtx in enumerate(obj.vtx):   # doctest: +SKIP
    ...     edgs=vtx.toEdges()              # doctest: +SKIP
    ...     totalLen=0                      # doctest: +SKIP
    ...     edgCnt=0                        # doctest: +SKIP
    ...     for edg in edgs:                # doctest: +SKIP
    ...         edgCnt += 1                 # doctest: +SKIP
    ...         l = edg.getLength()         # doctest: +SKIP
    ...         totalLen += l               # doctest: +SKIP
    ...     avgLen=totalLen / edgCnt        # doctest: +SKIP
    ...     #print avgLen                   # doctest: +SKIP
    ...     currColor = vtx.getColor(0)     # doctest: +SKIP
    ...     color = datatypes.Color.black   # doctest: +SKIP
    ...     # only set blue if it has not been set before
    ...     if currColor.b<=0.0:            # doctest: +SKIP
    ...         color.b = avgLen            # doctest: +SKIP
    ...     color.r = avgLen                # doctest: +SKIP
    ...     colors.append(color)            # doctest: +SKIP


    """
#    def __init__(self, *args, **kwargs ):
#        SurfaceShape.__init__(self, self._apiobject )
#        self.vtx = MeshEdge(self.__apimobject__() )
    _componentAttributes = {'vtx': general.MeshVertex,
                            'verts': general.MeshVertex,
                            'e': general.MeshEdge,
                            'edges': general.MeshEdge,
                            'f': general.MeshFace,
                            'faces': general.MeshFace,
                            'map': general.MeshUV,
                            'uvs': general.MeshUV,
                            'vtxFace': general.MeshVertexFace,
                            'faceVerts': general.MeshVertexFace}

    # Unfortunately, objects that don't yet have any mesh data - ie, if you do
    # createNode('mesh') - can't be fed into MFnMesh (even though it is a mesh
    # node).  This means that all the methods wrapped from MFnMesh won't be
    # usable in this case.  While it might make sense for some methods - ie,
    # editing methods like collapseEdges - to fail in this situation, some
    # basic methods like numVertices should still be usable.  Therefore,
    # we override some of these with the mel versions (which still work...)
    numVertices = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'vertex', 'numVertices')
    numEdges = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'edge', 'numEdges')
    numFaces = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'face', 'numFaces')

    numTriangles = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'triangle', 'numTriangles')
    numSelectedTriangles = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'triangleComponent', 'numSelectedTriangles')
    numSelectedFaces = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'faceComponent', 'numSelectedFaces')
    numSelectedEdges = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'edgeComponent', 'numSelectedEdges')
    numSelectedVertices = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'vertexComponent', 'numSelectedVertices')

    area = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'area')
    worldArea = _factories.makeCreateFlagMethod(cmds.polyEvaluate, 'worldArea')

    if versions.current() >= versions.v2016:
        @_factories.addApiDocs(_api.MFnMesh, 'getUVAtPoint')
        def getUVAtPoint(self, uvPoint, space=_api.MSpace.kObject, uvSet=None, returnClosestPolygon=False):
            result = self._getUVAtPoint(uvPoint, space, uvSet)
            if returnClosestPolygon:
                return result
            return result[0]

    if versions.current() >= versions.v2009:
        @_factories.addApiDocs(_api.MFnMesh, 'currentUVSetName')
        def getCurrentUVSetName(self):
            return self.__apimfn__().currentUVSetName(self.instanceNumber())

        @_factories.addApiDocs(_api.MFnMesh, 'currentColorSetName')
        def getCurrentColorSetName(self):
            return self.__apimfn__().currentColorSetName(self.instanceNumber())

    else:
        @_factories.addApiDocs(_api.MFnMesh, 'currentUVSetName')
        def getCurrentUVSetName(self):
            return self.__apimfn__().currentUVSetName()

        @_factories.addApiDocs(_api.MFnMesh, 'currentColorSetName')
        def getCurrentColorSetName(self):
            return self.__apimfn__().currentColorSetName()

    @_factories.addApiDocs(_api.MFnMesh, 'numColors')
    def numColors(self, colorSet=None):
        mfn = self.__apimfn__()
        # If we have an empty mesh, we will get an MFnDagNode...
        if not isinstance(mfn, _api.MFnMesh):
            return 0
        args = []
        if colorSet:
            args.append(colorSet)
        return mfn.numColors(*args)
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnMesh
    __melnode__ = u'mesh'
    __slots__ = ()
    BoolOperation = Enum('BoolOperation', {'union': 1, 'kUnion': 1, 'difference': 2, 'kDifference': 2, 'kIntersection': 3, 'intersection': 3}, multiKeys=True, defaultKeys={1: 'union', 2: 'difference', 3: 'intersection'})
    MColorRepresentation = Enum('MColorRepresentation', {'alpha': 1, 'kAlpha': 1, 'RGB': 3, 'kRGB': 3, 'kRGBA': 4, 'RGBA': 4}, multiKeys=True, defaultKeys={1: 'alpha', 3: 'RGB', 4: 'RGBA'})
    SplitPlacement = Enum('SplitPlacement', {'kOnEdge': 0, 'onEdge': 0, 'internalPoint': 1, 'kInternalPoint': 1, 'kInvalid': 2, 'invalid': 2}, multiKeys=True, defaultKeys={0: 'onEdge', 1: 'internalPoint', 2: 'invalid'})

    @_f.addApiDocs(_api.MFnMesh, 'getAssociatedColorSetInstances')
    def _getAssociatedColorSetInstances(self, colorSetName):
        # type: (unicode) -> List[int]
        do, final_do, outTypes = _f.getDoArgs([colorSetName], [('colorSetName', 'MString', 'in', None), ('instances', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getAssociatedColorSetInstances', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getAssociatedUVSetInstances')
    def _getAssociatedUVSetInstances(self, uvSetName):
        # type: (unicode) -> List[int]
        do, final_do, outTypes = _f.getDoArgs([uvSetName], [('uvSetName', 'MString', 'in', None), ('instances', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getAssociatedUVSetInstances', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getUVAtPoint')
    def _getUVAtPoint(self, pt, space='preTransform', uvSet=None):
        # type: (Point, datatypes.Space.Space, unicode) -> Tuple[Tuple[float, float], int]
        do, final_do, outTypes = _f.getDoArgs([pt, space, uvSet], [('pt', 'MPoint', 'in', None), ('uvPoint', 'float2', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None), ('closestPolygon', 'int', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getUVAtPoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'numColorSets')
    def _numColorSets(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numColorSets')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'numColors')
    def _numColors(self, colorSet):
        # type: (unicode) -> int
        do, final_do, outTypes = _f.getDoArgs([colorSet], [('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'numColors', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'numEdges')
    def _numEdges(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numEdges')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'numFaceVertices')
    def _numFaceVertices(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numFaceVertices')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'numNormals')
    def _numNormals(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numNormals')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'numPolygons')
    def _numPolygons(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numPolygons')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'numUVSets')
    def _numUVSets(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numUVSets')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'numUVs')
    def _numUVs(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numUVs')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'numVertices')
    def _numVertices(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numVertices')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'addHoles')
    def addHoles(self, faceIndex, vertexArray, loopCounts, mergeVertices=True, pointTolerance=1e-10):
        # type: (int, List[Point], List[int], bool, float) -> None
        do, final_do, outTypes = _f.getDoArgs([faceIndex, vertexArray, loopCounts, mergeVertices, pointTolerance], [('faceIndex', 'int', 'in', None), ('vertexArray', 'MPointArray', 'in', None), ('loopCounts', 'MIntArray', 'in', None), ('mergeVertices', 'bool', 'in', None), ('pointTolerance', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'addHoles', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'assignColor')
    def assignColor(self, polygonId, vertexIndex, colorId, colorSet=None):
        # type: (int, int, int, unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([polygonId, vertexIndex, colorId, colorSet], [('polygonId', 'int', 'in', None), ('vertexIndex', 'int', 'in', None), ('colorId', 'int', 'in', None), ('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'assignColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'assignColors')
    def assignColors(self, colorIds, colorSet=None):
        # type: (List[int], unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([colorIds, colorSet], [('colorIds', 'MIntArray', 'in', None), ('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'assignColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'assignUV')
    def assignUV(self, polygonId, vertexIndex, uvId, uvSet=None):
        # type: (int, int, int, unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([polygonId, vertexIndex, uvId, uvSet], [('polygonId', 'int', 'in', None), ('vertexIndex', 'int', 'in', None), ('uvId', 'int', 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'assignUV', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'assignUVs')
    def assignUVs(self, uvCounts, uvIds, uvSet=None):
        # type: (List[int], List[int], unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([uvCounts, uvIds, uvSet], [('uvCounts', 'MIntArray', 'in', None), ('uvIds', 'MIntArray', 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'assignUVs', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'booleanOps')
    def booleanOps(self, op, meshes):
        # type: (Mesh.BoolOperation, List[general.PyNode]) -> bool
        do, final_do, outTypes = _f.getDoArgs([op, meshes], [('op', ('MFnMesh', 'BoolOperation'), 'in', None), ('meshes', 'MObjectArray', 'in', None), ('useLegacy', 'bool', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'booleanOps', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'cleanupEdgeSmoothing')
    def cleanupEdgeSmoothing(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnMesh, 'cleanupEdgeSmoothing')
        return res

    @_f.addApiDocs(_api.MFnMesh, 'clearColors')
    def clearColors(self, colorSet=None):
        # type: (unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([colorSet], [('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'clearColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'clearUVs')
    def clearUVs(self, uvSet=None):
        # type: (unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([uvSet], [('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'clearUVs', final_do)
        return res

    @classmethod
    @_f.addApiDocs(_api.MFnMesh, 'componentTypeFromName')
    def componentTypeFromName(self, assocName):
        # type: (unicode) -> datatypes.Fn.Type
        do, final_do, outTypes = _f.getDoArgs([assocName], [('assocName', 'MString', 'in', None)])
        res = _api.MFnMesh.componentTypeFromName(*final_do)
        res = _f.ApiArgUtil._castResult(self, res, ('MFn', 'Type'), None)
        return res

    @classmethod
    @_f.addApiDocs(_api.MFnMesh, 'componentTypeName')
    def componentTypeName(self, compType):
        # type: (datatypes.Fn.Type) -> unicode
        do, final_do, outTypes = _f.getDoArgs([compType], [('compType', ('MFn', 'Type'), 'in', None)])
        res = _api.MFnMesh.componentTypeName(*final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'createColorSetWithName')
    def createColorSet(self, colorSetName, modifier=None, instances=None):
        # type: (unicode, datatypes.DGModifier, datatypes.UintArray) -> unicode
        do, final_do, outTypes = _f.getDoArgs([colorSetName, modifier, instances], [('colorSetName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None), ('instances', 'MUintArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'createColorSetWithName', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.deprecated
    def createColorSetWithName(self, colorSetName, modifier=None, instances=None):
        # type: (unicode, datatypes.DGModifier, datatypes.UintArray) -> unicode
        do, final_do, outTypes = _f.getDoArgs([colorSetName, modifier, instances], [('colorSetName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None), ('instances', 'MUintArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'createColorSetWithName', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'createUVSetWithName')
    def createUVSet(self, uvSetName, modifier=None, instances=None):
        # type: (unicode, datatypes.DGModifier, datatypes.UintArray) -> unicode
        do, final_do, outTypes = _f.getDoArgs([uvSetName, modifier, instances], [('uvSetName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None), ('instances', 'MUintArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'createUVSetWithName', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.deprecated
    def createUVSetWithName(self, uvSetName, modifier=None, instances=None):
        # type: (unicode, datatypes.DGModifier, datatypes.UintArray) -> unicode
        do, final_do, outTypes = _f.getDoArgs([uvSetName, modifier, instances], [('uvSetName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None), ('instances', 'MUintArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'createUVSetWithName', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'deleteColorSet')
    def deleteColorSet(self, colorSetName, modifier=None, currentSelection=None):
        # type: (unicode, datatypes.DGModifier, SelectionSet) -> None
        do, final_do, outTypes = _f.getDoArgs([colorSetName, modifier, currentSelection], [('colorSetName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None), ('currentSelection', 'MSelectionList', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'deleteColorSet', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'deleteUVSet')
    def deleteUVSet(self, setName, modifier=None, currentSelection=None):
        # type: (unicode, datatypes.DGModifier, SelectionSet) -> None
        do, final_do, outTypes = _f.getDoArgs([setName, modifier, currentSelection], [('setName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None), ('currentSelection', 'MSelectionList', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'deleteUVSet', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'getAssignedUVs')
    def getAssignedUVs(self, uvSet=None):
        # type: (unicode) -> Tuple[List[int], List[int]]
        do, final_do, outTypes = _f.getDoArgs([uvSet], [('uvCounts', 'MIntArray', 'out', None), ('uvIds', 'MIntArray', 'out', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getAssignedUVs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def getAssociatedColorSetInstances(self, colorSetName):
        # type: (unicode) -> List[int]
        do, final_do, outTypes = _f.getDoArgs([colorSetName], [('colorSetName', 'MString', 'in', None), ('instances', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getAssociatedColorSetInstances', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def getAssociatedUVSetInstances(self, uvSetName):
        # type: (unicode) -> List[int]
        do, final_do, outTypes = _f.getDoArgs([uvSetName], [('uvSetName', 'MString', 'in', None), ('instances', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getAssociatedUVSetInstances', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getAssociatedUVSetTextures')
    def getAssociatedUVSetTextures(self, uvSetName):
        # type: (unicode) -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([uvSetName], [('uvSetName', 'MString', 'in', None), ('textures', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getAssociatedUVSetTextures', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getAxisAtPoint')
    def getAxisAtPoint(self, pt, space='preTransform', uvSet=None):
        # type: (Point, datatypes.Space.Space, unicode) -> Tuple[Vector, Vector, Vector, int]
        do, final_do, outTypes = _f.getDoArgs([pt, space, uvSet], [('pt', 'MPoint', 'in', None), ('normal', 'MVector', 'out', None), ('uTangent', 'MVector', 'out', None), ('vTangent', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None), ('closestPolygon', 'int', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getAxisAtPoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getBinormals')
    def getBinormals(self, space='preTransform', uvSet=None):
        # type: (datatypes.Space.Space, unicode) -> List[FloatVector]
        do, final_do, outTypes = _f.getDoArgs([space, uvSet], [('binormals', 'MFloatVectorArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getBinormals', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getCheckSamePointTwice')
    def getCheckSamePointTwice(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnMesh, 'getCheckSamePointTwice')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnMesh, 'getClosestNormal')
    def getClosestNormal(self, toThisPoint, space='preTransform', accelParams=None):
        # type: (Point, datatypes.Space.Space, datatypes.MeshIsectAccelParams) -> Tuple[Vector, int]
        do, final_do, outTypes = _f.getDoArgs([toThisPoint, space, accelParams], [('toThisPoint', 'MPoint', 'in', None), ('theNormal', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('closestPolygon', 'int', 'out', None), ('accelParams', 'MMeshIsectAccelParams', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getClosestNormal', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getClosestPoint')
    def getClosestPoint(self, toThisPoint, space='preTransform', accelParams=None):
        # type: (Point, datatypes.Space.Space, datatypes.MeshIsectAccelParams) -> Tuple[Point, int]
        do, final_do, outTypes = _f.getDoArgs([toThisPoint, space, accelParams], [('toThisPoint', 'MPoint', 'in', None), ('theClosestPoint', 'MPoint', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('closestPolygon', 'int', 'out', None), ('accelParams', 'MMeshIsectAccelParams', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getClosestPoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getClosestPointAndNormal')
    def getClosestPointAndNormal(self, toThisPoint, space='preTransform', accelParams=None):
        # type: (Point, datatypes.Space.Space, datatypes.MeshIsectAccelParams) -> Tuple[Point, Vector, int]
        do, final_do, outTypes = _f.getDoArgs([toThisPoint, space, accelParams], [('toThisPoint', 'MPoint', 'in', None), ('theClosestPoint', 'MPoint', 'out', None), ('theNormal', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('closestPolygon', 'int', 'out', None), ('accelParams', 'MMeshIsectAccelParams', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getClosestPointAndNormal', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getColor')
    def getColor(self, colorId, colorSet=None, defaultUnsetColor=None):
        # type: (int, unicode, Color) -> Color
        do, final_do, outTypes = _f.getDoArgs([colorId, colorSet, defaultUnsetColor], [('colorId', 'int', 'in', None), ('color', 'MColor', 'out', None), ('colorSet', 'MString', 'in', None), ('defaultUnsetColor', 'MColor', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getColor', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getColorRepresentation')
    def getColorRepresentation(self, colorSet):
        # type: (unicode) -> Mesh.MColorRepresentation
        do, final_do, outTypes = _f.getDoArgs([colorSet], [('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getColorRepresentation', final_do)
        res = _f.ApiArgUtil._castResult(self, res, ('MFnMesh', 'MColorRepresentation'), None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'getColorSetFamilyNames')
    def getColorSetFamilyNames(self):
        # type: () -> List[unicode]
        do, final_do, outTypes = _f.getDoArgs([], [('familyNames', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getColorSetFamilyNames', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getColorSetNames')
    def getColorSetNames(self):
        # type: () -> List[unicode]
        do, final_do, outTypes = _f.getDoArgs([], [('setNames', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getColorSetNames', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getColors')
    def getColors(self, colorSet=None, defaultUnsetColor=None):
        # type: (unicode, Color) -> List[Color]
        do, final_do, outTypes = _f.getDoArgs([colorSet, defaultUnsetColor], [('colorArray', 'MColorArray', 'out', None), ('colorSet', 'MString', 'in', None), ('defaultUnsetColor', 'MColor', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getColors', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'displayColors')
    def getDisplayColors(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnMesh, 'displayColors')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnMesh, 'getEdgeVertices')
    def getEdgeVertices(self, edgeId):
        # type: (int) -> Tuple[int, int]
        do, final_do, outTypes = _f.getDoArgs([edgeId], [('edgeId', 'int', 'in', None), ('vertexList', 'int2', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getEdgeVertices', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceNormalIds')
    def getFaceNormalIds(self, faceIndex):
        # type: (int) -> List[int]
        do, final_do, outTypes = _f.getDoArgs([faceIndex], [('faceIndex', 'int', 'in', None), ('normals', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceNormalIds', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceUVSetNames')
    def getFaceUVSetNames(self, polygonId):
        # type: (int) -> List[unicode]
        do, final_do, outTypes = _f.getDoArgs([polygonId], [('polygonId', 'int', 'in', None), ('setNames', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceUVSetNames', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceVertexBinormal')
    def getFaceVertexBinormal(self, faceIndex, vertexIndex, space='preTransform', uvSet=None):
        # type: (int, int, datatypes.Space.Space, unicode) -> Vector
        do, final_do, outTypes = _f.getDoArgs([faceIndex, vertexIndex, space, uvSet], [('faceIndex', 'int', 'in', None), ('vertexIndex', 'int', 'in', None), ('binormal', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceVertexBinormal', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceVertexBinormals')
    def getFaceVertexBinormals(self, faceIndex, space='preTransform', uvSet=None):
        # type: (int, datatypes.Space.Space, unicode) -> List[FloatVector]
        do, final_do, outTypes = _f.getDoArgs([faceIndex, space, uvSet], [('faceIndex', 'int', 'in', None), ('binormals', 'MFloatVectorArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceVertexBinormals', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceVertexColorIndex')
    def getFaceVertexColorIndex(self, faceIndex, localVertexIndex, colorSet=None):
        # type: (int, int, unicode) -> int
        do, final_do, outTypes = _f.getDoArgs([faceIndex, localVertexIndex, colorSet], [('faceIndex', 'int', 'in', None), ('localVertexIndex', 'int', 'in', None), ('colorIndex', 'int', 'out', None), ('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceVertexColorIndex', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceVertexColors')
    def getFaceVertexColors(self, colorSet=None, defaultUnsetColor=None):
        # type: (unicode, Color) -> List[Color]
        do, final_do, outTypes = _f.getDoArgs([colorSet, defaultUnsetColor], [('colors', 'MColorArray', 'out', None), ('colorSet', 'MString', 'in', None), ('defaultUnsetColor', 'MColor', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceVertexColors', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceVertexNormal')
    def getFaceVertexNormal(self, faceIndex, vertexIndex, space='preTransform'):
        # type: (int, int, datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([faceIndex, vertexIndex, space], [('faceIndex', 'int', 'in', None), ('vertexIndex', 'int', 'in', None), ('normal', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceVertexNormal', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceVertexTangent')
    def getFaceVertexTangent(self, faceIndex, vertexIndex, space='preTransform', uvSet=None):
        # type: (int, int, datatypes.Space.Space, unicode) -> Vector
        do, final_do, outTypes = _f.getDoArgs([faceIndex, vertexIndex, space, uvSet], [('faceIndex', 'int', 'in', None), ('vertexIndex', 'int', 'in', None), ('tangent', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceVertexTangent', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getFaceVertexTangents')
    def getFaceVertexTangents(self, faceIndex, space='preTransform', uvSet=None):
        # type: (int, datatypes.Space.Space, unicode) -> List[FloatVector]
        do, final_do, outTypes = _f.getDoArgs([faceIndex, space, uvSet], [('faceIndex', 'int', 'in', None), ('tangents', 'MFloatVectorArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getFaceVertexTangents', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getHoles')
    def getHoles(self):
        # type: () -> Tuple[int, List[int], List[int]]
        do, final_do, outTypes = _f.getDoArgs([], [('holeInfoArray', 'MIntArray', 'out', None), ('holeVertexArray', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getHoles', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getNormalIds')
    def getNormalIds(self):
        # type: () -> Tuple[List[int], List[int]]
        do, final_do, outTypes = _f.getDoArgs([], [('normalCounts', 'MIntArray', 'out', None), ('normals', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getNormalIds', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getNormals')
    def getNormals(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> List[FloatVector]
        do, final_do, outTypes = _f.getDoArgs([space], [('normals', 'MFloatVectorArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getNormals', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getPoint')
    def getPoint(self, vertexId, space='preTransform'):
        # type: (int, datatypes.Space.Space) -> Point
        do, final_do, outTypes = _f.getDoArgs([vertexId, space], [('vertexId', 'int', 'in', None), ('pos', 'MPoint', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getPoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getPointAtUV')
    def getPointAtUV(self, polygonId, uvPoint, space='preTransform', uvSet=None, tolerance=0.0):
        # type: (int, Tuple[float, float], datatypes.Space.Space, unicode, float) -> Point
        do, final_do, outTypes = _f.getDoArgs([polygonId, uvPoint, space, uvSet, tolerance], [('polygonId', 'int', 'in', None), ('toThisPoint', 'MPoint', 'out', None), ('uvPoint', 'float2', 'in', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None), ('tolerance', 'float', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getPointAtUV', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getPoints')
    def getPoints(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> List[Point]
        do, final_do, outTypes = _f.getDoArgs([space], [('vertexArray', 'MPointArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getPoints', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getPolygonNormal')
    def getPolygonNormal(self, polygonId, space='preTransform'):
        # type: (int, datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([polygonId, space], [('polygonId', 'int', 'in', None), ('normal', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getPolygonNormal', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getPolygonTriangleVertices')
    def getPolygonTriangleVertices(self, polygonId, triangleId):
        # type: (int, int) -> Tuple[int, int, int]
        do, final_do, outTypes = _f.getDoArgs([polygonId, triangleId], [('polygonId', 'int', 'in', None), ('triangleId', 'int', 'in', None), ('vertexList', 'int__array3', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getPolygonTriangleVertices', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getPolygonUV')
    def getPolygonUV(self, polygonId, vertexIndex, uvSet=None):
        # type: (int, int, unicode) -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([polygonId, vertexIndex, uvSet], [('polygonId', 'int', 'in', None), ('vertexIndex', 'int', 'in', None), ('u', 'float', 'out', None), ('v', 'float', 'out', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getPolygonUV', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getPolygonUVid')
    def getPolygonUVid(self, polygonId, vertexIndex, uvSet=None):
        # type: (int, int, unicode) -> int
        do, final_do, outTypes = _f.getDoArgs([polygonId, vertexIndex, uvSet], [('polygonId', 'int', 'in', None), ('vertexIndex', 'int', 'in', None), ('uvId', 'int', 'out', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getPolygonUVid', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getPolygonVertices')
    def getPolygonVertices(self, polygonId):
        # type: (int) -> List[int]
        do, final_do, outTypes = _f.getDoArgs([polygonId], [('polygonId', 'int', 'in', None), ('vertexList', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getPolygonVertices', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getTangentId')
    def getTangentId(self, faceIndex, vertexIndex):
        # type: (int, int) -> int
        do, final_do, outTypes = _f.getDoArgs([faceIndex, vertexIndex], [('faceIndex', 'int', 'in', None), ('vertexIndex', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getTangentId', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'getTangents')
    def getTangents(self, space='preTransform', uvSet=None):
        # type: (datatypes.Space.Space, unicode) -> List[FloatVector]
        do, final_do, outTypes = _f.getDoArgs([space, uvSet], [('tangents', 'MFloatVectorArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getTangents', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getTriangleOffsets')
    def getTriangleOffsets(self):
        # type: () -> Tuple[List[int], List[int]]
        do, final_do, outTypes = _f.getDoArgs([], [('triangleCounts', 'MIntArray', 'out', None), ('triangleIndices', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getTriangleOffsets', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getTriangles')
    def getTriangles(self):
        # type: () -> Tuple[List[int], List[int]]
        do, final_do, outTypes = _f.getDoArgs([], [('triangleCounts', 'MIntArray', 'out', None), ('triangleVertices', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getTriangles', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getUV')
    def getUV(self, uvId, uvSet=None):
        # type: (int, unicode) -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([uvId, uvSet], [('uvId', 'int', 'in', None), ('u', 'float', 'out', None), ('v', 'float', 'out', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getUV', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getUVSetFamilyNames')
    def getUVSetFamilyNames(self):
        # type: () -> List[unicode]
        do, final_do, outTypes = _f.getDoArgs([], [('familyNames', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getUVSetFamilyNames', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getUVSetNames')
    def getUVSetNames(self):
        # type: () -> List[unicode]
        do, final_do, outTypes = _f.getDoArgs([], [('setNames', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getUVSetNames', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getUVSetsInFamily')
    def getUVSetsInFamily(self, familyName):
        # type: (unicode) -> List[unicode]
        do, final_do, outTypes = _f.getDoArgs([familyName], [('familyName', 'MString', 'in', None), ('setNames', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getUVSetsInFamily', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getUVs')
    def getUVs(self, uvSet=None):
        # type: (unicode) -> Tuple[List[float], List[float]]
        do, final_do, outTypes = _f.getDoArgs([uvSet], [('uArray', 'MFloatArray', 'out', None), ('vArray', 'MFloatArray', 'out', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getUVs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getUvShellsIds')
    def getUvShellsIds(self, uvSet=None):
        # type: (unicode) -> Tuple[List[int], int]
        do, final_do, outTypes = _f.getDoArgs([uvSet], [('uvShellIds', 'MIntArray', 'out', None), ('nbUvShells', 'uint', 'out', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getUvShellsIds', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getVertexNormal')
    def getVertexNormal(self, vertexId, angleWeighted, space='preTransform'):
        # type: (int, bool, datatypes.Space.Space) -> Vector
        do, final_do, outTypes = _f.getDoArgs([vertexId, angleWeighted, space], [('vertexId', 'int', 'in', None), ('angleWeighted', 'bool', 'in', None), ('normal', 'MVector', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getVertexNormal', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'getVertices')
    def getVertices(self):
        # type: () -> Tuple[List[int], List[int]]
        do, final_do, outTypes = _f.getDoArgs([], [('vertexCount', 'MIntArray', 'out', None), ('vertexList', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'getVertices', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'hasAlphaChannels')
    def hasAlphaChannels(self, colorSet):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([colorSet], [('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'hasAlphaChannels', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'hasColorChannels')
    def hasColorChannels(self, colorSet):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([colorSet], [('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'hasColorChannels', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'intersect')
    def intersect(self, raySource, rayDirection, tolerance=1e-10, space='preTransform'):
        # type: (Point, Vector, float, datatypes.Space.Space) -> Tuple[bool, List[Point], List[int]]
        do, final_do, outTypes = _f.getDoArgs([raySource, rayDirection, tolerance, space], [('raySource', 'MPoint', 'in', None), ('rayDirection', 'MVector', 'in', None), ('points', 'MPointArray', 'out', None), ('tolerance', 'double', 'in', None), ('space', ('MSpace', 'Space'), 'in', None), ('polygonIds', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'intersect', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMesh, 'isColorClamped')
    def isColorClamped(self, colorSet):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([colorSet], [('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'isColorClamped', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'isColorSetPerInstance')
    def isColorSetPerInstance(self, name):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([name], [('name', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'isColorSetPerInstance', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'isEdgeSmooth')
    def isEdgeSmooth(self, edgeId):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([edgeId], [('edgeId', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'isEdgeSmooth', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'isNormalLocked')
    def isNormalLocked(self, normalId):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([normalId], [('normalId', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'isNormalLocked', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'isPolygonConvex')
    def isPolygonConvex(self, faceIndex):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([faceIndex], [('faceIndex', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'isPolygonConvex', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'isRightHandedTangent')
    def isRightHandedTangent(self, tangentId, uvSetName=None):
        # type: (int, unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([tangentId, uvSetName], [('tangentId', 'int', 'in', None), ('uvSetName', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'isRightHandedTangent', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'isUVSetPerInstance')
    def isUVSetPerInstance(self, name):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([name], [('name', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'isUVSetPerInstance', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'lockFaceVertexNormals')
    def lockFaceVertexNormals(self, faceList, vertexList):
        # type: (List[int], List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([faceList, vertexList], [('faceList', 'MIntArray', 'in', None), ('vertexList', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'lockFaceVertexNormals', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'lockVertexNormals')
    def lockVertexNormals(self, vertexList):
        # type: (List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([vertexList], [('vertexList', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'lockVertexNormals', final_do)
        return res

    @_f.deprecated
    def numColorSets(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numColorSets')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.deprecated
    def numFaceVertices(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numFaceVertices')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.deprecated
    def numNormals(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numNormals')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'polygonVertexCount')
    def numPolygonVertices(self, polygonId):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([polygonId], [('polygonId', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'polygonVertexCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.deprecated
    def numPolygons(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numPolygons')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.deprecated
    def numUVSets(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numUVSets')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.deprecated
    def numUVs(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMesh, 'numUVs')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMesh, 'onBoundary')
    def onBoundary(self, polygonId):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([polygonId], [('polygonId', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'onBoundary', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @classmethod
    @_f.addApiDocs(_api.MFnMesh, 'polyTriangulate')
    def polyTriangulate(self, pointsAndHoles, pointsCount, outerPointsCount, holesCount, considerNormal, normals):
        # type: (float, int, int, int, bool, float) -> Tuple[int, int]
        do, final_do, outTypes = _f.getDoArgs([pointsAndHoles, pointsCount, outerPointsCount, holesCount, considerNormal, normals], [('pointsAndHoles', 'float', 'in', None), ('pointsCount', 'uint', 'in', None), ('outerPointsCount', 'uint', 'in', None), ('holesCount', 'uint', 'in', None), ('considerNormal', 'bool', 'in', None), ('normals', 'float', 'in', None), ('triangles', 'short', 'out', None), ('trianglesCount', 'int', 'out', None)])
        res = _api.MFnMesh.polyTriangulate(*final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def polygonVertexCount(self, polygonId):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([polygonId], [('polygonId', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'polygonVertexCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'removeFaceColors')
    def removeFaceColors(self, faceList):
        # type: (List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([faceList], [('faceList', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'removeFaceColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'removeFaceVertexColors')
    def removeFaceVertexColors(self, faceList, vertexList):
        # type: (List[int], List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([faceList, vertexList], [('faceList', 'MIntArray', 'in', None), ('vertexList', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'removeFaceVertexColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'removeVertexColors')
    def removeVertexColors(self, vertexList):
        # type: (List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([vertexList], [('vertexList', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'removeVertexColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'renameUVSet')
    def renameUVSet(self, origName, newName, modifier=None):
        # type: (unicode, unicode, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.getDoArgs([origName, newName, modifier], [('origName', 'MString', 'in', None), ('newName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'renameUVSet', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setCheckSamePointTwice')
    def setCheckSamePointTwice(self, check=True):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([check], [('check', 'bool', 'in', None)], self.getCheckSamePointTwice, self.setCheckSamePointTwice, [])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setCheckSamePointTwice', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setColor')
    def setColor(self, colorId, color, colorSet=None):
        # type: (int, Color, unicode) -> None
        do, final_do, outTypes = _f.processApiArgs([colorId, color, colorSet], [('colorId', 'int', 'in', None), ('color', 'MColor', 'in', None), ('colorSet', 'MString', 'in', None)], self.getColor, self.setColor, ['colorId', 'colorSet', 'defaultUnsetColor'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setIsColorClamped')
    def setColorClamped(self, colorSet, clamped):
        # type: (unicode, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([colorSet, clamped], [('colorSet', 'MString', 'in', None), ('clamped', 'bool', 'in', None)], self.isColorClamped, self.setColorClamped, ['colorSet'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setIsColorClamped', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setColors')
    def setColors(self, colorArray, colorSet=None):
        # type: (List[Color], unicode) -> None
        do, final_do, outTypes = _f.processApiArgs([colorArray, colorSet], [('colorArray', 'MColorArray', 'in', None), ('colorSet', 'MString', 'in', None)], self.getColors, self.setColors, ['colorSet', 'defaultUnsetColor'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setCurrentColorSetName')
    def setCurrentColorSetName(self, setName, modifier=None, currentSelection=None):
        # type: (unicode, datatypes.DGModifier, SelectionSet) -> None
        do, final_do, outTypes = _f.processApiArgs([setName, modifier, currentSelection], [('setName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None), ('currentSelection', 'MSelectionList', 'in', None)], self.getCurrentColorSetName, self.setCurrentColorSetName, ['instance'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setCurrentColorSetName', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setCurrentUVSetName')
    def setCurrentUVSetName(self, setName, modifier=None, currentSelection=None):
        # type: (unicode, datatypes.DGModifier, SelectionSet) -> None
        do, final_do, outTypes = _f.processApiArgs([setName, modifier, currentSelection], [('setName', 'MString', 'in', None), ('modifier', 'MDGModifier', 'in', None), ('currentSelection', 'MSelectionList', 'in', None)], self.getCurrentUVSetName, self.setCurrentUVSetName, ['instance'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setCurrentUVSetName', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setDisplayColors')
    def setDisplayColors(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enable], [('enable', 'bool', 'in', None)], self.getDisplayColors, self.setDisplayColors, [])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setDisplayColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setEdgeSmoothing')
    def setEdgeSmoothing(self, edgeId, smooth=True):
        # type: (int, bool) -> None
        do, final_do, outTypes = _f.getDoArgs([edgeId, smooth], [('edgeId', 'int', 'in', None), ('smooth', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setEdgeSmoothing', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setFaceColor')
    def setFaceColor(self, color, faceIndex):
        # type: (Color, int) -> None
        do, final_do, outTypes = _f.getDoArgs([color, faceIndex], [('color', 'MColor', 'in', None), ('faceIndex', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setFaceColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setFaceColors')
    def setFaceColors(self, colors, faceList):
        # type: (List[Color], List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([colors, faceList], [('colors', 'MColorArray', 'in', None), ('faceList', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setFaceColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setFaceVertexColor')
    def setFaceVertexColor(self, color, faceIndex, vertexIndex, modifier=None):
        # type: (Color, int, int, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.getDoArgs([color, faceIndex, vertexIndex, modifier], [('color', 'MColor', 'in', None), ('faceIndex', 'int', 'in', None), ('vertexIndex', 'int', 'in', None), ('modifier', 'MDGModifier', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setFaceVertexColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setFaceVertexNormal')
    def setFaceVertexNormal(self, normalIn, faceId, vertexId, space='preTransform', modifier=None):
        # type: (Vector, int, int, datatypes.Space.Space, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.getDoArgs([normalIn, faceId, vertexId, space, modifier], [('normalIn', 'MVector', 'in', None), ('faceId', 'int', 'in', None), ('vertexId', 'int', 'in', None), ('space', ('MSpace', 'Space'), 'in', None), ('modifier', 'MDGModifier', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setFaceVertexNormal', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setNormals')
    def setNormals(self, normals, space='preTransform'):
        # type: (List[FloatVector], datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([normals, space], [('normals', 'MFloatVectorArray', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getNormals, self.setNormals, ['space'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setNormals', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setPoint')
    def setPoint(self, vertexId, pos, space='preTransform'):
        # type: (int, Point, datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([vertexId, pos, space], [('vertexId', 'int', 'in', None), ('pos', 'MPoint', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)], self.getPoint, self.setPoint, ['vertexId', 'space'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setPoint', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setPoints')
    def setPoints(self, vertexArray, space='preTransform'):
        # type: (List[Point], datatypes.Space.Space) -> None
        do, final_do, outTypes = _f.processApiArgs([vertexArray, space], [(u'vertexArray', 'MPointArray', u'in', None), (u'space', ('MSpace', 'Space'), 'in', None)], self.getPoints, self.setPoints, ['space'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setPoints', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setSomeColors')
    def setSomeColors(self, colorIds, colorArray, colorSet=None):
        # type: (List[int], List[Color], unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([colorIds, colorArray, colorSet], [('colorIds', 'MIntArray', 'in', None), ('colorArray', 'MColorArray', 'in', None), ('colorSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setSomeColors', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setSomeUVs')
    def setSomeUVs(self, uvIds, uArray, vArray, uvSet=None):
        # type: (List[int], List[float], List[float], unicode) -> None
        do, final_do, outTypes = _f.getDoArgs([uvIds, uArray, vArray, uvSet], [('uvIds', 'MIntArray', 'in', None), ('uArray', 'MFloatArray', 'in', None), ('vArray', 'MFloatArray', 'in', None), ('uvSet', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setSomeUVs', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setUV')
    def setUV(self, uvId, u, v, uvSet=None):
        # type: (int, float, float, unicode) -> None
        do, final_do, outTypes = _f.processApiArgs([uvId, u, v, uvSet], [('uvId', 'int', 'in', None), ('u', 'float', 'in', None), ('v', 'float', 'in', None), ('uvSet', 'MString', 'in', None)], self.getUV, self.setUV, ['uvId', 'uvSet'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setUV', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setUVs')
    def setUVs(self, uArray, vArray, uvSet=None):
        # type: (List[float], List[float], unicode) -> None
        do, final_do, outTypes = _f.processApiArgs([uArray, vArray, uvSet], [('uArray', 'MFloatArray', 'in', None), ('vArray', 'MFloatArray', 'in', None), ('uvSet', 'MString', 'in', None)], self.getUVs, self.setUVs, ['uvSet'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setUVs', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setVertexColor')
    def setVertexColor(self, color, vertexIndex, modifier=None):
        # type: (Color, int, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.getDoArgs([color, vertexIndex, modifier], [('color', 'MColor', 'in', None), ('vertexIndex', 'int', 'in', None), ('modifier', 'MDGModifier', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setVertexColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'setVertexNormal')
    def setVertexNormal(self, normalIn, vertexId, space='preTransform', modifier=None):
        # type: (Vector, int, datatypes.Space.Space, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([normalIn, vertexId, space, modifier], [('normalIn', 'MVector', 'in', None), ('vertexId', 'int', 'in', None), ('space', ('MSpace', 'Space'), 'in', None), ('modifier', 'MDGModifier', 'in', None)], self.getVertexNormal, self.setVertexNormal, ['vertexId', 'space'])
        res = _f.getProxyResult(self, _api.MFnMesh, 'setVertexNormal', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'syncObject')
    def syncObject(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnMesh, 'syncObject')
        return res

    @_f.addApiDocs(_api.MFnMesh, 'unlockFaceVertexNormals')
    def unlockFaceVertexNormals(self, faceList, vertexList):
        # type: (List[int], List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([faceList, vertexList], [('faceList', 'MIntArray', 'in', None), ('vertexList', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'unlockFaceVertexNormals', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'unlockVertexNormals')
    def unlockVertexNormals(self, vertexList):
        # type: (List[int]) -> None
        do, final_do, outTypes = _f.getDoArgs([vertexList], [('vertexList', 'MIntArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMesh, 'unlockVertexNormals', final_do)
        return res

    @_f.addApiDocs(_api.MFnMesh, 'updateSurface')
    def updateSurface(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnMesh, 'updateSurface')
        return res
# ------ Do not edit above this line --------


# Unfortunately, objects that don't yet have any mesh data - ie, if you do
# createNode('mesh') - can't be fed into MFnMesh (even though it is a mesh
# node).  This means that all the methods wrapped from MFnMesh won't be
# usable in this case.  While it might make sense for some methods - ie,
# editing methods like collapseEdges - to fail in this situation, some
# basic methods like numVertices should still be usable.  Therefore,
# we override some of these with the mel versions (which still work...)

def _makeApiMethodWrapForEmptyMesh(apiMethodName, baseMethodName=None,
                                   resultName=None, defaultVal=0):
    if baseMethodName is None:
        baseMethodName = '_' + apiMethodName
    if resultName is None:
        resultName = apiMethodName

    baseMethod = getattr(Mesh, baseMethodName)

    @_factories.addApiDocs(_api.MFnMesh, apiMethodName)
    def methodWrapForEmptyMesh(self, *args, **kwargs):
        # If we have an empty mesh, we will get an MFnDagNode...
        mfn = self.__apimfn__()
        if not isinstance(mfn, _api.MFnMesh):
            return defaultVal
        return baseMethod(self, *args, **kwargs)
    methodWrapForEmptyMesh.__name__ = resultName
    return methodWrapForEmptyMesh


if not _factories.building:
    # keep this safe to load if the templates have not been built yet
    for _apiMethodName in '''numColorSets
                        numFaceVertices
                        numNormals
                        numUVSets
                        numUVs'''.split():
        _wrappedFunc = _makeApiMethodWrapForEmptyMesh(_apiMethodName)
        setattr(Mesh, _wrappedFunc.__name__, _wrappedFunc)


class Subdiv(SurfaceShape):

    _componentAttributes = {'smp': general.SubdVertex,
                            'verts': general.SubdVertex,
                            'sme': general.SubdEdge,
                            'edges': general.SubdEdge,
                            'smf': general.SubdFace,
                            'faces': general.SubdFace,
                            'smm': general.SubdUV,
                            'uvs': general.SubdUV}

    def getTweakedVerts(self, **kwargs):
        return cmds.querySubdiv(action=1, **kwargs)

    def getSharpenedVerts(self, **kwargs):
        return cmds.querySubdiv(action=2, **kwargs)

    def getSharpenedEdges(self, **kwargs):
        return cmds.querySubdiv(action=3, **kwargs)

    def getEdges(self, **kwargs):
        return cmds.querySubdiv(action=4, **kwargs)

    def cleanTopology(self):
        cmds.subdCleanTopology(self)
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnSubd
    __melcmd__ = staticmethod(modeling.subdiv)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'subdiv'
    __melnode__ = u'subdiv'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnSubd, 'collapse')
    def collapse(self, level, makeNewNodeInvisible):
        # type: (int, bool) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([level, makeNewNodeInvisible], [('level', 'int', 'in', None), ('makeNewNodeInvisible', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'collapse', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'convertToNurbs')
    def convertToNurbs(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('newNurbsSurfaces', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'convertToNurbs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnSubd, 'copy')
    def copy(self, source, parentOrOwner='MObject::kNullObj'):
        # type: (general.PyNode, general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([source, parentOrOwner], [('source', 'MObject', 'in', None), ('parentOrOwner', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'copy', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'creasesClearAll')
    def creasesClearAll(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnSubd, 'creasesClearAll')
        return res

    @_f.addApiDocs(_api.MFnSubd, 'createBaseMesh')
    def createBaseMesh(self, reverseNormal, numVertices, numPolygons, vertexArray, polygonCounts, polygonConnects, parentOrOwner='MObject::kNullObj'):
        # type: (bool, int, int, List[Point], List[int], List[int], general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([reverseNormal, numVertices, numPolygons, vertexArray, polygonCounts, polygonConnects, parentOrOwner], [('reverseNormal', 'bool', 'in', None), ('numVertices', 'int', 'in', None), ('numPolygons', 'int', 'in', None), ('vertexArray', 'MPointArray', 'in', None), ('polygonCounts', 'MIntArray', 'in', None), ('polygonConnects', 'MIntArray', 'in', None), ('parentOrOwner', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'createBaseMesh', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.deprecated
    def edgeCount(self, level=0):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([level], [('level', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'edgeCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'editsPending')
    def editsPending(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnSubd, 'editsPending')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnSubd, 'editsUpdateAll')
    def editsUpdateAll(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnSubd, 'editsUpdateAll')
        return res

    @_f.addMelDocs('subdiv', 'currentLevel')
    def getCurrentLevel(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'currentLevel')
        return res

    @_f.addMelDocs('subdiv', 'currentSubdLevel')
    def getCurrentSubdLevel(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'currentSubdLevel')
        return res

    @_f.addMelDocs('subdiv', 'deepestLevel')
    def getDeepestLevel(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'deepestLevel')
        return res

    @_f.addMelDocs('subdiv', 'displayLoad')
    def getDisplayLoad(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'displayLoad')
        return res

    @_f.addMelDocs('subdiv', 'edgeStats')
    def getEdgeStats(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'edgeStats')
        return res

    @_f.addMelDocs('subdiv', 'faceStats')
    def getFaceStats(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'faceStats')
        return res

    @_f.addMelDocs('subdiv', 'maxPossibleLevel')
    def getMaxPossibleLevel(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'maxPossibleLevel')
        return res

    @_f.addMelDocs('subdiv', 'proxyMode')
    def getProxyMode(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'proxyMode')
        return res

    @_f.addMelDocs('subdiv', 'smallOffsets')
    def getSmallOffsets(self, **kwargs):
        res = _f.asQuery(self, modeling.subdiv, kwargs, 'smallOffsets')
        return res

    @_f.addApiDocs(_api.MFnSubd, 'levelFullySubdivideTo')
    def levelFullySubdivideTo(self, level):
        # type: (int) -> None
        do, final_do, outTypes = _f.getDoArgs([level], [('level', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'levelFullySubdivideTo', final_do)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'levelMaxAllowed')
    def levelMaxAllowed(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnSubd, 'levelMaxAllowed')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnSubd, 'levelMaxCurrent')
    def levelMaxCurrent(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnSubd, 'levelMaxCurrent')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnSubd, 'edgeCount')
    def numEdges(self, level=0):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([level], [('level', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'edgeCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'polygonCount')
    def numFaces(self, level=0):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([level], [('level', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'polygonCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'vertexCount')
    def numVertices(self, level=0):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([level], [('level', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'vertexCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.deprecated
    def polygonCount(self, level=0):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([level], [('level', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'polygonCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'polygonCountMaxWithGivenBaseMesh')
    def polygonCountMaxWithGivenBaseMesh(self, level=1):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([level], [('level', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'polygonCountMaxWithGivenBaseMesh', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'tesselate')
    def tesselate(self, uniform, depth, sample, parentOrOwner='MObject::kNullObj'):
        # type: (bool, int, int, general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([uniform, depth, sample, parentOrOwner], [('uniform', 'bool', 'in', None), ('depth', 'int', 'in', None), ('sample', 'int', 'in', None), ('parentOrOwner', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'tesselate', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'tessellateViaNurbs')
    def tessellateViaNurbs(self, parentOrOwner='MObject::kNullObj'):
        # type: (general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([parentOrOwner], [('parentOrOwner', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'tessellateViaNurbs', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'updateAllEditsAndCreases')
    def updateAllEditsAndCreases(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnSubd, 'updateAllEditsAndCreases')
        return res

    @_f.addApiDocs(_api.MFnSubd, 'updateSubdSurface')
    def updateSubdSurface(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnSubd, 'updateSubdSurface')
        return res

    @_f.addApiDocs(_api.MFnSubd, 'vertexBaseMeshAdd')
    def vertexBaseMeshAdd(self, x, y, z):
        # type: (float, float, float) -> int
        do, final_do, outTypes = _f.getDoArgs([x, y, z], [('x', 'double', 'in', None), ('y', 'double', 'in', None), ('z', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'vertexBaseMeshAdd', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'vertexBaseMeshAddWithIndex')
    def vertexBaseMeshAddWithIndex(self, x, y, z, index):
        # type: (float, float, float, int) -> None
        do, final_do, outTypes = _f.getDoArgs([x, y, z, index], [('x', 'double', 'in', None), ('y', 'double', 'in', None), ('z', 'double', 'in', None), ('index', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'vertexBaseMeshAddWithIndex', final_do)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'vertexBaseMeshGet')
    def vertexBaseMeshGet(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> List[Point]
        do, final_do, outTypes = _f.getDoArgs([space], [('positions', 'MPointArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'vertexBaseMeshGet', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnSubd, 'vertexBaseMeshSet')
    def vertexBaseMeshSet(self, space='preTransform'):
        # type: (datatypes.Space.Space) -> List[Point]
        do, final_do, outTypes = _f.getDoArgs([space], [('positions', 'MPointArray', 'out', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'vertexBaseMeshSet', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def vertexCount(self, level=0):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([level], [('level', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSubd, 'vertexCount', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnSubd, 'vertexEditsClearAllNonBase')
    def vertexEditsClearAllNonBase(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnSubd, 'vertexEditsClearAllNonBase')
        return res
# ------ Do not edit above this line --------


class Lattice(ControlPoint):
    _componentAttributes = {'pt': general.LatticePoint,
                            'points': general.LatticePoint}
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnLattice
    __melcmd__ = staticmethod(animation.lattice)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'lattice'
    __melnode__ = u'lattice'
    __slots__ = ()

    @_f.addMelDocs('lattice', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'after', val)

    @_f.addMelDocs('lattice', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'afterReference', val)

    @_f.addMelDocs('lattice', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'before', val)

    @_f.addMelDocs('lattice', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('lattice', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.lattice, kwargs, 'deformerTools')
        return res

    @_f.addApiDocs(_api.MFnLattice, 'getDivisions')
    def getDivisions(self):
        # type: () -> Tuple[int, int, int]
        do, final_do, outTypes = _f.getDoArgs([], [('s', 'uint', 'out', None), ('t', 'uint', 'out', None), ('u', 'uint', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnLattice, 'getDivisions', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('lattice', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.lattice, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('lattice', 'freezeMapping')
    def getFreezeMapping(self, **kwargs):
        res = _f.asQuery(self, animation.lattice, kwargs, 'freezeMapping')
        return res

    @_f.addMelDocs('lattice', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.lattice, kwargs, 'geometry')
        return res

    @_f.addMelDocs('lattice', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.lattice, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('lattice', 'ldivisions')
    def getLdivisions(self, **kwargs):
        res = _f.asQuery(self, animation.lattice, kwargs, 'ldivisions')
        return res

    @_f.addMelDocs('lattice', 'latticeReset')
    def latticeReset(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'latticeReset', val)

    @_f.addMelDocs('lattice', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'parallel', val)

    @_f.addApiDocs(_api.MFnLattice, 'point')
    def point(self, s, t, u):
        # type: (int, int, int) -> Point
        do, final_do, outTypes = _f.getDoArgs([s, t, u], [('s', 'uint', 'in', None), ('t', 'uint', 'in', None), ('u', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLattice, 'point', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MPoint', None)
        return res

    @_f.addMelDocs('lattice', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'prune', val)

    @_f.addMelDocs('lattice', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'remove', val)

    @_f.addMelDocs('lattice', 'removeTweaks')
    def removeTweaks(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'removeTweaks', val)

    @_f.addApiDocs(_api.MFnLattice, 'reset')
    def reset(self, sSize=1.0, tSize=1.0, uSize=1.0):
        # type: (float, float, float) -> None
        do, final_do, outTypes = _f.getDoArgs([sSize, tSize, uSize], [('sSize', 'double', 'in', None), ('tSize', 'double', 'in', None), ('uSize', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLattice, 'reset', final_do)
        return res

    @_f.addApiDocs(_api.MFnLattice, 'setDivisions')
    def setDivisions(self, s, t, u):
        # type: (int, int, int) -> None
        do, final_do, outTypes = _f.processApiArgs([s, t, u], [('s', 'uint', 'in', None), ('t', 'uint', 'in', None), ('u', 'uint', 'in', None)], self.getDivisions, self.setDivisions, [])
        res = _f.getProxyResult(self, _api.MFnLattice, 'setDivisions', final_do)
        return res

    @_f.addMelDocs('lattice', 'freezeMapping')
    def setFreezeMapping(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'freezeMapping', val)

    @_f.addMelDocs('lattice', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'geometry', val)

    @_f.addMelDocs('lattice', 'ldivisions')
    def setLdivisions(self, val=True, **kwargs):
        return _f.asEdit(self, animation.lattice, kwargs, 'ldivisions', val)
# ------ Do not edit above this line --------


class Particle(DeformableShape):
    __apicls__ = _api.MFnParticleSystem
    _componentAttributes = {'pt': general.ParticleComponent,
                            'points': general.ParticleComponent}
    # for backwards compatibility
    Point = general.ParticleComponent

    # for backwards compatibility, keep these two, even though the api wrap
    # will also provide 'count'
    def pointCount(self):
        return cmds.particle(self, q=1, count=1)
    num = pointCount
# ------ Do not edit below this line --------
    __melcmd__ = staticmethod(effects.particle)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'particle'
    __melnode__ = u'particle'
    __slots__ = ()
    RenderType = Enum('RenderType', {'kCloud': 0, 'cloud': 0, 'tube': 1, 'kTube': 1, 'blobby': 2, 'kBlobby': 2, 'multiPoint': 3, 'kMultiPoint': 3, 'kMultiStreak': 4, 'multiStreak': 4, 'kNumeric': 5, 'numeric': 5, 'kPoints': 6, 'points': 6, 'kSpheres': 7, 'spheres': 7, 'kSprites': 8, 'sprites': 8, 'streak': 9, 'kStreak': 9}, multiKeys=True, defaultKeys={0: 'cloud', 1: 'tube', 2: 'blobby', 3: 'multiPoint', 4: 'multiStreak', 5: 'numeric', 6: 'points', 7: 'spheres', 8: 'sprites', 9: 'streak'})

    @_f.addApiDocs(_api.MFnParticleSystem, 'acceleration')
    def acceleration(self):
        # type: () -> List[Vector]
        do, final_do, outTypes = _f.getDoArgs([], [('array', 'MVectorArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'acceleration', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnParticleSystem, 'age')
    def age(self, ages):
        # type: (List[float]) -> None
        do, final_do, outTypes = _f.getDoArgs([ages], [('ages', 'MDoubleArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'age', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'betterIllum')
    def betterIllum(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'betterIllum')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'castsShadows')
    def castsShadows(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'castsShadows')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'deformedParticleShape')
    def deformedParticleShape(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'deformedParticleShape')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'disableCloudAxis')
    def disableCloudAxis(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'disableCloudAxis')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'emission')
    def emission(self, emissions):
        # type: (List[Vector]) -> None
        do, final_do, outTypes = _f.getDoArgs([emissions], [('emissions', 'MVectorArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'emission', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'emit')
    def emit(self, v):
        # type: (Point) -> None
        do, final_do, outTypes = _f.getDoArgs([v], [('v', 'MPoint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'emit', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'evaluateDynamics')
    def evaluateDynamics(self, to, runupFromStart):
        # type: (Time, bool) -> None
        do, final_do, outTypes = _f.getDoArgs([to, runupFromStart], [('to', 'MTime', 'in', None), ('runupFromStart', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'evaluateDynamics', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'flatShaded')
    def flatShaded(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'flatShaded')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addMelDocs('particle', 'floatValue')
    def floatValue(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'floatValue', val)

    @_f.addMelDocs('particle', 'attribute')
    def getAttribute(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'attribute')
        return res

    @_f.addMelDocs('particle', 'cache')
    def getCache(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'cache')
        return res

    @_f.addMelDocs('particle', 'conserve')
    def getConserve(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'conserve')
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'count')
    def getCount(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'count')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('particle', 'dynamicAttrList')
    def getDynamicAttrList(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'dynamicAttrList')
        return res

    @_f.addMelDocs('particle', 'gridSpacing')
    def getGridSpacing(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'gridSpacing')
        return res

    @_f.addMelDocs('particle', 'inherit')
    def getInherit(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'inherit')
        return res

    @_f.addMelDocs('particle', 'jitterBasePoint')
    def getJitterBasePoint(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'jitterBasePoint')
        return res

    @_f.addMelDocs('particle', 'jitterRadius')
    def getJitterRadius(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'jitterRadius')
        return res

    @_f.addMelDocs('particle', 'lowerLeft')
    def getLowerLeft(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'lowerLeft')
        return res

    @_f.addMelDocs('particle', 'numJitters')
    def getNumJitters(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'numJitters')
        return res

    @_f.addMelDocs('particle', 'order')
    def getOrder(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'order')
        return res

    @_f.addMelDocs('particle', 'particleId')
    def getParticleId(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'particleId')
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'getPerParticleAttribute')
    def getPerParticleAttribute(self, attrName):
        # type: (unicode) -> Tuple[int, List[int]]
        do, final_do, outTypes = _f.getDoArgs([attrName], [('attrName', 'MString', 'in', None), ('array', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'getPerParticleAttribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('particle', 'perParticleDouble')
    def getPerParticleDouble(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'perParticleDouble')
        return res

    @_f.addMelDocs('particle', 'perParticleVector')
    def getPerParticleVector(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'perParticleVector')
        return res

    @_f.addMelDocs('particle', 'shapeName')
    def getShapeName(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'shapeName')
        return res

    @_f.addMelDocs('particle', 'upperRight')
    def getUpperRight(self, **kwargs):
        res = _f.asQuery(self, effects.particle, kwargs, 'upperRight')
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'hasEmission')
    def hasEmission(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'hasEmission')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'hasLifespan')
    def hasLifespan(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'hasLifespan')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'hasOpacity')
    def hasOpacity(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'hasOpacity')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'hasRgb')
    def hasRgb(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'hasRgb')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'isDeformedParticleShape')
    def isDeformedParticleShape(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'isDeformedParticleShape')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'isPerParticleDoubleAttribute')
    def isPerParticleDoubleAttribute(self, attrName):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([attrName], [('attrName', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'isPerParticleDoubleAttribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'isPerParticleIntAttribute')
    def isPerParticleIntAttribute(self, attrName):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([attrName], [('attrName', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'isPerParticleIntAttribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'isPerParticleVectorAttribute')
    def isPerParticleVectorAttribute(self, attrName):
        # type: (unicode) -> bool
        do, final_do, outTypes = _f.getDoArgs([attrName], [('attrName', 'MString', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'isPerParticleVectorAttribute', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'isValid')
    def isValid(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'isValid')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'lifespan')
    def lifespan(self, lifespans):
        # type: (List[float]) -> None
        do, final_do, outTypes = _f.getDoArgs([lifespans], [('lifespans', 'MDoubleArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'lifespan', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'mass')
    def mass(self):
        # type: () -> List[float]
        do, final_do, outTypes = _f.getDoArgs([], [('array', 'MDoubleArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'mass', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnParticleSystem, 'opacity')
    def opacity(self, opacities):
        # type: (List[float]) -> None
        do, final_do, outTypes = _f.getDoArgs([opacities], [('opacities', 'MDoubleArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'opacity', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'originalParticleShape')
    def originalParticleShape(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'originalParticleShape')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'particleIds')
    def particleIds(self):
        # type: () -> List[int]
        do, final_do, outTypes = _f.getDoArgs([], [('ids', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'particleIds', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnParticleSystem, 'particleName')
    def particleName(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'particleName')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'position')
    def position(self, positions):
        # type: (List[Vector]) -> None
        do, final_do, outTypes = _f.getDoArgs([positions], [('positions', 'MVectorArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'position', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'position0')
    def position0(self, positions):
        # type: (List[Vector]) -> None
        do, final_do, outTypes = _f.getDoArgs([positions], [('positions', 'MVectorArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'position0', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'position1')
    def position1(self, positions):
        # type: (List[Vector]) -> None
        do, final_do, outTypes = _f.getDoArgs([positions], [('positions', 'MVectorArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'position1', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'primaryVisibility')
    def primaryVisibility(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'primaryVisibility')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'radius')
    def radius(self, radii):
        # type: (List[float]) -> None
        do, final_do, outTypes = _f.getDoArgs([radii], [('radii', 'MDoubleArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'radius', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'radius0')
    def radius0(self, radii):
        # type: (List[float]) -> None
        do, final_do, outTypes = _f.getDoArgs([radii], [('radii', 'MDoubleArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'radius0', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'radius1')
    def radius1(self, radii):
        # type: (List[float]) -> None
        do, final_do, outTypes = _f.getDoArgs([radii], [('radii', 'MDoubleArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'radius1', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'receiveShadows')
    def receiveShadows(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'receiveShadows')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'renderType')
    def renderType(self):
        # type: () -> ParticleSystem.RenderType
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'renderType')
        return _f.ApiArgUtil._castResult(self, res, ('MFnParticleSystem', 'RenderType'), None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'rgb')
    def rgb(self, colors):
        # type: (List[Vector]) -> None
        do, final_do, outTypes = _f.getDoArgs([colors], [('colors', 'MVectorArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'rgb', final_do)
        return res

    @_f.addApiDocs(_api.MFnParticleSystem, 'saveInitialState')
    def saveInitialState(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'saveInitialState')
        return res

    @_f.addMelDocs('particle', 'attribute')
    def setAttribute(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'attribute', val)

    @_f.addMelDocs('particle', 'cache')
    def setCache(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'cache', val)

    @_f.addMelDocs('particle', 'conserve')
    def setConserve(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'conserve', val)

    @_f.addApiDocs(_api.MFnParticleSystem, 'setCount')
    def setCount(self, count):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([count], [('count', 'uint', 'in', None)], self.getCount, self.setCount, [])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'setCount', final_do)
        return res

    @_f.addMelDocs('particle', 'inherit')
    def setInherit(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'inherit', val)

    @_f.addMelDocs('particle', 'order')
    def setOrder(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'order', val)

    @_f.addMelDocs('particle', 'particleId')
    def setParticleId(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'particleId', val)

    @_f.addApiDocs(_api.MFnParticleSystem, 'setPerParticleAttribute')
    def setPerParticleAttribute(self, attrName, array):
        # type: (unicode, List[Vector]) -> None
        do, final_do, outTypes = _f.processApiArgs([attrName, array], [('attrName', 'MString', 'in', None), ('array', 'MVectorArray', 'in', None)], self.getPerParticleAttribute, self.setPerParticleAttribute, ['attrName'])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'setPerParticleAttribute', final_do)
        return res

    @_f.addMelDocs('particle', 'shapeName')
    def setShapeName(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'shapeName', val)

    @_f.addApiDocs(_api.MFnParticleSystem, 'surfaceShading')
    def surfaceShading(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'surfaceShading')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'tailSize')
    def tailSize(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'tailSize')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'threshold')
    def threshold(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'threshold')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('particle', 'vectorValue')
    def vectorValue(self, val=True, **kwargs):
        return _f.asEdit(self, effects.particle, kwargs, 'vectorValue', val)

    @_f.addApiDocs(_api.MFnParticleSystem, 'velocity')
    def velocity(self):
        # type: () -> List[Vector]
        do, final_do, outTypes = _f.getDoArgs([], [('array', 'MVectorArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'velocity', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnParticleSystem, 'visibleInReflections')
    def visibleInReflections(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'visibleInReflections')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnParticleSystem, 'visibleInRefractions')
    def visibleInRefractions(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnParticleSystem, 'visibleInRefractions')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)
# ------ Do not edit above this line --------


class SelectionSet(_api.MSelectionList):
    apicls = _api.MSelectionList

    def __init__(self, objs):
        """ can be initialized from a list of objects, another SelectionSet, an MSelectionList, or an ObjectSet"""
        if isinstance(objs, _api.MSelectionList):
            _api.MSelectionList.__init__(self, objs)

        elif isinstance(objs, ObjectSet):
            _api.MSelectionList.__init__(self, objs.asSelectionSet())

        else:
            _api.MSelectionList.__init__(self)
            for obj in objs:
                if isinstance(obj, (DependNode, DagNode)):
                    self.apicls.add(self, obj.__apiobject__())
                elif isinstance(obj, general.Attribute):
                    self.apicls.add(self, obj.__apiobject__(), True)
    #            elif isinstance(obj, Component):
    #                sel.add( obj.__apiobject__(), True )
                elif isinstance(obj, basestring):
                    self.apicls.add(self, obj)
                else:
                    raise TypeError

    def __melobject__(self):
        # If the list contains components, THEIR __melobject__ is a list -
        # so need to iterate through, and flatten if needed
        melList = []
        for selItem in self:
            selItem = selItem.__melobject__()
            if _util.isIterable(selItem):
                melList.extend(selItem)
            else:
                melList.append(selItem)
        return melList

    def __len__(self):
        # type: () -> int
        """
        Returns
        -------
        int
        """
        return self.apicls.length(self)

    def __contains__(self, item):
        # type: (Any) -> bool
        """
        Returns
        -------
        bool
        """
        if isinstance(item, (DependNode, DagNode, general.Attribute)):
            return self.apicls.hasItem(self, item.__apiobject__())
        elif isinstance(item, general.Component):
            raise NotImplementedError, 'Components not yet supported'
        else:
            return self.apicls.hasItem(self, general.PyNode(item).__apiobject__())

    def __repr__(self):
        # type: () -> str
        """
        Returns
        -------
        str
        """
        names = []
        self.apicls.getSelectionStrings(self, names)
        return 'nt.%s(%s)' % (self.__class__.__name__, names)

    def __getitem__(self, index):
        # type: (Any) -> general.PyNode
        """
        Returns
        -------
        general.PyNode
        """
        if index >= len(self):
            raise IndexError, "index out of range"

        plug = _api.MPlug()
        obj = _api.MObject()
        dag = _api.MDagPath()
        comp = _api.MObject()

        # Go from most specific to least - plug, dagPath, dependNode
        try:
            self.apicls.getPlug(self, index, plug)
            assert not plug.isNull()
        except (RuntimeError, AssertionError):
            try:
                self.apicls.getDagPath(self, index, dag, comp)
            except RuntimeError:
                try:
                    self.apicls.getDependNode(self, index, obj)
                    return general.PyNode(obj)
                except:
                    pass
            else:
                if comp.isNull():
                    return general.PyNode(dag)
                else:
                    return general.PyNode(dag, comp)
        else:
            return general.PyNode(plug)

    def __setitem__(self, index, item):

        if isinstance(item, (DependNode, DagNode, general.Attribute)):
            return self.apicls.replace(self, index, item.__apiobject__())
        elif isinstance(item, general.Component):
            raise NotImplementedError, 'Components not yet supported'
        else:
            return self.apicls.replace(self, general.PyNode(item).__apiobject__())

    def __and__(self, s):
        "operator for `SelectionSet.getIntersection`"
        return self.getIntersection(s)

    def __iand__(self, s):
        "operator for `SelectionSet.intersection`"
        return self.intersection(s)

    def __or__(self, s):
        "operator for `SelectionSet.getUnion`"
        return self.getUnion(s)

    def __ior__(self, s):
        "operator for `SelectionSet.union`"
        return self.union(s)

    def __lt__(self, s):
        "operator for `SelectionSet.isSubSet`"
        return self.isSubSet(s)

    def __gt__(self, s):
        "operator for `SelectionSet.isSuperSet`"
        return self.isSuperSet(s)

    def __sub__(self, s):
        "operator for `SelectionSet.getDifference`"
        return self.getDifference(s)

    def __isub__(self, s):
        "operator for `SelectionSet.difference`"
        return self.difference(s)

    def __xor__(self, s):
        "operator for `SelectionSet.symmetricDifference`"
        return self.getSymmetricDifference(s)

    def __ixor__(self, s):
        "operator for `SelectionSet.symmetricDifference`"
        return self.symmetricDifference(s)

    def add(self, item):

        if isinstance(item, (DependNode, DagNode, general.Attribute)):
            return self.apicls.add(self, item.__apiobject__())
        elif isinstance(item, general.Component):
            raise NotImplementedError, 'Components not yet supported'
        else:
            return self.apicls.add(self, general.PyNode(item).__apiobject__())

    def pop(self, index):
        # type: (int) -> general.PyNode
        """
        Parameters
        ----------
        index : int

        Returns
        -------
        general.PyNode
        """
        if index >= len(self):
            raise IndexError, "index out of range"
        return self.apicls.remove(self, index)

    def isSubSet(self, other):
        # type: (Any) -> bool
        """
        Returns
        -------
        bool
        """
        if isinstance(other, ObjectSet):
            other = other.asSelectionSet()
        return set(self).issubset(other)

    def isSuperSet(self, other, flatten=True):
        # type: (Any, Any) -> bool
        """
        Returns
        -------
        bool
        """
        if isinstance(other, ObjectSet):
            other = other.asSelectionSet()
        return set(self).issuperset(other)

    def getIntersection(self, other):
        # type: (Any) -> SelectionSet
        """
        Returns
        -------
        SelectionSet
        """
        # diff = self-other
        # intersect = self-diff
        diff = self.getDifference(other)
        return self.getDifference(diff)

    def intersection(self, other):
        diff = self.getDifference(other)
        self.difference(diff)

    def getDifference(self, other):
        # type: (Any) -> SelectionSet
        """
        Returns
        -------
        SelectionSet
        """
        # create a new SelectionSet so that we don't modify our current one
        newSet = SelectionSet(self)
        newSet.difference(other)
        return newSet

    def difference(self, other):
        if not isinstance(other, _api.MSelectionList):
            other = SelectionSet(other)
        self.apicls.merge(self, other, _api.MSelectionList.kRemoveFromList)

    def getUnion(self, other):
        # type: (Any) -> SelectionSet
        """
        Returns
        -------
        SelectionSet
        """
        newSet = SelectionSet(self)
        newSet.union(other)
        return newSet

    def union(self, other):
        if not isinstance(other, _api.MSelectionList):
            other = SelectionSet(other)
        self.apicls.merge(self, other, _api.MSelectionList.kMergeNormal)

    def getSymmetricDifference(self, other):
        # type: (Any) -> SelectionSet
        """
        Also known as XOR

        Returns
        -------
        SelectionSet
        """
        # create a new SelectionSet so that we don't modify our current one
        newSet = SelectionSet(self)
        newSet.symmetricDifference(other)
        return newSet

    def symmetricDifference(self, other):
        if not isinstance(other, _api.MSelectionList):
            other = SelectionSet(other)
        # FIXME: does kXOR exist?  completion says only kXORWithList exists
        self.apicls.merge(self, other, _api.MSelectionList.kXOR)

    def asObjectSet(self):
        return general.sets(self)
#    def intersect(self, other):
#        self.apicls.merge( other, _api.MSelectionList.kXORWithList )


class ObjectSet(Entity):

    """
    The ObjectSet class and `SelectionSet` class work together.  Both classes have a very similar interface,
    the primary difference is that the ObjectSet class represents connections to an objectSet node, while the
    `SelectionSet` class is a generic set, akin to pythons built-in `set`.


    create some sets:

        >>> from pymel.core import *
        >>> f=newFile(f=1) #start clean
        >>>
        >>> s = sets()  # create an empty set
        >>> s.union( ls( type='camera') )  # add some cameras to it
        >>> s.members()  # doctest: +SKIP
        [nt.Camera(u'sideShape'), nt.Camera(u'frontShape'), nt.Camera(u'topShape'), nt.Camera(u'perspShape')]
        >>> sel = s.asSelectionSet() # or as a SelectionSet
        >>> sel # doctest: +SKIP
        nt.SelectionSet([u'sideShape', u'frontShape', u'topShape', u'perspShape'])
        >>> sorted(sel) # as a sorted list
        [nt.Camera(u'frontShape'), nt.Camera(u'perspShape'), nt.Camera(u'sideShape'), nt.Camera(u'topShape')]

    Operations between sets result in `SelectionSet` objects:

        >>> t = sets()  # create another set
        >>> t.add( 'perspShape' )  # add the persp camera shape to it
        >>> s.getIntersection(t)
        nt.SelectionSet([u'perspShape'])
        >>> diff = s.getDifference(t)
        >>> diff #doctest: +SKIP
        nt.SelectionSet([u'sideShape', u'frontShape', u'topShape'])
        >>> sorted(diff)
        [nt.Camera(u'frontShape'), nt.Camera(u'sideShape'), nt.Camera(u'topShape')]
        >>> s.isSuperSet(t)
        True



    """


#        >>> u = sets( s&t ) # intersection
#        >>> print u.elements(), s.elements()
#        >>> if u < s: print "%s is a sub-set of %s" % (u, s)
#
#    place a set inside another, take1
#
#        >>> # like python's built-in set, the add command expects a single element
#        >>> s.add( t )
#
#    place a set inside another, take2
#
#        >>> # like python's built-in set, the update command expects a set or a list
#        >>> t.update([u])
#
#        >>> # put the sets back where they were
#        >>> s.remove(t)
#        >>> t.remove(u)
#
#    now put the **contents** of a set into another set
#
#        >>> t.update(u)
#
#    mixed operation between pymel.core.ObjectSet and built-in set
#
#        >>> v = set(['polyCube3', 'pSphere3'])
#        >>> print s.intersection(v)
#        >>> print v.intersection(s)  # not supported yet
#        >>> u.clear()
#
#        >>> delete( s )
#        >>> delete( t )
#        >>> delete( u )
#
#
#    these will return the results of the operation as python sets containing lists of pymel node classes::
#
#        s&t     # s.intersection(t)
#        s|t     # s.union(t)
#        s^t     # s.symmetric_difference(t)
#        s-t     # s.difference(t)
#
#    the following will alter the contents of the maya set::
#
#        s&=t    # s.intersection_update(t)
#        s|=t    # s.update(t)
#        s^=t    # s.symmetric_difference_update(t)
#        s-=t    # s.difference_update(t)
#
#    def _elements(self):
#        """ used internally to get a list of elements without casting to node classes"""
#        return sets( self, q=True)
#    # ----------------------
#    # Maya Methods
#    # ----------------------

    # ----------------------
    # Python ObjectSet Methods
    # ----------------------

    @classmethod
    def _getApiObjs(cls, item, tryCast=True):
        """
        Returns a tuple of api objects suitable (after unpacking) for
        feeding to most of the MFnSet methods (ie, remove, isMember, etc)
        """
        if isinstance(item, DagNode):
            return (item.__apimdagpath__(), _api.MObject())
        elif isinstance(item, (DependNode, general.Attribute)):
            return (item.__apiobject__(), )
        elif isinstance(item, general.Component):
            return (item.__apimdagpath__(), item.__apimobject__())
        elif tryCast:
            return cls._getApiObjs(general.PyNode(item), tryCast=False)
        else:
            raise TypeError(item)

    def __contains__(self, item):
        # type: (Any) -> bool
        """
        Returns
        -------
        bool
        """
        return self.__apimfn__().isMember(*self._getApiObjs(item))

    def __getitem__(self, index):
        return self.asSelectionSet()[index]

    def __len__(self):
        # type: () -> int
        """
        Returns
        -------
        int
        """
        return cmds.sets(self, q=1, size=1)

    # def __eq__(self, s):
    #    return s == self._elements()

    # def __ne__(self, s):
    #    return s != self._elements()

    def __and__(self, s):
        "operator for `ObjectSet.getIntersection`"
        return self.getIntersection(s)

    def __iand__(self, s):
        "operator for `ObjectSet.intersection`"
        return self.intersection(s)

    def __or__(self, s):
        "operator for `ObjectSet.getUnion`"
        return self.getUnion(s)

    def __ior__(self, s):
        "operator for `ObjectSet.union`"
        return self.union(s)

#    def __lt__(self, s):
#        "operator for `ObjectSet.isSubSet`"
#        return self.isSubSet(s)
#
#    def __gt__(self, s):
#        "operator for `ObjectSet.isSuperSet`"
#        return self.isSuperSet(s)

    def __sub__(self, s):
        "operator for `ObjectSet.getDifference`"
        return self.getDifference(s)

    def __isub__(self, s):
        "operator for `ObjectSet.difference`"
        return self.difference(s)

    def __xor__(self, s):
        "operator for `ObjectSet.symmetricDifference`"
        return self.getSymmetricDifference(s)

    def __ixor__(self, s):
        "operator for `ObjectSet.symmetricDifference`"
        return self.symmetricDifference(s)

#
#    def subtract(self, set2):
#        return sets( self, subtract=set2 )
#
#    def add(self, element):
#        return sets( self, add=[element] )
#
#    def clear(self):
#        return sets( self, clear=True )
#
#    def copy(self ):
#        return sets( self, copy=True )
#
#    def difference(self, elements):
#        if isinstance(elements,basestring):
#            elements = cmds.sets( elements, q=True)
#        return list(set(self.elements()).difference(elements))
#
#        '''
#        if isinstance(s, ObjectSet) or isinstance(s, str):
#            return sets( s, subtract=self )
#
#        s = sets( s )
#        res = sets( s, subtract=self )
#        cmds.delete(s)
#        return res'''
#
#    def difference_update(self, elements ):
#        return sets( self, remove=elements)
#
#    def discard( self, element ):
#        try:
#            return self.remove(element)
#        except TypeError:
#            pass
#
#    def intersection(self, elements):
#        if isinstance(elements,basestring):
#            elements = cmds.sets( elements, q=True)
#        return set(self.elements()).intersection(elements)
#
#    def intersection_update(self, elements):
#        self.clear()
#        sets( self, add=self.intersections(elements) )
#
#
#    def remove( self, element ):
#        return sets( self, remove=[element])
#
#    def symmetric_difference(self, elements):
#        if isinstance(elements,basestring):
#            elements = cmds.sets( elements, q=True)
#        return set(self.elements()).symmetric_difference(elements)
#
#    def union( self, elements ):
#        if isinstance(elements,basestring):
#            elements = cmds.sets( elements, q=True)
#        return set(self.elements()).union(elements)
#
#    def update( self, set2 ):
#        sets( self, forceElement=set2 )

    def forceElement(self, member):
        """
        Forces addition of the items to the set. If the items are in
        another set which is in the same partition as the given set,
        the items will be removed from the other set in order to keep the
        sets in the partition mutually exclusive with respect to membership."""
        cmds.sets(member, forceElement=self)

    def members(self, flatten=False):
        # type: (Any) -> List[general.PyNode]
        """
        return members as a list

        Returns
        -------
        List[general.PyNode]
        """
        return list(self.asSelectionSet(flatten))

    @_warnings.deprecated('Use ObjectSet.members instead', 'ObjectSet')
    def elements(self, flatten=False):
        # type: (Any) -> List[general.PyNode]
        """
        return members as a list

        Returns
        -------
        List[general.PyNode]
        """
        return list(self.asSelectionSet(flatten))

    def flattened(self):
        # type: () -> List[general.PyNode]
        """
        return a flattened list of members.

        equivalent to `ObjectSet.members(flatten=True)`

        Returns
        -------
        List[general.PyNode]
        """
        return self.members(flatten=True)

    def resetTo(self, newContents):
        """
        clear and set the members to the passed list/set
        """
        self.clear()
        self.addMembers(newContents)

    def add(self, item):
        return self.__apimfn__().addMember(*self._getApiObjs(item))

    def remove(self, item):
        try:
            return self.__apimfn__().removeMember(*self._getApiObjs(item))
        except RuntimeError:
            # Provide a more informative error if object is not in set
            if item not in self:
                try:
                    itemStr = repr(item)
                except Exception:
                    itemStr = 'item'
                raise ValueError("%s not in set %r" % (itemStr, self))
            else:
                raise

    def isSubSet(self, other):
        # type: (Union[str, ObjectSet]) -> bool
        """
        Parameters
        ----------
        other : Union[str, ObjectSet]

        Returns
        -------
        bool
        """
        return self.asSelectionSet().isSubSet(other)

    def isSuperSet(self, other):
        # type: (Union[str, ObjectSet]) -> bool
        """
        Parameters
        ----------
        other : Union[str, ObjectSet]

        Returns
        -------
        bool
        """
        return self.asSelectionSet().isSuperSet(other)

    def isEqual(self, other):
        # type: (Union[str, ObjectSet]) -> bool
        """
        do not use __eq__ to test equality of set contents. __eq__ will only tell you if
        the passed object is the same node, not if this set and the passed set
        have the same contents.

        Parameters
        ----------
        other : Union[str, ObjectSet]

        Returns
        -------
        bool
        """
        return self.asSelectionSet() == SelectionSet(other)

    def getDifference(self, other):
        # type: (Union[str, ObjectSet]) -> SelectionSet
        """
        Parameters
        ----------
        other : Union[str, ObjectSet]

        Returns
        -------
        SelectionSet
        """
        sel = self.asSelectionSet()
        sel.difference(other)
        return sel

    def difference(self, other):
        sel = self.getDifference(other)
        self.resetTo(sel)

    def getSymmetricDifference(self, other):
        # type: (Union[str, ObjectSet]) -> SelectionSet
        """
        also known as XOR

        Parameters
        ----------
        other : Union[str, ObjectSet]

        Returns
        -------
        SelectionSet
        """
        sel = self.getSymmetricDifference()
        sel.difference(other)
        return sel

    def symmetricDifference(self, other):
        sel = self.symmetricDifference(other)
        self.resetTo(sel)

    def getIntersection(self, other):
        # type: (Union[str, ObjectSet]) -> SelectionSet
        """
        Parameters
        ----------
        other : Union[str, ObjectSet]

        Returns
        -------
        SelectionSet
        """
        if isinstance(other, ObjectSet):
            return self._getIntersection(other)

        # elif isinstance(other, SelectionSet) or hasattr(other, '__iter__'):
        selSet = self.asSelectionSet()
        selSet.intersection(other)
        return selSet

        #raise TypeError, 'Cannot perform intersection with non-iterable type %s' % type(other)

    def intersection(self, other):
        sel = self.getIntersection(other)
        self.resetTo(sel)

    def getUnion(self, other):
        # type: (Union[str, ObjectSet]) -> SelectionSet
        """
        Parameters
        ----------
        other : Union[str, ObjectSet]

        Returns
        -------
        SelectionSet
        """
        if isinstance(other, ObjectSet):
            return self._getUnion(other)

        selSet = self.asSelectionSet()
        selSet.union(other)
        return selSet

    def union(self, other):
        self.addMembers(other)

    def isRenderable(self):
        '''Mimics cmds.sets(self, q=True, renderable=True).

        Alternatively you can use isinstance(someset, pm.nt.ShadingEngine)
        since shadingEngine is the only renderable set in maya now
        '''
        return bool(cmds.sets(self, q=True, r=True))
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnSet
    __melnode__ = u'objectSet'
    __slots__ = ()
    Restriction = Enum('Restriction', {'none': 0, 'kNone': 0, 'verticesOnly': 1, 'kVerticesOnly': 1, 'kEdgesOnly': 2, 'edgesOnly': 2, 'facetsOnly': 3, 'kFacetsOnly': 3, 'editPointsOnly': 4, 'kEditPointsOnly': 4, 'renderableOnly': 5, 'kRenderableOnly': 5}, multiKeys=True, defaultKeys={0: 'none', 1: 'verticesOnly', 2: 'edgesOnly', 3: 'facetsOnly', 4: 'editPointsOnly', 5: 'renderableOnly'})

    @_f.addApiDocs(_api.MFnSet, 'getIntersection')
    def _getIntersection(self, withSet):
        # type: (general.PyNode) -> SelectionSet
        do, final_do, outTypes = _f.getDoArgs([withSet], [('withSet', 'MObject', 'in', None), ('result', 'MSelectionList', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'getIntersection', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnSet, 'getUnion')
    def _getUnion(self, withSet):
        # type: (general.PyNode) -> SelectionSet
        do, final_do, outTypes = _f.getDoArgs([withSet], [('withSet', 'MObject', 'in', None), ('result', 'MSelectionList', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'getUnion', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.deprecated
    def addMember(self, obj):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([obj], [('obj', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'addMember', final_do)
        return res

    @_f.addApiDocs(_api.MFnSet, 'addMembers')
    def addMembers(self, list):
        # type: (SelectionSet) -> None
        do, final_do, outTypes = _f.getDoArgs([list], [('list', 'MSelectionList', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'addMembers', final_do)
        return res

    @_f.addApiDocs(_api.MFnSet, 'getMembers')
    def asSelectionSet(self, flatten=False):
        # type: (bool) -> SelectionSet
        do, final_do, outTypes = _f.getDoArgs([flatten], [('members', 'MSelectionList', 'out', None), ('flatten', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'getMembers', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnSet, 'clear')
    def clear(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnSet, 'clear')
        return res

    @_f.addApiDocs(_api.MFnSet, 'annotation')
    def getAnnotation(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnSet, 'annotation')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.addApiDocs(_api.MFnSet, 'hasRestrictions')
    def hasRestrictions(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnSet, 'hasRestrictions')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnSet, 'intersectsWith')
    def intersectsWith(self, otherSet):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([otherSet], [('otherSet', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'intersectsWith', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.deprecated
    def isMember(self, object):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([object], [('object', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'isMember', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.deprecated
    def removeMember(self, obj):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([obj], [('obj', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'removeMember', final_do)
        return res

    @_f.addApiDocs(_api.MFnSet, 'removeMembers')
    def removeMembers(self, list):
        # type: (SelectionSet) -> None
        do, final_do, outTypes = _f.getDoArgs([list], [('list', 'MSelectionList', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSet, 'removeMembers', final_do)
        return res

    @_f.addApiDocs(_api.MFnSet, 'restriction')
    def restriction(self):
        # type: () -> Set.Restriction
        res = _f.getProxyResult(self, _api.MFnSet, 'restriction')
        return _f.ApiArgUtil._castResult(self, res, ('MFnSet', 'Restriction'), None)

    @_f.addApiDocs(_api.MFnSet, 'setAnnotation')
    def setAnnotation(self, annotation):
        # type: (unicode) -> None
        do, final_do, outTypes = _f.processApiArgs([annotation], [('annotation', 'MString', 'in', None)], self.getAnnotation, self.setAnnotation, [])
        res = _f.getProxyResult(self, _api.MFnSet, 'setAnnotation', final_do)
        return res
# ------ Do not edit above this line --------


class ShadingEngine(ObjectSet):

    @classmethod
    def _getApiObjs(cls, item, tryCast=True):
        # Since shading groups can't contain transforms, as a convenience,
        # use getShape on any transforms
        if isinstance(item, Transform):
            shape = item.getShape()
            if shape:
                return cls._getApiObjs(shape)
            else:
                try:
                    itemStr = repr(item)
                except Exception:
                    itemStr = 'item'
                raise TypeError("%s has no shape, and %s objects cannot contain Transforms" % (itemStr, cls.__name__))
        else:
            return super(ShadingEngine, cls)._getApiObjs(item, tryCast=tryCast)
# ------ Do not edit below this line --------
    __melnode__ = u'shadingEngine'
    __slots__ = ()
# ------ Do not edit above this line --------


class AnimLayer(ObjectSet):

    def getAttribute(self):
        '''
        Retrieve the attributes animated on this AnimLayer
        '''
        # Unfortunately, cmds.animLayer('MyAnimLayer', q=1, attribute=1)
        # returns none unique attribute names, ie,
        #   MyNode.myAttr
        # even if there are foo|MyNode and bar|MyNode in the scene, and there
        # doesn't seem to be a flag to tell it to give unique / full paths.
        # Therefore, query it ourselves, by gettin inputs to dagSetMembers.
        # Testing has shown that animLayers only use dagSetMembers, and never
        # dnSetMembers - if you add a non-dag node to an animLayer, it makes
        # a connection to dagSetMembers; and even if you manually make a connection
        # to dnSetMembers, those connections don't seem to show up in
        # animLayer(q=1, attribute=1)
        return self.attr('dagSetMembers').inputs(plugs=1)

    getAttributes = getAttribute
# ------ Do not edit below this line --------
    __melcmd__ = staticmethod(animation.animLayer)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'animLayer'
    __melnode__ = u'animLayer'
    __slots__ = ()

    @_f.addMelDocs('animLayer', 'copy')
    def copy(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'copy', val)

    @_f.addMelDocs('animLayer', 'copyAnimation')
    def copyAnimation(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'copyAnimation', val)

    @_f.addMelDocs('animLayer', 'copyNoAnimation')
    def copyNoAnimation(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'copyNoAnimation', val)

    @_f.addMelDocs('animLayer', 'extractAnimation')
    def extractAnimation(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'extractAnimation', val)

    @_f.addMelDocs('animLayer', 'addRelatedKG')
    def getAddRelatedKG(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'addRelatedKG')
        return res

    @_f.addMelDocs('animLayer', 'addSelectedObjects')
    def getAddSelectedObjects(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'addSelectedObjects')
        return res

    @_f.addMelDocs('animLayer', 'affectedLayers')
    def getAffectedLayers(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'affectedLayers')
        return res

    @_f.addMelDocs('animLayer', 'animCurves')
    def getAnimCurves(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'animCurves')
        return res

    @_f.addMelDocs('animLayer', 'baseAnimCurves')
    def getBaseAnimCurves(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'baseAnimCurves')
        return res

    @_f.addMelDocs('animLayer', 'bestAnimLayer')
    def getBestAnimLayer(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'bestAnimLayer')
        return res

    @_f.addMelDocs('animLayer', 'bestLayer')
    def getBestLayer(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'bestLayer')
        return res

    @_f.addMelDocs('animLayer', 'blendNodes')
    def getBlendNodes(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'blendNodes')
        return res

    @_f.addMelDocs('animLayer', 'children')
    def getChildren(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'children')
        return res

    @_f.addMelDocs('animLayer', 'collapse')
    def getCollapse(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'collapse')
        return res

    @_f.addMelDocs('animLayer', 'excludeBoolean')
    def getExcludeBoolean(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'excludeBoolean')
        return res

    @_f.addMelDocs('animLayer', 'excludeDynamic')
    def getExcludeDynamic(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'excludeDynamic')
        return res

    @_f.addMelDocs('animLayer', 'excludeEnum')
    def getExcludeEnum(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'excludeEnum')
        return res

    @_f.addMelDocs('animLayer', 'excludeRotate')
    def getExcludeRotate(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'excludeRotate')
        return res

    @_f.addMelDocs('animLayer', 'excludeScale')
    def getExcludeScale(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'excludeScale')
        return res

    @_f.addMelDocs('animLayer', 'excludeTranslate')
    def getExcludeTranslate(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'excludeTranslate')
        return res

    @_f.addMelDocs('animLayer', 'excludeVisibility')
    def getExcludeVisibility(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'excludeVisibility')
        return res

    @_f.addMelDocs('animLayer', 'exists')
    def getExists(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'exists')
        return res

    @_f.addMelDocs('animLayer', 'findCurveForPlug')
    def getFindCurveForPlug(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'findCurveForPlug')
        return res

    @_f.addMelDocs('animLayer', 'layeredPlug')
    def getLayeredPlug(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'layeredPlug')
        return res

    @_f.addMelDocs('animLayer', 'lock')
    def getLock(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'lock')
        return res

    @_f.addMelDocs('animLayer', 'maxLayers')
    def getMaxLayers(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'maxLayers')
        return res

    @_f.addMelDocs('animLayer', 'mute')
    def getMute(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'mute')
        return res

    @_f.addMelDocs('animLayer', 'override')
    def getOverride(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'override')
        return res

    @_f.addMelDocs('animLayer', 'parent')
    def getParent(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'parent')
        return res

    @_f.addMelDocs('animLayer', 'passthrough')
    def getPassthrough(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'passthrough')
        return res

    @_f.addMelDocs('animLayer', 'preferred')
    def getPreferred(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'preferred')
        return res

    @_f.addMelDocs('animLayer', 'root')
    def getRoot(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'root')
        return res

    @_f.addMelDocs('animLayer', 'selected')
    def getSelected(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'selected')
        return res

    @_f.addMelDocs('animLayer', 'solo')
    def getSolo(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'solo')
        return res

    @_f.addMelDocs('animLayer', 'weight')
    def getWeight(self, **kwargs):
        res = _f.asQuery(self, animation.animLayer, kwargs, 'weight')
        return res

    @_f.addMelDocs('animLayer', 'moveLayerAfter')
    def moveLayerAfter(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'moveLayerAfter', val)

    @_f.addMelDocs('animLayer', 'moveLayerBefore')
    def moveLayerBefore(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'moveLayerBefore', val)

    @_f.addMelDocs('animLayer', 'removeAllAttributes')
    def removeAllAttributes(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'removeAllAttributes', val)

    @_f.addMelDocs('animLayer', 'addRelatedKG')
    def setAddRelatedKG(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'addRelatedKG', val)

    @_f.addMelDocs('animLayer', 'addSelectedObjects')
    def setAddSelectedObjects(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'addSelectedObjects', val)

    @_f.addMelDocs('animLayer', 'animCurves')
    def setAnimCurves(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'animCurves', val)

    @_f.addMelDocs('animLayer', 'attribute')
    def setAttribute(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'attribute', val)

    @_f.addMelDocs('animLayer', 'baseAnimCurves')
    def setBaseAnimCurves(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'baseAnimCurves', val)

    @_f.addMelDocs('animLayer', 'bestAnimLayer')
    def setBestAnimLayer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'bestAnimLayer', val)

    @_f.addMelDocs('animLayer', 'blendNodes')
    def setBlendNodes(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'blendNodes', val)

    @_f.addMelDocs('animLayer', 'collapse')
    def setCollapse(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'collapse', val)

    @_f.addMelDocs('animLayer', 'excludeBoolean')
    def setExcludeBoolean(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'excludeBoolean', val)

    @_f.addMelDocs('animLayer', 'excludeDynamic')
    def setExcludeDynamic(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'excludeDynamic', val)

    @_f.addMelDocs('animLayer', 'excludeEnum')
    def setExcludeEnum(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'excludeEnum', val)

    @_f.addMelDocs('animLayer', 'excludeRotate')
    def setExcludeRotate(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'excludeRotate', val)

    @_f.addMelDocs('animLayer', 'excludeScale')
    def setExcludeScale(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'excludeScale', val)

    @_f.addMelDocs('animLayer', 'excludeTranslate')
    def setExcludeTranslate(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'excludeTranslate', val)

    @_f.addMelDocs('animLayer', 'excludeVisibility')
    def setExcludeVisibility(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'excludeVisibility', val)

    @_f.addMelDocs('animLayer', 'findCurveForPlug')
    def setFindCurveForPlug(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'findCurveForPlug', val)

    @_f.addMelDocs('animLayer', 'lock')
    def setLock(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'lock', val)

    @_f.addMelDocs('animLayer', 'mute')
    def setMute(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'mute', val)

    @_f.addMelDocs('animLayer', 'override')
    def setOverride(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'override', val)

    @_f.addMelDocs('animLayer', 'parent')
    def setParent(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'parent', val)

    @_f.addMelDocs('animLayer', 'passthrough')
    def setPassthrough(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'passthrough', val)

    @_f.addMelDocs('animLayer', 'preferred')
    def setPreferred(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'preferred', val)

    @_f.addMelDocs('animLayer', 'selected')
    def setSelected(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'selected', val)

    @_f.addMelDocs('animLayer', 'solo')
    def setSolo(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'solo', val)

    @_f.addMelDocs('animLayer', 'weight')
    def setWeight(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'weight', val)

    @_f.addMelDocs('animLayer', 'writeBlendnodeDestinations')
    def writeBlendnodeDestinations(self, val=True, **kwargs):
        return _f.asEdit(self, animation.animLayer, kwargs, 'writeBlendnodeDestinations', val)
# ------ Do not edit above this line --------


class AnimCurve(DependNode):

    def addKeys(self, time, values, tangentInType='linear',
                tangentOutType='linear', unit=None):
        if not unit:
            unit = _api.MTime.uiUnit()
        times = _api.MTimeArray()
        for frame in time:
            times.append(_api.MTime(frame, unit))
        keys = _api.MDoubleArray()
        for value in values:
            keys.append(value)
        infoObj = _factories.apiClassInfo['MFnAnimCurve']['enums']['TangentType']['values']
        return self.__apimfn__().addKeys(times, keys,
                                         infoObj.getIndex('kTangent' + tangentInType.capitalize()),
                                         infoObj.getIndex('kTangent' + tangentOutType.capitalize()))

    def numKeyframes(self):
        # just because MFnAnimCurve.numKeyframes is deprecated...
        return self.numKeys()
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnAnimCurve
    __melnode__ = u'animCurve'
    __slots__ = ()
    AnimCurveType = Enum('AnimCurveType', {'kAnimCurveTA': 0, 'TA': 0, 'TL': 1, 'kAnimCurveTL': 1, 'kAnimCurveTT': 2, 'TT': 2, 'kAnimCurveTU': 3, 'TU': 3, 'kAnimCurveUA': 4, 'UA': 4, 'UL': 5, 'kAnimCurveUL': 5, 'UT': 6, 'kAnimCurveUT': 6, 'UU': 7, 'kAnimCurveUU': 7, 'kAnimCurveUnknown': 8, 'unknown': 8}, multiKeys=True, defaultKeys={0: 'TA', 1: 'TL', 2: 'TT', 3: 'TU', 4: 'UA', 5: 'UL', 6: 'UT', 7: 'UU', 8: 'unknown'})
    InfinityType = Enum('InfinityType', {'constant': 0, 'kConstant': 0, 'linear': 1, 'kLinear': 1, 'kCycle': 3, 'cycle': 3, 'kCycleRelative': 4, 'cycleRelative': 4, 'oscillate': 5, 'kOscillate': 5}, multiKeys=True, defaultKeys={0: 'constant', 1: 'linear', 3: 'cycle', 4: 'cycleRelative', 5: 'oscillate'})
    if versions.current() >= versions.v2019:
        TangentType = Enum('TangentType', {'kTangentGlobal': 0, 'global_': 0, 'kTangentFixed': 1, 'fixed': 1, 'linear': 2, 'kTangentLinear': 2, 'kTangentFlat': 3, 'flat': 3, 'smooth': 4, 'kTangentSmooth': 4, 'kTangentStep': 5, 'step': 5, 'slow': 6, 'kTangentSlow': 6, 'kTangentFast': 7, 'fast': 7, 'clamped': 8, 'kTangentClamped': 8, 'plateau': 9, 'kTangentPlateau': 9, 'stepNext': 10, 'kTangentStepNext': 10, 'kTangentAuto': 11, 'auto': 11, 'kTangentShared1': 19, 'shared1': 19, 'kTangentShared2': 20, 'shared2': 20, 'shared3': 21, 'kTangentShared3': 21, 'kTangentShared4': 22, 'shared4': 22, 'kTangentShared5': 23, 'shared5': 23, 'kTangentShared6': 24, 'shared6': 24, 'kTangentShared7': 25, 'shared7': 25, 'kTangentShared8': 26, 'shared8': 26, 'customStart': 64, 'kTangentCustomStart': 64, 'customEnd': 32767, 'kTangentCustomEnd': 32767, 'typeCount': 32768, 'kTangentTypeCount': 32768}, multiKeys=True, defaultKeys={32768: 'typeCount', 1: 'fixed', 2: 'linear', 3: 'flat', 4: 'smooth', 5: 'step', 6: 'slow', 7: 'fast', 8: 'clamped', 9: 'plateau', 10: 'stepNext', 11: 'auto', 19: 'shared1', 20: 'shared2', 21: 'shared3', 22: 'shared4', 23: 'shared5', 24: 'shared6', 25: 'shared7', 26: 'shared8', 0: 'global_', 64: 'customStart', 32767: 'customEnd'})
    else:
        TangentType = Enum('TangentType', {'kTangentGlobal': 0, 'global_': 0, 'kTangentFixed': 1, 'fixed': 1, 'linear': 2, 'kTangentLinear': 2, 'kTangentFlat': 3, 'flat': 3, 'smooth': 4, 'kTangentSmooth': 4, 'kTangentStep': 5, 'step': 5, 'slow': 6, 'kTangentSlow': 6, 'kTangentFast': 7, 'fast': 7, 'clamped': 8, 'kTangentClamped': 8, 'plateau': 9, 'kTangentPlateau': 9, 'stepNext': 10, 'kTangentStepNext': 10, 'kTangentAuto': 11, 'auto': 11}, multiKeys=True, defaultKeys={0: 'global_', 1: 'fixed', 2: 'linear', 3: 'flat', 4: 'smooth', 5: 'step', 6: 'slow', 7: 'fast', 8: 'clamped', 9: 'plateau', 10: 'stepNext', 11: 'auto'})

    @_f.deprecated
    def addKey(self, time, value, tangentInType='global_', tangentOutType='global_', change=None):
        # type: (Time, float, AnimCurve.TangentType, AnimCurve.TangentType, datatypes.AnimCurveChange) -> int
        do, final_do, outTypes = _f.getDoArgs([time, value, tangentInType, tangentOutType, change], [('time', 'MTime', 'in', None), ('value', 'double', 'in', None), ('tangentInType', ('MFnAnimCurve', 'TangentType'), 'in', None), ('tangentOutType', ('MFnAnimCurve', 'TangentType'), 'in', None), ('change', 'MAnimCurveChange', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'addKey', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.deprecated
    def addKeyframe(self, time, value, change=None):
        # type: (Time, float, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.getDoArgs([time, value, change], [('time', 'MTime', 'in', None), ('value', 'double', 'in', None), ('change', 'MAnimCurveChange', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'addKeyframe', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'animCurveType')
    def animCurveType(self):
        # type: () -> AnimCurve.AnimCurveType
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'animCurveType')
        return _f.ApiArgUtil._castResult(self, res, ('MFnAnimCurve', 'AnimCurveType'), None)

    @_f.deprecated
    def evaluate(self, atTime):
        # type: (Time) -> float
        do, final_do, outTypes = _f.getDoArgs([atTime], [('atTime', 'MTime', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'evaluate', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.deprecated
    def findClosest(self, time):
        # type: (Time) -> int
        do, final_do, outTypes = _f.getDoArgs([time], [('time', 'MTime', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'findClosest', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'inTangentType')
    def getInTangentType(self, index):
        # type: (int) -> AnimCurve.TangentType
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'inTangentType', final_do)
        res = _f.ApiArgUtil._castResult(self, res, ('MFnAnimCurve', 'TangentType'), None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'outTangentType')
    def getOutTangentType(self, index):
        # type: (int) -> AnimCurve.TangentType
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'outTangentType', final_do)
        res = _f.ApiArgUtil._castResult(self, res, ('MFnAnimCurve', 'TangentType'), None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'postInfinityType')
    def getPostInfinityType(self):
        # type: () -> AnimCurve.InfinityType
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'postInfinityType')
        return _f.ApiArgUtil._castResult(self, res, ('MFnAnimCurve', 'InfinityType'), None)

    @_f.addApiDocs(_api.MFnAnimCurve, 'preInfinityType')
    def getPreInfinityType(self):
        # type: () -> AnimCurve.InfinityType
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'preInfinityType')
        return _f.ApiArgUtil._castResult(self, res, ('MFnAnimCurve', 'InfinityType'), None)

    @_f.addApiDocs(_api.MFnAnimCurve, 'tangentsLocked')
    def getTangentsLocked(self, index):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'tangentsLocked', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'time')
    def getTime(self, index):
        # type: (int) -> Time
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'time', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MTime', None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'unitlessInput')
    def getUnitlessInput(self, index):
        # type: (int) -> float
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'unitlessInput', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'value')
    def getValue(self, index):
        # type: (int) -> float
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'value', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'weightsLocked')
    def getWeightsLocked(self, index):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'weightsLocked', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'isBreakdown')
    def isBreakdown(self, index):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'isBreakdown', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'isStatic')
    def isStatic(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'isStatic')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnAnimCurve, 'isTimeInput')
    def isTimeInput(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'isTimeInput')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnAnimCurve, 'isUnitlessInput')
    def isUnitlessInput(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'isUnitlessInput')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnAnimCurve, 'isWeighted')
    def isWeighted(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'isWeighted')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnAnimCurve, 'numKeys')
    def numKeys(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'numKeys')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnAnimCurve, 'remove')
    def remove(self, index, change=None):
        # type: (int, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.getDoArgs([index, change], [('index', 'uint', 'in', None), ('change', 'MAnimCurveChange', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'remove', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setAngle')
    def setAngle(self, index, angle, inTangent, change=None):
        # type: (int, Angle, bool, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.getDoArgs([index, angle, inTangent, change], [('index', 'uint', 'in', None), ('angle', 'MAngle', 'in', None), ('inTangent', 'bool', 'in', None), ('change', 'MAnimCurveChange', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setAngle', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setIsBreakdown')
    def setBreakdown(self, index, isBreakdown, change=None):
        # type: (int, bool, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([index, isBreakdown, change], [('index', 'uint', 'in', None), ('isBreakdown', 'bool', 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.isBreakdown, self.setBreakdown, ['index'])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setIsBreakdown', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setInTangentType')
    def setInTangentType(self, index, tangentType, change=None):
        # type: (int, AnimCurve.TangentType, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([index, tangentType, change], [('index', 'uint', 'in', None), ('tangentType', ('MFnAnimCurve', 'TangentType'), 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getInTangentType, self.setInTangentType, ['index'])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setInTangentType', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setOutTangentType')
    def setOutTangentType(self, index, tangentType, change=None):
        # type: (int, AnimCurve.TangentType, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([index, tangentType, change], [('index', 'uint', 'in', None), ('tangentType', ('MFnAnimCurve', 'TangentType'), 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getOutTangentType, self.setOutTangentType, ['index'])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setOutTangentType', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setPostInfinityType')
    def setPostInfinityType(self, infinityType, change=None):
        # type: (AnimCurve.InfinityType, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([infinityType, change], [('infinityType', ('MFnAnimCurve', 'InfinityType'), 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getPostInfinityType, self.setPostInfinityType, [])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setPostInfinityType', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setPreInfinityType')
    def setPreInfinityType(self, infinityType, change=None):
        # type: (AnimCurve.InfinityType, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([infinityType, change], [('infinityType', ('MFnAnimCurve', 'InfinityType'), 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getPreInfinityType, self.setPreInfinityType, [])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setPreInfinityType', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setTangentTypes')
    def setTangentTypes(self, indexArray, inTangentType='global_', outTangentType='global_', change=None):
        # type: (List[int], AnimCurve.TangentType, AnimCurve.TangentType, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.getDoArgs([indexArray, inTangentType, outTangentType, change], [('indexArray', 'MIntArray', 'in', None), ('inTangentType', ('MFnAnimCurve', 'TangentType'), 'in', None), ('outTangentType', ('MFnAnimCurve', 'TangentType'), 'in', None), ('change', 'MAnimCurveChange', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setTangentTypes', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setTangentsLocked')
    def setTangentsLocked(self, index, locked, change=None):
        # type: (int, bool, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([index, locked, change], [('index', 'uint', 'in', None), ('locked', 'bool', 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getTangentsLocked, self.setTangentsLocked, ['index'])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setTangentsLocked', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setTime')
    def setTime(self, index, time, change=None):
        # type: (int, Time, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([index, time, change], [('index', 'uint', 'in', None), ('time', 'MTime', 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getTime, self.setTime, ['index'])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setTime', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setUnitlessInput')
    def setUnitlessInput(self, index, unitlessInput, change=None):
        # type: (int, float, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([index, unitlessInput, change], [('index', 'uint', 'in', None), ('unitlessInput', 'double', 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getUnitlessInput, self.setUnitlessInput, ['index'])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setUnitlessInput', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setValue')
    def setValue(self, index, value, change=None):
        # type: (int, float, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([index, value, change], [('index', 'uint', 'in', None), ('value', 'double', 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getValue, self.setValue, ['index'])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setValue', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setWeight')
    def setWeight(self, index, weight, inTangent, change=None):
        # type: (int, float, bool, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.getDoArgs([index, weight, inTangent, change], [('index', 'uint', 'in', None), ('weight', 'double', 'in', None), ('inTangent', 'bool', 'in', None), ('change', 'MAnimCurveChange', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setWeight', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setIsWeighted')
    def setWeighted(self, isWeighted, change=None):
        # type: (bool, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([isWeighted, change], [('isWeighted', 'bool', 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.isWeighted, self.setWeighted, [])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setIsWeighted', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnimCurve, 'setWeightsLocked')
    def setWeightsLocked(self, index, locked, change=None):
        # type: (int, bool, datatypes.AnimCurveChange) -> None
        do, final_do, outTypes = _f.processApiArgs([index, locked, change], [('index', 'uint', 'in', None), ('locked', 'bool', 'in', None), ('change', 'MAnimCurveChange', 'in', None)], self.getWeightsLocked, self.setWeightsLocked, ['index'])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'setWeightsLocked', final_do)
        return res

    @_f.deprecated
    def timedAnimCurveTypeForPlug(self, plug):
        # type: (Attribute) -> AnimCurve.AnimCurveType
        do, final_do, outTypes = _f.getDoArgs([plug], [('plug', 'MPlug', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'timedAnimCurveTypeForPlug', final_do)
        res = _f.ApiArgUtil._castResult(self, res, ('MFnAnimCurve', 'AnimCurveType'), None)
        return res

    @_f.deprecated
    def unitlessAnimCurveTypeForPlug(self, plug):
        # type: (Attribute) -> AnimCurve.AnimCurveType
        do, final_do, outTypes = _f.getDoArgs([plug], [('plug', 'MPlug', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnAnimCurve, 'unitlessAnimCurveTypeForPlug', final_do)
        res = _f.ApiArgUtil._castResult(self, res, ('MFnAnimCurve', 'AnimCurveType'), None)
        return res
# ------ Do not edit above this line --------


class GeometryFilter(DependNode):
    pass
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnGeometryFilter
    __melnode__ = u'geometryFilter'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnGeometryFilter, 'deformerSet')
    def deformerSet(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'deformerSet')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnGeometryFilter, 'envelope')
    def getEnvelope(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'envelope')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnGeometryFilter, 'getInputGeometry')
    def getInputGeometry(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('geomList', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'getInputGeometry', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnGeometryFilter, 'getOutputGeometry')
    def getOutputGeometry(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('geomList', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'getOutputGeometry', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnGeometryFilter, 'getPathAtIndex')
    def getPathAtIndex(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None), ('dagPath', 'MDagPath', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'getPathAtIndex', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnGeometryFilter, 'groupIdAtIndex')
    def groupIdAtIndex(self, index):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'groupIdAtIndex', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnGeometryFilter, 'indexForGroupId')
    def indexForGroupId(self, groupId):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([groupId], [('groupId', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'indexForGroupId', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnGeometryFilter, 'indexForOutputConnection')
    def indexForOutputConnection(self, connectionIndex):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([connectionIndex], [('connectionIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'indexForOutputConnection', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnGeometryFilter, 'indexForOutputShape')
    def indexForOutputShape(self, shape):
        # type: (general.PyNode) -> int
        do, final_do, outTypes = _f.getDoArgs([shape], [('shape', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'indexForOutputShape', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnGeometryFilter, 'inputShapeAtIndex')
    def inputShapeAtIndex(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'inputShapeAtIndex', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnGeometryFilter, 'numOutputConnections')
    def numOutputConnections(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'numOutputConnections')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnGeometryFilter, 'outputShapeAtIndex')
    def outputShapeAtIndex(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'outputShapeAtIndex', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnGeometryFilter, 'setEnvelope')
    def setEnvelope(self, envelope):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([envelope], [('envelope', 'float', 'in', None)], self.getEnvelope, self.setEnvelope, [])
        res = _f.getProxyResult(self, _api.MFnGeometryFilter, 'setEnvelope', final_do)
        return res
# ------ Do not edit above this line --------


class SkinCluster(GeometryFilter):

    def getWeights(self, geometry, influenceIndex=None):
        if not isinstance(geometry, general.PyNode):
            geometry = general.PyNode(geometry)

        if isinstance(geometry, Transform):
            try:
                geometry = geometry.getShape()
            except:
                raise TypeError, "%s is a transform with no shape" % geometry

        if isinstance(geometry, GeometryShape):
            components = _api.toComponentMObject(geometry.__apimdagpath__())
        elif isinstance(geometry, general.Component):
            components = geometry.__apiobject__()

        else:
            raise TypeError

        if influenceIndex is not None:
            weights = _api.MDoubleArray()
            self.__apimfn__().getWeights(geometry.__apimdagpath__(), components, influenceIndex, weights)
            return iter(weights)
        else:
            weights = _api.MDoubleArray()
            index = _api.SafeApiPtr('uint')
            self.__apimfn__().getWeights(geometry.__apimdagpath__(), components, weights, index())
            index = index.get()
            args = [iter(weights)] * index
            return itertools.izip(*args)

    def setWeights(self, geometry, influnces, weights, normalize=True):
        if not isinstance(geometry, general.PyNode):
            geometry = general.PyNode(geometry)

        if isinstance(geometry, Transform):
            try:
                geometry = geometry.getShape()
            except:
                raise TypeError, "%s is a transform with no shape" % geometry

        if isinstance(geometry, GeometryShape):
            components = _api.toComponentMObject(geometry.__apimdagpath__())
        elif isinstance(geometry, general.Component):
            components = geometry.__apiobject__()

        else:
            raise TypeError

        if not isinstance(influnces, _api.MIntArray):
            api_influnces = _api.MIntArray()
            for influnce in influnces:
                api_influnces.append(influnce)
            influnces = api_influnces

        if not isinstance(weights, _api.MDoubleArray):
            api_weights = _api.MDoubleArray()
            for weight in weights:
                api_weights.append(weight)
            weights = api_weights

        old_weights = _api.MDoubleArray()
        su = _api.MScriptUtil()
        su.createFromInt(0)
        index = su.asUintPtr()
        self.__apimfn__().getWeights(geometry.__apimdagpath__(), components, old_weights, index)
        return self.__apimfn__().setWeights(geometry.__apimdagpath__(), components, influnces, weights, normalize, old_weights)

    @_factories.addApiDocs(_api.MFnSkinCluster, 'influenceObjects')
    def influenceObjects(self):
        return self._influenceObjects()[1]

    def numInfluenceObjects(self):
        return self._influenceObjects()[0]
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnSkinCluster
    __melcmd__ = staticmethod(animation.skinCluster)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'skinCluster'
    __melnode__ = u'skinCluster'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnSkinCluster, 'influenceObjects')
    def _influenceObjects(self):
        # type: () -> Tuple[int, List[general.PyNode]]
        do, final_do, outTypes = _f.getDoArgs([], [(u'paths', 'MDagPathArray', u'out', None)])
        res = _f.getProxyResult(self, _api.MFnSkinCluster, 'influenceObjects', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('skinCluster', 'addInfluence')
    def addInfluence(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'addInfluence', val)

    @_f.addMelDocs('skinCluster', 'addToSelection')
    def addToSelection(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'addToSelection', val)

    @_f.addMelDocs('skinCluster', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'after', val)

    @_f.addMelDocs('skinCluster', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'afterReference', val)

    @_f.addMelDocs('skinCluster', 'baseShape')
    def baseShape(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'baseShape', val)

    @_f.addMelDocs('skinCluster', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'before', val)

    @_f.addMelDocs('skinCluster', 'forceNormalizeWeights')
    def forceNormalizeWeights(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'forceNormalizeWeights', val)

    @_f.addMelDocs('skinCluster', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('skinCluster', 'bindMethod')
    def getBindMethod(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'bindMethod')
        return res

    @_f.addApiDocs(_api.MFnSkinCluster, 'getBlendWeights')
    def getBlendWeights(self, path, components):
        # type: (general.PyNode, general.PyNode) -> List[float]
        do, final_do, outTypes = _f.getDoArgs([path, components], [('path', 'MDagPath', 'in', None), ('components', 'MObject', 'in', None), ('weights', 'MDoubleArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnSkinCluster, 'getBlendWeights', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('skinCluster', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('skinCluster', 'dropoffRate')
    def getDropoffRate(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'dropoffRate')
        return res

    @_f.addMelDocs('skinCluster', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('skinCluster', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'geometry')
        return res

    @_f.addMelDocs('skinCluster', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('skinCluster', 'ignoreHierarchy')
    def getIgnoreHierarchy(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'ignoreHierarchy')
        return res

    @_f.addMelDocs('skinCluster', 'influence')
    def getInfluence(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'influence')
        return res

    @_f.addMelDocs('skinCluster', 'lockWeights')
    def getLockWeights(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'lockWeights')
        return res

    @_f.addMelDocs('skinCluster', 'maximumInfluences')
    def getMaximumInfluences(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'maximumInfluences')
        return res

    @_f.addMelDocs('skinCluster', 'normalizeWeights')
    def getNormalizeWeights(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'normalizeWeights')
        return res

    @_f.addMelDocs('skinCluster', 'obeyMaxInfluences')
    def getObeyMaxInfluences(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'obeyMaxInfluences')
        return res

    @_f.addApiDocs(_api.MFnSkinCluster, 'getPointsAffectedByInfluence')
    def getPointsAffectedByInfluence(self, path):
        # type: (general.PyNode) -> Tuple[SelectionSet, List[float]]
        do, final_do, outTypes = _f.getDoArgs([path], [('path', 'MDagPath', 'in', None), ('result', 'MSelectionList', 'out', None), ('weights', 'MDoubleArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnSkinCluster, 'getPointsAffectedByInfluence', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('skinCluster', 'skinMethod')
    def getSkinMethod(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'skinMethod')
        return res

    @_f.addMelDocs('skinCluster', 'weightDistribution')
    def getWeightDistribution(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'weightDistribution')
        return res

    @_f.addMelDocs('skinCluster', 'weightedInfluence')
    def getWeightedInfluence(self, **kwargs):
        res = _f.asQuery(self, animation.skinCluster, kwargs, 'weightedInfluence')
        return res

    @_f.addMelDocs('skinCluster', 'ignoreBindPose')
    def ignoreBindPose(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'ignoreBindPose', val)

    @_f.addApiDocs(_api.MFnSkinCluster, 'indexForInfluenceObject')
    def indexForInfluenceObject(self, mpath):
        # type: (general.PyNode) -> int
        do, final_do, outTypes = _f.getDoArgs([mpath], [('mpath', 'MDagPath', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSkinCluster, 'indexForInfluenceObject', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addMelDocs('skinCluster', 'moveJointsMode')
    def moveJointsMode(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'moveJointsMode', val)

    @_f.addMelDocs('skinCluster', 'nurbsSamples')
    def nurbsSamples(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'nurbsSamples', val)

    @_f.addMelDocs('skinCluster', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'parallel', val)

    @_f.addMelDocs('skinCluster', 'polySmoothness')
    def polySmoothness(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'polySmoothness', val)

    @_f.addMelDocs('skinCluster', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'prune', val)

    @_f.addMelDocs('skinCluster', 'recacheBindMatrices')
    def recacheBindMatrices(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'recacheBindMatrices', val)

    @_f.addMelDocs('skinCluster', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'remove', val)

    @_f.addMelDocs('skinCluster', 'removeFromSelection')
    def removeFromSelection(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'removeFromSelection', val)

    @_f.addMelDocs('skinCluster', 'removeInfluence')
    def removeInfluence(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'removeInfluence', val)

    @_f.addMelDocs('skinCluster', 'selectInfluenceVerts')
    def selectInfluenceVerts(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'selectInfluenceVerts', val)

    @_f.addApiDocs(_api.MFnSkinCluster, 'setBlendWeights')
    def setBlendWeights(self, path, components, weights):
        # type: (general.PyNode, general.PyNode, List[float]) -> None
        do, final_do, outTypes = _f.processApiArgs([path, components, weights], [(u'path', 'MDagPath', 'in', None), (u'components', 'MObject', 'in', None), (u'weights', 'MDoubleArray', u'in', None)], self.getBlendWeights, self.setBlendWeights, ['path', 'components'])
        res = _f.getProxyResult(self, _api.MFnSkinCluster, 'setBlendWeights', final_do)
        return res

    @_f.addMelDocs('skinCluster', 'dropoffRate')
    def setDropoffRate(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'dropoffRate', val)

    @_f.addMelDocs('skinCluster', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'geometry', val)

    @_f.addMelDocs('skinCluster', 'influence')
    def setInfluence(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'influence', val)

    @_f.addMelDocs('skinCluster', 'lockWeights')
    def setLockWeights(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'lockWeights', val)

    @_f.addMelDocs('skinCluster', 'maximumInfluences')
    def setMaximumInfluences(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'maximumInfluences', val)

    @_f.addMelDocs('skinCluster', 'normalizeWeights')
    def setNormalizeWeights(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'normalizeWeights', val)

    @_f.addMelDocs('skinCluster', 'obeyMaxInfluences')
    def setObeyMaxInfluences(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'obeyMaxInfluences', val)

    @_f.addMelDocs('skinCluster', 'skinMethod')
    def setSkinMethod(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'skinMethod', val)

    @_f.addMelDocs('skinCluster', 'weightDistribution')
    def setWeightDistribution(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'weightDistribution', val)

    @_f.addMelDocs('skinCluster', 'smoothWeights')
    def smoothWeights(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'smoothWeights', val)

    @_f.addMelDocs('skinCluster', 'smoothWeightsMaxIterations')
    def smoothWeightsMaxIterations(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'smoothWeightsMaxIterations', val)

    @_f.addMelDocs('skinCluster', 'unbind')
    def unbind(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'unbind', val)

    @_f.addMelDocs('skinCluster', 'unbindKeepHistory')
    def unbindKeepHistory(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'unbindKeepHistory', val)

    @_f.addMelDocs('skinCluster', 'useGeometry')
    def useGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'useGeometry', val)

    @_f.addMelDocs('skinCluster', 'weight')
    def weight(self, val=True, **kwargs):
        return _f.asEdit(self, animation.skinCluster, kwargs, 'weight', val)
# ------ Do not edit above this line --------


# TODO: if hikHandle bug ever fixed:
#   - remove entry in apiCache.ApiCache.API_TO_MFN_OVERRIDES
#   - remove hard-code setting of HikHandle's parent to Transform
class HikHandle(Transform):
    pass
# ------ Do not edit below this line --------
    __apicls__ = _api.MFnTransform
    __melnode__ = u'hikHandle'
    __slots__ = ()
    LimitType = Enum('LimitType', {'scaleMinX': 0, 'kScaleMinX': 0, 'kScaleMaxX': 1, 'scaleMaxX': 1, 'scaleMinY': 2, 'kScaleMinY': 2, 'kScaleMaxY': 3, 'scaleMaxY': 3, 'scaleMinZ': 4, 'kScaleMinZ': 4, 'kScaleMaxZ': 5, 'scaleMaxZ': 5, 'shearMinXY': 6, 'kShearMinXY': 6, 'kShearMaxXY': 7, 'shearMaxXY': 7, 'shearMinXZ': 8, 'kShearMinXZ': 8, 'kShearMaxXZ': 9, 'shearMaxXZ': 9, 'shearMinYZ': 10, 'kShearMinYZ': 10, 'shearMaxYZ': 11, 'kShearMaxYZ': 11, 'rotateMinX': 12, 'kRotateMinX': 12, 'rotateMaxX': 13, 'kRotateMaxX': 13, 'rotateMinY': 14, 'kRotateMinY': 14, 'rotateMaxY': 15, 'kRotateMaxY': 15, 'rotateMinZ': 16, 'kRotateMinZ': 16, 'rotateMaxZ': 17, 'kRotateMaxZ': 17, 'translateMinX': 18, 'kTranslateMinX': 18, 'kTranslateMaxX': 19, 'translateMaxX': 19, 'translateMinY': 20, 'kTranslateMinY': 20, 'kTranslateMaxY': 21, 'translateMaxY': 21, 'translateMinZ': 22, 'kTranslateMinZ': 22, 'kTranslateMaxZ': 23, 'translateMaxZ': 23}, multiKeys=True, defaultKeys={0: 'scaleMinX', 1: 'scaleMaxX', 2: 'scaleMinY', 3: 'scaleMaxY', 4: 'scaleMinZ', 5: 'scaleMaxZ', 6: 'shearMinXY', 7: 'shearMaxXY', 8: 'shearMinXZ', 9: 'shearMaxXZ', 10: 'shearMinYZ', 11: 'shearMaxYZ', 12: 'rotateMinX', 13: 'rotateMaxX', 14: 'rotateMinY', 15: 'rotateMaxY', 16: 'rotateMinZ', 17: 'rotateMaxZ', 18: 'translateMinX', 19: 'translateMaxX', 20: 'translateMinY', 21: 'translateMaxY', 22: 'translateMinZ', 23: 'translateMaxZ'})

    @_f.addApiDocs(_api.MFnTransform, 'rotateOrientation')
    def getRotateOrientation(self, space):
        # type: (datatypes.Space.Space) -> Quaternion
        do, final_do, outTypes = _f.getDoArgs([space], [('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnTransform, 'rotateOrientation', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MQuaternion', None)
        return res
# ------ Do not edit above this line --------


_factories.ApiTypeRegister.register('MSelectionList', SelectionSet)

# def listToMSelection( objs ):
#    sel = _api.MSelectionList()
#    for obj in objs:
#        if isinstance(obj, DependNode):
#            sel.add( obj.__apiobject__() )
#        elif isinstance(obj, Attribute):
#            sel.add( obj.__apiobject__(), True )
#        elif isinstance(obj, Component):
#            pass
#            #sel.add( obj.__apiobject__(), True )
#        else:
#            raise TypeError

# ------ Do not edit below this line --------
class ColorProfile(DependNode):
    __melnode__ = u'colorProfile'
    __slots__ = ()


class StrokeGlobals(DependNode):
    __melnode__ = u'strokeGlobals'
    __slots__ = ()


class LightInfo(DependNode):
    __melnode__ = u'lightInfo'
    __slots__ = ()


class TimeEditor(DependNode):
    __melcmd__ = staticmethod(animation.timeEditor)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'timeEditor'
    __melnode__ = u'timeEditor'
    __slots__ = ()

    @_f.addMelDocs('timeEditor', 'mute')
    def getMute(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditor, kwargs, 'mute')
        return res


class TimeEditorClipBase(DependNode):
    __melnode__ = u'timeEditorClipBase'
    __slots__ = ()


class TimeEditorClip(TimeEditorClipBase):
    __melcmd__ = staticmethod(animation.timeEditorClip)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'timeEditorClip'
    __melnode__ = u'timeEditorClip'
    __slots__ = ()

    @_f.addMelDocs('timeEditorClip', 'allowShrinking')
    def allowShrinking(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'allowShrinking', val)

    @_f.addMelDocs('timeEditorClip', 'clipId')
    def clipId(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'clipId', val)

    @_f.addMelDocs('timeEditorClip', 'copyClip')
    def copyClip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'copyClip', val)

    @_f.addMelDocs('timeEditorClip', 'duplicateClip')
    def duplicateClip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'duplicateClip', val)

    @_f.addMelDocs('timeEditorClip', 'exclusive')
    def exclusive(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'exclusive', val)

    @_f.addMelDocs('timeEditorClip', 'existingOnly')
    def existingOnly(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'existingOnly', val)

    @_f.addMelDocs('timeEditorClip', 'explode')
    def explode(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'explode', val)

    @_f.addMelDocs('timeEditorClip', 'exportAllClips')
    def exportAllClips(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'exportAllClips', val)

    @_f.addMelDocs('timeEditorClip', 'exportFbx')
    def exportFbx(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'exportFbx', val)

    @_f.addMelDocs('timeEditorClip', 'extend')
    def extend(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'extend', val)

    @_f.addMelDocs('timeEditorClip', 'extendParent')
    def extendParent(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'extendParent', val)

    @_f.addMelDocs('timeEditorClip', 'absolute')
    def getAbsolute(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'absolute')
        return res

    @_f.addMelDocs('timeEditorClip', 'addObjects')
    def getAddObjects(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'addObjects')
        return res

    @_f.addMelDocs('timeEditorClip', 'addRelatedKG')
    def getAddRelatedKG(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'addRelatedKG')
        return res

    @_f.addMelDocs('timeEditorClip', 'addSelectedObjects')
    def getAddSelectedObjects(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'addSelectedObjects')
        return res

    @_f.addMelDocs('timeEditorClip', 'animSource')
    def getAnimSource(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'animSource')
        return res

    @_f.addMelDocs('timeEditorClip', 'children')
    def getChildren(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'children')
        return res

    @_f.addMelDocs('timeEditorClip', 'clipAfter')
    def getClipAfter(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'clipAfter')
        return res

    @_f.addMelDocs('timeEditorClip', 'clipBefore')
    def getClipBefore(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'clipBefore')
        return res

    @_f.addMelDocs('timeEditorClip', 'clipDataType')
    def getClipDataType(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'clipDataType')
        return res

    @_f.addMelDocs('timeEditorClip', 'clipIdFromNodeName')
    def getClipIdFromNodeName(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'clipIdFromNodeName')
        return res

    @_f.addMelDocs('timeEditorClip', 'clipIdFromPath')
    def getClipIdFromPath(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'clipIdFromPath')
        return res

    @_f.addMelDocs('timeEditorClip', 'clipNode')
    def getClipNode(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'clipNode')
        return res

    @_f.addMelDocs('timeEditorClip', 'clipPath')
    def getClipPath(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'clipPath')
        return res

    @_f.addMelDocs('timeEditorClip', 'crossfadeMode')
    def getCrossfadeMode(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'crossfadeMode')
        return res

    @_f.addMelDocs('timeEditorClip', 'crossfadePlug')
    def getCrossfadePlug(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'crossfadePlug')
        return res

    @_f.addMelDocs('timeEditorClip', 'curveTime')
    def getCurveTime(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'curveTime')
        return res

    @_f.addMelDocs('timeEditorClip', 'defaultGhostRoot')
    def getDefaultGhostRoot(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'defaultGhostRoot')
        return res

    @_f.addMelDocs('timeEditorClip', 'drivenAttributes')
    def getDrivenAttributes(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'drivenAttributes')
        return res

    @_f.addMelDocs('timeEditorClip', 'drivenClipsBySource')
    def getDrivenClipsBySource(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'drivenClipsBySource')
        return res

    @_f.addMelDocs('timeEditorClip', 'drivenObjects')
    def getDrivenObjects(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'drivenObjects')
        return res

    @_f.addMelDocs('timeEditorClip', 'drivenRootObjects')
    def getDrivenRootObjects(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'drivenRootObjects')
        return res

    @_f.addMelDocs('timeEditorClip', 'drivingSources')
    def getDrivingSources(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'drivingSources')
        return res

    @_f.addMelDocs('timeEditorClip', 'duration')
    def getDuration(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'duration')
        return res

    @_f.addMelDocs('timeEditorClip', 'endTime')
    def getEndTime(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'endTime')
        return res

    @_f.addMelDocs('timeEditorClip', 'exists')
    def getExists(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'exists')
        return res

    @_f.addMelDocs('timeEditorClip', 'ghost')
    def getGhost(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'ghost')
        return res

    @_f.addMelDocs('timeEditorClip', 'holdEnd')
    def getHoldEnd(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'holdEnd')
        return res

    @_f.addMelDocs('timeEditorClip', 'holdStart')
    def getHoldStart(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'holdStart')
        return res

    @_f.addMelDocs('timeEditorClip', 'isContainer')
    def getIsContainer(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'isContainer')
        return res

    @_f.addMelDocs('timeEditorClip', 'listUserGhostRoot')
    def getListUserGhostRoot(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'listUserGhostRoot')
        return res

    @_f.addMelDocs('timeEditorClip', 'loopEnd')
    def getLoopEnd(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'loopEnd')
        return res

    @_f.addMelDocs('timeEditorClip', 'loopStart')
    def getLoopStart(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'loopStart')
        return res

    @_f.addMelDocs('timeEditorClip', 'minClipDuration')
    def getMinClipDuration(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'minClipDuration')
        return res

    @_f.addMelDocs('timeEditorClip', 'mute')
    def getMute(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'mute')
        return res

    @_f.addMelDocs('timeEditorClip', 'parentClipId')
    def getParentClipId(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'parentClipId')
        return res

    @_f.addMelDocs('timeEditorClip', 'parentGroupId')
    def getParentGroupId(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'parentGroupId')
        return res

    @_f.addMelDocs('timeEditorClip', 'remappedSourceAttrs')
    def getRemappedSourceAttrs(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'remappedSourceAttrs')
        return res

    @_f.addMelDocs('timeEditorClip', 'remappedTargetAttrs')
    def getRemappedTargetAttrs(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'remappedTargetAttrs')
        return res

    @_f.addMelDocs('timeEditorClip', 'removeWeightCurve')
    def getRemoveWeightCurve(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'removeWeightCurve')
        return res

    @_f.addMelDocs('timeEditorClip', 'speedRamping')
    def getSpeedRamping(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'speedRamping')
        return res

    @_f.addMelDocs('timeEditorClip', 'startTime')
    def getStartTime(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'startTime')
        return res

    @_f.addMelDocs('timeEditorClip', 'timeWarp')
    def getTimeWarp(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'timeWarp')
        return res

    @_f.addMelDocs('timeEditorClip', 'timeWarpCurve')
    def getTimeWarpCurve(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'timeWarpCurve')
        return res

    @_f.addMelDocs('timeEditorClip', 'timeWarpType')
    def getTimeWarpType(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'timeWarpType')
        return res

    @_f.addMelDocs('timeEditorClip', 'track')
    def getTrack(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'track')
        return res

    @_f.addMelDocs('timeEditorClip', 'tracksNode')
    def getTracksNode(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'tracksNode')
        return res

    @_f.addMelDocs('timeEditorClip', 'truncated')
    def getTruncated(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'truncated')
        return res

    @_f.addMelDocs('timeEditorClip', 'type')
    def getType(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'type')
        return res

    @_f.addMelDocs('timeEditorClip', 'userGhostRoot')
    def getUserGhostRoot(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'userGhostRoot')
        return res

    @_f.addMelDocs('timeEditorClip', 'weightCurve')
    def getWeightCurve(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorClip, kwargs, 'weightCurve')
        return res

    @_f.addMelDocs('timeEditorClip', 'ghostRootAdd')
    def ghostRootAdd(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'ghostRootAdd', val)

    @_f.addMelDocs('timeEditorClip', 'ghostRootRemove')
    def ghostRootRemove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'ghostRootRemove', val)

    @_f.addMelDocs('timeEditorClip', 'importOption')
    def importOption(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'importOption', val)

    @_f.addMelDocs('timeEditorClip', 'importPopulateOption')
    def importPopulateOption(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'importPopulateOption', val)

    @_f.addMelDocs('timeEditorClip', 'includeRoot')
    def includeRoot(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'includeRoot', val)

    @_f.addMelDocs('timeEditorClip', 'modifyAnimSource')
    def modifyAnimSource(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'modifyAnimSource', val)

    @_f.addMelDocs('timeEditorClip', 'moveClip')
    def moveClip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'moveClip', val)

    @_f.addMelDocs('timeEditorClip', 'parent')
    def parent(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'parent', val)

    @_f.addMelDocs('timeEditorClip', 'pasteClip')
    def pasteClip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'pasteClip', val)

    @_f.addMelDocs('timeEditorClip', 'path')
    def path(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'path', val)

    @_f.addMelDocs('timeEditorClip', 'razorClip')
    def razorClip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'razorClip', val)

    @_f.addMelDocs('timeEditorClip', 'recursively')
    def recursively(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'recursively', val)

    @_f.addMelDocs('timeEditorClip', 'remap')
    def remap(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'remap', val)

    @_f.addMelDocs('timeEditorClip', 'remapSource')
    def remapSource(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'remapSource', val)

    @_f.addMelDocs('timeEditorClip', 'removeClip')
    def removeClip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'removeClip', val)

    @_f.addMelDocs('timeEditorClip', 'removeCrossfade')
    def removeCrossfade(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'removeCrossfade', val)

    @_f.addMelDocs('timeEditorClip', 'removeSceneAnimation')
    def removeSceneAnimation(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'removeSceneAnimation', val)

    @_f.addMelDocs('timeEditorClip', 'resetTiming')
    def resetTiming(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'resetTiming', val)

    @_f.addMelDocs('timeEditorClip', 'resetTransition')
    def resetTransition(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'resetTransition', val)

    @_f.addMelDocs('timeEditorClip', 'ripple')
    def ripple(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'ripple', val)

    @_f.addMelDocs('timeEditorClip', 'rootClipId')
    def rootClipId(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'rootClipId', val)

    @_f.addMelDocs('timeEditorClip', 'rootPath')
    def rootPath(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'rootPath', val)

    @_f.addMelDocs('timeEditorClip', 'scaleEnd')
    def scaleEnd(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'scaleEnd', val)

    @_f.addMelDocs('timeEditorClip', 'scalePivot')
    def scalePivot(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'scalePivot', val)

    @_f.addMelDocs('timeEditorClip', 'scaleStart')
    def scaleStart(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'scaleStart', val)

    @_f.addMelDocs('timeEditorClip', 'addObjects')
    def setAddObjects(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'addObjects', val)

    @_f.addMelDocs('timeEditorClip', 'addRelatedKG')
    def setAddRelatedKG(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'addRelatedKG', val)

    @_f.addMelDocs('timeEditorClip', 'addSelectedObjects')
    def setAddSelectedObjects(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'addSelectedObjects', val)

    @_f.addMelDocs('timeEditorClip', 'animSource')
    def setAnimSource(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'animSource', val)

    @_f.addMelDocs('timeEditorClip', 'crossfadeMode')
    def setCrossfadeMode(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'crossfadeMode', val)

    @_f.addMelDocs('timeEditorClip', 'defaultGhostRoot')
    def setDefaultGhostRoot(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'defaultGhostRoot', val)

    @_f.addMelDocs('timeEditorClip', 'ghost')
    def setGhost(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'ghost', val)

    @_f.addMelDocs('timeEditorClip', 'holdEnd')
    def setHoldEnd(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'holdEnd', val)

    @_f.addMelDocs('timeEditorClip', 'holdStart')
    def setHoldStart(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'holdStart', val)

    @_f.addMelDocs('timeEditorClip', 'setKeyframe')
    def setKeyframe(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'setKeyframe', val)

    @_f.addMelDocs('timeEditorClip', 'loopEnd')
    def setLoopEnd(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'loopEnd', val)

    @_f.addMelDocs('timeEditorClip', 'loopStart')
    def setLoopStart(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'loopStart', val)

    @_f.addMelDocs('timeEditorClip', 'mute')
    def setMute(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'mute', val)

    @_f.addMelDocs('timeEditorClip', 'removeWeightCurve')
    def setRemoveWeightCurve(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'removeWeightCurve', val)

    @_f.addMelDocs('timeEditorClip', 'speedRamping')
    def setSpeedRamping(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'speedRamping', val)

    @_f.addMelDocs('timeEditorClip', 'timeWarpType')
    def setTimeWarpType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'timeWarpType', val)

    @_f.addMelDocs('timeEditorClip', 'track')
    def setTrack(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'track', val)

    @_f.addMelDocs('timeEditorClip', 'type')
    def setType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'type', val)

    @_f.addMelDocs('timeEditorClip', 'userGhostRoot')
    def setUserGhostRoot(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'userGhostRoot', val)

    @_f.addMelDocs('timeEditorClip', 'weightCurve')
    def setWeightCurve(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'weightCurve', val)

    @_f.addMelDocs('timeEditorClip', 'transition')
    def transition(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'transition', val)

    @_f.addMelDocs('timeEditorClip', 'trimEnd')
    def trimEnd(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'trimEnd', val)

    @_f.addMelDocs('timeEditorClip', 'trimStart')
    def trimStart(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'trimStart', val)

    @_f.addMelDocs('timeEditorClip', 'uniqueAnimSource')
    def uniqueAnimSource(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'uniqueAnimSource', val)

    @_f.addMelDocs('timeEditorClip', 'zeroKeying')
    def zeroKeying(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorClip, kwargs, 'zeroKeying', val)


class Choice(DependNode):
    __melcmd__ = staticmethod(animation.choice)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'choice'
    __melnode__ = u'choice'
    __slots__ = ()

    @_f.addMelDocs('choice', 'index')
    def getIndex(self, **kwargs):
        res = _f.asQuery(self, animation.choice, kwargs, 'index')
        return res

    @_f.addMelDocs('choice', 'selector')
    def getSelector(self, **kwargs):
        res = _f.asQuery(self, animation.choice, kwargs, 'selector')
        return res


class DefaultShaderList(DependNode):
    __melnode__ = u'defaultShaderList'
    __slots__ = ()


class Condition(DependNode):
    __melnode__ = u'condition'
    __slots__ = ()


class SelectionListOperator(DependNode):
    __melnode__ = u'selectionListOperator'
    __slots__ = ()


class UnitConversion(DependNode):
    __melnode__ = u'unitConversion'
    __slots__ = ()


class ParticleTranspMapper(DependNode):
    __melnode__ = u'particleTranspMapper'
    __slots__ = ()


class Contrast(DependNode):
    __melnode__ = u'contrast'
    __slots__ = ()


class ShaderGlow(DependNode):
    __melnode__ = u'shaderGlow'
    __slots__ = ()


class RenderGlobals(DependNode):
    __melnode__ = u'renderGlobals'
    __slots__ = ()


class ReorderUVSet(DependNode):
    __melnode__ = u'reorderUVSet'
    __slots__ = ()


class DeleteColorSet(DependNode):
    __melnode__ = u'deleteColorSet'
    __slots__ = ()


class PassContributionMap(DependNode):
    __melnode__ = u'passContributionMap'
    __slots__ = ()


class Chooser(DependNode):
    __melnode__ = u'chooser'
    __slots__ = ()


class SimpleVolumeShader(DependNode):
    __melnode__ = u'simpleVolumeShader'
    __slots__ = ()


class PolyBlindData(DependNode):
    __melcmd__ = staticmethod(modeling.polyBlindData)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyBlindData'
    __melnode__ = u'polyBlindData'
    __slots__ = ()

    @_f.addMelDocs('polyBlindData', 'associationType')
    def associationType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'associationType', val)

    @_f.addMelDocs('polyBlindData', 'binaryData')
    def binaryData(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'binaryData', val)

    @_f.addMelDocs('polyBlindData', 'booleanData')
    def booleanData(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'booleanData', val)

    @_f.addMelDocs('polyBlindData', 'delete')
    def delete(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'delete', val)

    @_f.addMelDocs('polyBlindData', 'doubleData')
    def doubleData(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'doubleData', val)

    @_f.addMelDocs('polyBlindData', 'int64Data')
    def int64Data(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'int64Data', val)

    @_f.addMelDocs('polyBlindData', 'intData')
    def intData(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'intData', val)

    @_f.addMelDocs('polyBlindData', 'longDataName')
    def longDataName(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'longDataName', val)

    @_f.addMelDocs('polyBlindData', 'rescan')
    def rescan(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'rescan', val)

    @_f.addMelDocs('polyBlindData', 'reset')
    def reset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'reset', val)

    @_f.addMelDocs('polyBlindData', 'shape')
    def shape(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'shape', val)

    @_f.addMelDocs('polyBlindData', 'shortDataName')
    def shortDataName(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'shortDataName', val)

    @_f.addMelDocs('polyBlindData', 'stringData')
    def stringData(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBlindData, kwargs, 'stringData', val)


class SubdBlindData(PolyBlindData):
    __melnode__ = u'subdBlindData'
    __slots__ = ()


class CharacterOffset(DependNode):
    __melnode__ = u'characterOffset'
    __slots__ = ()


class UnitToTimeConversion(DependNode):
    __melnode__ = u'unitToTimeConversion'
    __slots__ = ()


class CreateUVSet(DependNode):
    __melnode__ = u'createUVSet'
    __slots__ = ()


class SurfaceLuminance(DependNode):
    __melnode__ = u'surfaceLuminance'
    __slots__ = ()


class BlendColors(DependNode):
    __melnode__ = u'blendColors'
    __slots__ = ()


class GroupId(DependNode):
    __melnode__ = u'groupId'
    __slots__ = ()


class SetRange(DependNode):
    __melnode__ = u'setRange'
    __slots__ = ()


class CopyUVSet(DependNode):
    __melnode__ = u'copyUVSet'
    __slots__ = ()


class RenderQuality(DependNode):
    __melnode__ = u'renderQuality'
    __slots__ = ()


class Tweak(GeometryFilter):
    __melnode__ = u'tweak'
    __slots__ = ()


class BoneLattice(GeometryFilter):
    __melcmd__ = staticmethod(animation.boneLattice)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'boneLattice'
    __melnode__ = u'boneLattice'
    __slots__ = ()

    @_f.addMelDocs('boneLattice', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'after', val)

    @_f.addMelDocs('boneLattice', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'afterReference', val)

    @_f.addMelDocs('boneLattice', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'before', val)

    @_f.addMelDocs('boneLattice', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('boneLattice', 'bicep')
    def getBicep(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'bicep')
        return res

    @_f.addMelDocs('boneLattice', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('boneLattice', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('boneLattice', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'geometry')
        return res

    @_f.addMelDocs('boneLattice', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('boneLattice', 'joint')
    def getJoint(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'joint')
        return res

    @_f.addMelDocs('boneLattice', 'lengthIn')
    def getLengthIn(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'lengthIn')
        return res

    @_f.addMelDocs('boneLattice', 'lengthOut')
    def getLengthOut(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'lengthOut')
        return res

    @_f.addMelDocs('boneLattice', 'tricep')
    def getTricep(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'tricep')
        return res

    @_f.addMelDocs('boneLattice', 'widthLeft')
    def getWidthLeft(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'widthLeft')
        return res

    @_f.addMelDocs('boneLattice', 'widthRight')
    def getWidthRight(self, **kwargs):
        res = _f.asQuery(self, animation.boneLattice, kwargs, 'widthRight')
        return res

    @_f.addMelDocs('boneLattice', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'parallel', val)

    @_f.addMelDocs('boneLattice', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'prune', val)

    @_f.addMelDocs('boneLattice', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'remove', val)

    @_f.addMelDocs('boneLattice', 'bicep')
    def setBicep(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'bicep', val)

    @_f.addMelDocs('boneLattice', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'geometry', val)

    @_f.addMelDocs('boneLattice', 'joint')
    def setJoint(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'joint', val)

    @_f.addMelDocs('boneLattice', 'lengthIn')
    def setLengthIn(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'lengthIn', val)

    @_f.addMelDocs('boneLattice', 'lengthOut')
    def setLengthOut(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'lengthOut', val)

    @_f.addMelDocs('boneLattice', 'tricep')
    def setTricep(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'tricep', val)

    @_f.addMelDocs('boneLattice', 'widthLeft')
    def setWidthLeft(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'widthLeft', val)

    @_f.addMelDocs('boneLattice', 'widthRight')
    def setWidthRight(self, val=True, **kwargs):
        return _f.asEdit(self, animation.boneLattice, kwargs, 'widthRight', val)


class THskinCluster(SkinCluster):
    __apicls__ = _api.MFnBlendShapeDeformer
    __melnode__ = u'THskinCluster'
    __slots__ = ()
    HistoryLocation = Enum('HistoryLocation', {'frontOfChain': 0, 'kFrontOfChain': 0, 'normal': 1, 'kNormal': 1, 'kPost': 2, 'post': 2, 'kOther': 3, 'other': 3}, multiKeys=True, defaultKeys={0: 'frontOfChain', 1: 'normal', 2: 'post', 3: 'other'})
    Origin = Enum('Origin', {'localOrigin': 0, 'kLocalOrigin': 0, 'worldOrigin': 1, 'kWorldOrigin': 1}, multiKeys=True, defaultKeys={0: 'localOrigin', 1: 'worldOrigin'})
    TargetType = Enum('TargetType', {'object': 0, 'kObject': 0, 'kTangent': 1, 'tangent': 1}, multiKeys=True, defaultKeys={0: 'object', 1: 'tangent'})


class WeightGeometryFilter(GeometryFilter):
    __apicls__ = _api.MFnWeightGeometryFilter
    __melnode__ = u'weightGeometryFilter'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnWeightGeometryFilter, 'getWeightPlugStrings')
    def getWeightPlugStrings(self, list):
        # type: (SelectionSet) -> List[unicode]
        do, final_do, outTypes = _f.getDoArgs([list], [('list', 'MSelectionList', 'in', None), ('plugStringArray', 'MStringArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnWeightGeometryFilter, 'getWeightPlugStrings', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnWeightGeometryFilter, 'getWeights')
    def getWeights(self, index):
        # type: (int) -> Tuple[general.PyNode, List[float]]
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None), ('components', 'MObject', 'out', None), ('weights', 'MFloatArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnWeightGeometryFilter, 'getWeights', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnWeightGeometryFilter, 'setWeight')
    def setWeight(self, path, index, components, weight, oldValues=None):
        # type: (general.PyNode, int, general.PyNode, float, List[float]) -> None
        do, final_do, outTypes = _f.getDoArgs([path, index, components, weight, oldValues], [('path', 'MDagPath', 'in', None), ('index', 'uint', 'in', None), ('components', 'MObject', 'in', None), ('weight', 'float', 'in', None), ('oldValues', 'MFloatArray', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWeightGeometryFilter, 'setWeight', final_do)
        return res

    @_f.addApiDocs(_api.MFnWeightGeometryFilter, 'weightPlugStrings')
    def weightPlugStrings(self, list):
        # type: (SelectionSet) -> unicode
        do, final_do, outTypes = _f.getDoArgs([list], [('list', 'MSelectionList', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWeightGeometryFilter, 'weightPlugStrings', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res


class NonLinear(WeightGeometryFilter):
    __melcmd__ = staticmethod(animation.nonLinear)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'nonLinear'
    __melnode__ = u'nonLinear'
    __slots__ = ()

    @_f.addMelDocs('nonLinear', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.nonLinear, kwargs, 'after', val)

    @_f.addMelDocs('nonLinear', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.nonLinear, kwargs, 'afterReference', val)

    @_f.addMelDocs('nonLinear', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.nonLinear, kwargs, 'before', val)

    @_f.addMelDocs('nonLinear', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.nonLinear, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('nonLinear', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.nonLinear, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('nonLinear', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.nonLinear, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('nonLinear', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.nonLinear, kwargs, 'geometry')
        return res

    @_f.addMelDocs('nonLinear', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.nonLinear, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('nonLinear', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.nonLinear, kwargs, 'parallel', val)

    @_f.addMelDocs('nonLinear', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.nonLinear, kwargs, 'prune', val)

    @_f.addMelDocs('nonLinear', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.nonLinear, kwargs, 'remove', val)

    @_f.addMelDocs('nonLinear', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.nonLinear, kwargs, 'geometry', val)


class DeltaMush(WeightGeometryFilter):
    __melcmd__ = staticmethod(animation.deltaMush)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'deltaMush'
    __melnode__ = u'deltaMush'
    __slots__ = ()

    @_f.addMelDocs('deltaMush', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'after', val)

    @_f.addMelDocs('deltaMush', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'afterReference', val)

    @_f.addMelDocs('deltaMush', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'before', val)

    @_f.addMelDocs('deltaMush', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('deltaMush', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('deltaMush', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('deltaMush', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'geometry')
        return res

    @_f.addMelDocs('deltaMush', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('deltaMush', 'inwardConstraint')
    def getInwardConstraint(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'inwardConstraint')
        return res

    @_f.addMelDocs('deltaMush', 'outwardConstraint')
    def getOutwardConstraint(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'outwardConstraint')
        return res

    @_f.addMelDocs('deltaMush', 'pinBorderVertices')
    def getPinBorderVertices(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'pinBorderVertices')
        return res

    @_f.addMelDocs('deltaMush', 'smoothingIterations')
    def getSmoothingIterations(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'smoothingIterations')
        return res

    @_f.addMelDocs('deltaMush', 'smoothingStep')
    def getSmoothingStep(self, **kwargs):
        res = _f.asQuery(self, animation.deltaMush, kwargs, 'smoothingStep')
        return res

    @_f.addMelDocs('deltaMush', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'parallel', val)

    @_f.addMelDocs('deltaMush', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'prune', val)

    @_f.addMelDocs('deltaMush', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'remove', val)

    @_f.addMelDocs('deltaMush', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'geometry', val)

    @_f.addMelDocs('deltaMush', 'inwardConstraint')
    def setInwardConstraint(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'inwardConstraint', val)

    @_f.addMelDocs('deltaMush', 'outwardConstraint')
    def setOutwardConstraint(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'outwardConstraint', val)

    @_f.addMelDocs('deltaMush', 'pinBorderVertices')
    def setPinBorderVertices(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'pinBorderVertices', val)

    @_f.addMelDocs('deltaMush', 'smoothingIterations')
    def setSmoothingIterations(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'smoothingIterations', val)

    @_f.addMelDocs('deltaMush', 'smoothingStep')
    def setSmoothingStep(self, val=True, **kwargs):
        return _f.asEdit(self, animation.deltaMush, kwargs, 'smoothingStep', val)


class Cluster(WeightGeometryFilter):
    __melcmd__ = staticmethod(animation.cluster)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'cluster'
    __melnode__ = u'cluster'
    __slots__ = ()

    @_f.addMelDocs('cluster', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'after', val)

    @_f.addMelDocs('cluster', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'afterReference', val)

    @_f.addMelDocs('cluster', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'before', val)

    @_f.addMelDocs('cluster', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('cluster', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.cluster, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('cluster', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.cluster, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('cluster', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.cluster, kwargs, 'geometry')
        return res

    @_f.addMelDocs('cluster', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.cluster, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('cluster', 'weightedNode')
    def getWeightedNode(self, **kwargs):
        res = _f.asQuery(self, animation.cluster, kwargs, 'weightedNode')
        return res

    @_f.addMelDocs('cluster', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'parallel', val)

    @_f.addMelDocs('cluster', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'prune', val)

    @_f.addMelDocs('cluster', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'remove', val)

    @_f.addMelDocs('cluster', 'resetGeometry')
    def resetGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'resetGeometry', val)

    @_f.addMelDocs('cluster', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'geometry', val)

    @_f.addMelDocs('cluster', 'weightedNode')
    def setWeightedNode(self, val=True, **kwargs):
        return _f.asEdit(self, animation.cluster, kwargs, 'weightedNode', val)


class JointCluster(Cluster):
    __melcmd__ = staticmethod(animation.jointCluster)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'jointCluster'
    __melnode__ = u'jointCluster'
    __slots__ = ()

    @_f.addMelDocs('jointCluster', 'aboveBound')
    def getAboveBound(self, **kwargs):
        res = _f.asQuery(self, animation.jointCluster, kwargs, 'aboveBound')
        return res

    @_f.addMelDocs('jointCluster', 'aboveCluster')
    def getAboveCluster(self, **kwargs):
        res = _f.asQuery(self, animation.jointCluster, kwargs, 'aboveCluster')
        return res

    @_f.addMelDocs('jointCluster', 'aboveDropoffType')
    def getAboveDropoffType(self, **kwargs):
        res = _f.asQuery(self, animation.jointCluster, kwargs, 'aboveDropoffType')
        return res

    @_f.addMelDocs('jointCluster', 'aboveValue')
    def getAboveValue(self, **kwargs):
        res = _f.asQuery(self, animation.jointCluster, kwargs, 'aboveValue')
        return res

    @_f.addMelDocs('jointCluster', 'belowBound')
    def getBelowBound(self, **kwargs):
        res = _f.asQuery(self, animation.jointCluster, kwargs, 'belowBound')
        return res

    @_f.addMelDocs('jointCluster', 'belowCluster')
    def getBelowCluster(self, **kwargs):
        res = _f.asQuery(self, animation.jointCluster, kwargs, 'belowCluster')
        return res

    @_f.addMelDocs('jointCluster', 'belowDropoffType')
    def getBelowDropoffType(self, **kwargs):
        res = _f.asQuery(self, animation.jointCluster, kwargs, 'belowDropoffType')
        return res

    @_f.addMelDocs('jointCluster', 'belowValue')
    def getBelowValue(self, **kwargs):
        res = _f.asQuery(self, animation.jointCluster, kwargs, 'belowValue')
        return res

    @_f.addMelDocs('jointCluster', 'aboveBound')
    def setAboveBound(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointCluster, kwargs, 'aboveBound', val)

    @_f.addMelDocs('jointCluster', 'aboveDropoffType')
    def setAboveDropoffType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointCluster, kwargs, 'aboveDropoffType', val)

    @_f.addMelDocs('jointCluster', 'aboveValue')
    def setAboveValue(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointCluster, kwargs, 'aboveValue', val)

    @_f.addMelDocs('jointCluster', 'belowBound')
    def setBelowBound(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointCluster, kwargs, 'belowBound', val)

    @_f.addMelDocs('jointCluster', 'belowDropoffType')
    def setBelowDropoffType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointCluster, kwargs, 'belowDropoffType', val)

    @_f.addMelDocs('jointCluster', 'belowValue')
    def setBelowValue(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointCluster, kwargs, 'belowValue', val)


class Tension(WeightGeometryFilter):
    __melcmd__ = staticmethod(animation.tension)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'tension'
    __melnode__ = u'tension'
    __slots__ = ()

    @_f.addMelDocs('tension', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'after', val)

    @_f.addMelDocs('tension', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'afterReference', val)

    @_f.addMelDocs('tension', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'before', val)

    @_f.addMelDocs('tension', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('tension', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('tension', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('tension', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'geometry')
        return res

    @_f.addMelDocs('tension', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('tension', 'inwardConstraint')
    def getInwardConstraint(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'inwardConstraint')
        return res

    @_f.addMelDocs('tension', 'outwardConstraint')
    def getOutwardConstraint(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'outwardConstraint')
        return res

    @_f.addMelDocs('tension', 'pinBorderVertices')
    def getPinBorderVertices(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'pinBorderVertices')
        return res

    @_f.addMelDocs('tension', 'smoothingIterations')
    def getSmoothingIterations(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'smoothingIterations')
        return res

    @_f.addMelDocs('tension', 'smoothingStep')
    def getSmoothingStep(self, **kwargs):
        res = _f.asQuery(self, animation.tension, kwargs, 'smoothingStep')
        return res

    @_f.addMelDocs('tension', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'parallel', val)

    @_f.addMelDocs('tension', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'prune', val)

    @_f.addMelDocs('tension', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'remove', val)

    @_f.addMelDocs('tension', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'geometry', val)

    @_f.addMelDocs('tension', 'inwardConstraint')
    def setInwardConstraint(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'inwardConstraint', val)

    @_f.addMelDocs('tension', 'outwardConstraint')
    def setOutwardConstraint(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'outwardConstraint', val)

    @_f.addMelDocs('tension', 'pinBorderVertices')
    def setPinBorderVertices(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'pinBorderVertices', val)

    @_f.addMelDocs('tension', 'smoothingIterations')
    def setSmoothingIterations(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'smoothingIterations', val)

    @_f.addMelDocs('tension', 'smoothingStep')
    def setSmoothingStep(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tension, kwargs, 'smoothingStep', val)


class Ffd(WeightGeometryFilter):
    __apicls__ = _api.MFnLatticeDeformer
    __melnode__ = u'ffd'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnLatticeDeformer, 'addGeometry')
    def addGeometry(self, object):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([object], [('object', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLatticeDeformer, 'addGeometry', final_do)
        return res

    @_f.addApiDocs(_api.MFnLatticeDeformer, 'baseLattice')
    def baseLattice(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnLatticeDeformer, 'baseLattice')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnLatticeDeformer, 'deformLattice')
    def deformLattice(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnLatticeDeformer, 'deformLattice')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnLatticeDeformer, 'getAffectedGeometry')
    def getAffectedGeometry(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('objects', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnLatticeDeformer, 'getAffectedGeometry', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnLatticeDeformer, 'getDivisions')
    def getDivisions(self):
        # type: () -> Tuple[int, int, int]
        do, final_do, outTypes = _f.getDoArgs([], [('x', 'uint', 'out', None), ('y', 'uint', 'out', None), ('z', 'uint', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnLatticeDeformer, 'getDivisions', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnLatticeDeformer, 'removeGeometry')
    def removeGeometry(self, object):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([object], [('object', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLatticeDeformer, 'removeGeometry', final_do)
        return res

    @_f.addApiDocs(_api.MFnLatticeDeformer, 'resetLattice')
    def resetLattice(self, centerLattice=False):
        # type: (bool) -> None
        do, final_do, outTypes = _f.getDoArgs([centerLattice], [('centerLattice', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLatticeDeformer, 'resetLattice', final_do)
        return res

    @_f.addApiDocs(_api.MFnLatticeDeformer, 'setDivisions')
    def setDivisions(self, x, y, z):
        # type: (int, int, int) -> None
        do, final_do, outTypes = _f.processApiArgs([x, y, z], [('x', 'uint', 'in', None), ('y', 'uint', 'in', None), ('z', 'uint', 'in', None)], self.getDivisions, self.setDivisions, [])
        res = _f.getProxyResult(self, _api.MFnLatticeDeformer, 'setDivisions', final_do)
        return res


class ShrinkWrap(WeightGeometryFilter):
    __melnode__ = u'shrinkWrap'
    __slots__ = ()


class Wire(WeightGeometryFilter):
    __apicls__ = _api.MFnWireDeformer
    __melcmd__ = staticmethod(animation.wire)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'wire'
    __melnode__ = u'wire'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnWireDeformer, 'addGeometry')
    def addGeometry(self, object):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([object], [('object', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'addGeometry', final_do)
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'addWire')
    def addWire(self, object):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([object], [('object', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'addWire', final_do)
        return res

    @_f.addMelDocs('wire', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'after', val)

    @_f.addMelDocs('wire', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'afterReference', val)

    @_f.addMelDocs('wire', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'before', val)

    @_f.addMelDocs('wire', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'frontOfChain', val)

    @_f.addApiDocs(_api.MFnWireDeformer, 'getAffectedGeometry')
    def getAffectedGeometry(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('objects', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'getAffectedGeometry', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnWireDeformer, 'crossingEffect')
    def getCrossingEffect(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'crossingEffect')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addMelDocs('wire', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('wire', 'dropoffDistance')
    def getDropoffDistance(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'dropoffDistance')
        return res

    @_f.addMelDocs('wire', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('wire', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'geometry')
        return res

    @_f.addMelDocs('wire', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('wire', 'holder')
    def getHolder(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'holder')
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'holdingShape')
    def getHoldingShape(self, wireIndex):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([wireIndex], [('wireIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'holdingShape', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addMelDocs('wire', 'localInfluence')
    def getLocalInfluence(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'localInfluence')
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'localIntensity')
    def getLocalIntensity(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'localIntensity')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnWireDeformer, 'rotation')
    def getRotation(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'rotation')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addMelDocs('wire', 'wire')
    def getWire(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'wire')
        return res

    @_f.addMelDocs('wire', 'wireCount')
    def getWireCount(self, **kwargs):
        res = _f.asQuery(self, animation.wire, kwargs, 'wireCount')
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'wireDropOffDistance')
    def getWireDropOffDistance(self, wireIndex):
        # type: (int) -> float
        do, final_do, outTypes = _f.getDoArgs([wireIndex], [('wireIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'wireDropOffDistance', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'float', None)
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'wireScale')
    def getWireScale(self, wireIndex):
        # type: (int) -> float
        do, final_do, outTypes = _f.getDoArgs([wireIndex], [('wireIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'wireScale', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'float', None)
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'numDropoffLocators')
    def numDropoffLocators(self, wireIndex):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([wireIndex], [('wireIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'numDropoffLocators', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'numWires')
    def numWires(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'numWires')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('wire', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'parallel', val)

    @_f.addMelDocs('wire', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'prune', val)

    @_f.addMelDocs('wire', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'remove', val)

    @_f.addApiDocs(_api.MFnWireDeformer, 'removeGeometry')
    def removeGeometry(self, object):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([object], [('object', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'removeGeometry', final_do)
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'setCrossingEffect')
    def setCrossingEffect(self, crossingEffect):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([crossingEffect], [('crossingEffect', 'float', 'in', None)], self.getCrossingEffect, self.setCrossingEffect, [])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'setCrossingEffect', final_do)
        return res

    @_f.addMelDocs('wire', 'dropoffDistance')
    def setDropoffDistance(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'dropoffDistance', val)

    @_f.addMelDocs('wire', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'geometry', val)

    @_f.addMelDocs('wire', 'holder')
    def setHolder(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'holder', val)

    @_f.addApiDocs(_api.MFnWireDeformer, 'setHoldingShape')
    def setHoldingShape(self, wireIndex, holdingShape):
        # type: (int, general.PyNode) -> None
        do, final_do, outTypes = _f.processApiArgs([wireIndex, holdingShape], [('wireIndex', 'uint', 'in', None), ('holdingShape', 'MObject', 'in', None)], self.getHoldingShape, self.setHoldingShape, ['wireIndex'])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'setHoldingShape', final_do)
        return res

    @_f.addMelDocs('wire', 'localInfluence')
    def setLocalInfluence(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'localInfluence', val)

    @_f.addApiDocs(_api.MFnWireDeformer, 'setLocalIntensity')
    def setLocalIntensity(self, localIntensity):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([localIntensity], [('localIntensity', 'float', 'in', None)], self.getLocalIntensity, self.setLocalIntensity, [])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'setLocalIntensity', final_do)
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'setRotation')
    def setRotation(self, rotation):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([rotation], [('rotation', 'float', 'in', None)], self.getRotation, self.setRotation, [])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'setRotation', final_do)
        return res

    @_f.addMelDocs('wire', 'wire')
    def setWire(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'wire', val)

    @_f.addMelDocs('wire', 'wireCount')
    def setWireCount(self, val=True, **kwargs):
        return _f.asEdit(self, animation.wire, kwargs, 'wireCount', val)

    @_f.addApiDocs(_api.MFnWireDeformer, 'setWireDropOffDistance')
    def setWireDropOffDistance(self, wireIndex, dropOff):
        # type: (int, float) -> None
        do, final_do, outTypes = _f.processApiArgs([wireIndex, dropOff], [('wireIndex', 'uint', 'in', None), ('dropOff', 'float', 'in', None)], self.getWireDropOffDistance, self.setWireDropOffDistance, ['wireIndex'])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'setWireDropOffDistance', final_do)
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'setWireScale')
    def setWireScale(self, wireIndex, scale):
        # type: (int, float) -> None
        do, final_do, outTypes = _f.processApiArgs([wireIndex, scale], [('wireIndex', 'uint', 'in', None), ('scale', 'float', 'in', None)], self.getWireScale, self.setWireScale, ['wireIndex'])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'setWireScale', final_do)
        return res

    @_f.addApiDocs(_api.MFnWireDeformer, 'wire')
    def wire(self, wireIndex):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([wireIndex], [('wireIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnWireDeformer, 'wire', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res


class SoftMod(WeightGeometryFilter):
    __melcmd__ = staticmethod(animation.softMod)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'softMod'
    __melnode__ = u'softMod'
    __slots__ = ()

    @_f.addMelDocs('softMod', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'after', val)

    @_f.addMelDocs('softMod', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'afterReference', val)

    @_f.addMelDocs('softMod', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'before', val)

    @_f.addMelDocs('softMod', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('softMod', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.softMod, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('softMod', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.softMod, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('softMod', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.softMod, kwargs, 'geometry')
        return res

    @_f.addMelDocs('softMod', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.softMod, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('softMod', 'weightedNode')
    def getWeightedNode(self, **kwargs):
        res = _f.asQuery(self, animation.softMod, kwargs, 'weightedNode')
        return res

    @_f.addMelDocs('softMod', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'parallel', val)

    @_f.addMelDocs('softMod', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'prune', val)

    @_f.addMelDocs('softMod', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'remove', val)

    @_f.addMelDocs('softMod', 'resetGeometry')
    def resetGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'resetGeometry', val)

    @_f.addMelDocs('softMod', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'geometry', val)

    @_f.addMelDocs('softMod', 'weightedNode')
    def setWeightedNode(self, val=True, **kwargs):
        return _f.asEdit(self, animation.softMod, kwargs, 'weightedNode', val)


class TextureDeformer(WeightGeometryFilter):
    __melcmd__ = staticmethod(animation.textureDeformer)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'textureDeformer'
    __melnode__ = u'textureDeformer'
    __slots__ = ()

    @_f.addMelDocs('textureDeformer', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.textureDeformer, kwargs, 'after', val)

    @_f.addMelDocs('textureDeformer', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.textureDeformer, kwargs, 'afterReference', val)

    @_f.addMelDocs('textureDeformer', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.textureDeformer, kwargs, 'before', val)

    @_f.addMelDocs('textureDeformer', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.textureDeformer, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('textureDeformer', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.textureDeformer, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('textureDeformer', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.textureDeformer, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('textureDeformer', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.textureDeformer, kwargs, 'geometry')
        return res

    @_f.addMelDocs('textureDeformer', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.textureDeformer, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('textureDeformer', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.textureDeformer, kwargs, 'parallel', val)

    @_f.addMelDocs('textureDeformer', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.textureDeformer, kwargs, 'prune', val)

    @_f.addMelDocs('textureDeformer', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.textureDeformer, kwargs, 'remove', val)

    @_f.addMelDocs('textureDeformer', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.textureDeformer, kwargs, 'geometry', val)


class Jiggle(WeightGeometryFilter):
    __melnode__ = u'jiggle'
    __slots__ = ()


class THdeformer(WeightGeometryFilter):
    __melnode__ = u'THdeformer'
    __slots__ = ()


class BlendShape(GeometryFilter):
    __apicls__ = _api.MFnBlendShapeDeformer
    __melcmd__ = staticmethod(animation.blendShape)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'blendShape'
    __melnode__ = u'blendShape'
    __slots__ = ()
    HistoryLocation = Enum('HistoryLocation', {'frontOfChain': 0, 'kFrontOfChain': 0, 'normal': 1, 'kNormal': 1, 'kPost': 2, 'post': 2, 'kOther': 3, 'other': 3}, multiKeys=True, defaultKeys={0: 'frontOfChain', 1: 'normal', 2: 'post', 3: 'other'})
    Origin = Enum('Origin', {'localOrigin': 0, 'kLocalOrigin': 0, 'worldOrigin': 1, 'kWorldOrigin': 1}, multiKeys=True, defaultKeys={0: 'localOrigin', 1: 'worldOrigin'})
    TargetType = Enum('TargetType', {'object': 0, 'kObject': 0, 'kTangent': 1, 'tangent': 1}, multiKeys=True, defaultKeys={0: 'object', 1: 'tangent'})

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'addBaseObject')
    def addBaseObject(self, object):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([object], [('object', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'addBaseObject', final_do)
        return res

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'addTarget')
    def addTarget(self, baseObject, weightIndex, newTarget, fullWeight, targetType='object'):
        # type: (general.PyNode, int, general.PyNode, float, BlendShapeDeformer.TargetType) -> None
        do, final_do, outTypes = _f.getDoArgs([baseObject, weightIndex, newTarget, fullWeight, targetType], [('baseObject', 'MObject', 'in', None), ('weightIndex', 'int', 'in', None), ('newTarget', 'MObject', 'in', None), ('fullWeight', 'double', 'in', None), ('targetType', ('MFnBlendShapeDeformer', 'TargetType'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'addTarget', final_do)
        return res

    @_f.addMelDocs('blendShape', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'after', val)

    @_f.addMelDocs('blendShape', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'afterReference', val)

    @_f.addMelDocs('blendShape', 'automatic')
    def automatic(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'automatic', val)

    @_f.addMelDocs('blendShape', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'before', val)

    @_f.addMelDocs('blendShape', 'copyDelta')
    def copyDelta(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'copyDelta', val)

    @_f.addMelDocs('blendShape', 'copyInBetweenDelta')
    def copyInBetweenDelta(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'copyInBetweenDelta', val)

    @_f.addMelDocs('blendShape', 'export')
    def export(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'export', val)

    @_f.addMelDocs('blendShape', 'exportTarget')
    def exportTarget(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'exportTarget', val)

    @_f.addMelDocs('blendShape', 'flipTarget')
    def flipTarget(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'flipTarget', val)

    @_f.addMelDocs('blendShape', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'frontOfChain', val)

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'getBaseObjects')
    def getBaseObjects(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('objects', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'getBaseObjects', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('blendShape', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('blendShape', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('blendShape', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'geometry')
        return res

    @_f.addMelDocs('blendShape', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('blendShape', 'normalizationGroups')
    def getNormalizationGroups(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'normalizationGroups')
        return res

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'origin')
    def getOrigin(self):
        # type: () -> BlendShapeDeformer.Origin
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'origin')
        return _f.ApiArgUtil._castResult(self, res, ('MFnBlendShapeDeformer', 'Origin'), None)

    @_f.addMelDocs('blendShape', 'symmetryAxis')
    def getSymmetryAxis(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'symmetryAxis')
        return res

    @_f.addMelDocs('blendShape', 'symmetryEdge')
    def getSymmetryEdge(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'symmetryEdge')
        return res

    @_f.addMelDocs('blendShape', 'symmetrySpace')
    def getSymmetrySpace(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'symmetrySpace')
        return res

    @_f.addMelDocs('blendShape', 'target')
    def getTarget(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'target')
        return res

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'getTargets')
    def getTargets(self, baseObject, weightIndex):
        # type: (general.PyNode, int) -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([baseObject, weightIndex], [('baseObject', 'MObject', 'in', None), ('weightIndex', 'int', 'in', None), ('targetObjects', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'getTargets', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('blendShape', 'transform')
    def getTransform(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'transform')
        return res

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'weight')
    def getWeight(self, index):
        # type: (int) -> float
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'weight', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'float', None)
        return res

    @_f.addMelDocs('blendShape', 'weightCount')
    def getWeightCount(self, **kwargs):
        res = _f.asQuery(self, animation.blendShape, kwargs, 'weightCount')
        return res

    @_f.addMelDocs('blendShape', 'inBetween')
    def inBetween(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'inBetween', val)

    @_f.addMelDocs('blendShape', 'inBetweenIndex')
    def inBetweenIndex(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'inBetweenIndex', val)

    @_f.addMelDocs('blendShape', 'inBetweenType')
    def inBetweenType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'inBetweenType', val)

    @_f.addMelDocs('blendShape', 'ip')
    def ip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'ip', val)

    @_f.addMelDocs('blendShape', 'mergeSource')
    def mergeSource(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'mergeSource', val)

    @_f.addMelDocs('blendShape', 'mergeTarget')
    def mergeTarget(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'mergeTarget', val)

    @_f.addMelDocs('blendShape', 'mirrorDirection')
    def mirrorDirection(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'mirrorDirection', val)

    @_f.addMelDocs('blendShape', 'mirrorTarget')
    def mirrorTarget(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'mirrorTarget', val)

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'numWeights')
    def numWeights(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'numWeights')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('blendShape', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'parallel', val)

    @_f.addMelDocs('blendShape', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'prune', val)

    @_f.addMelDocs('blendShape', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'remove', val)

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'removeTarget')
    def removeTarget(self, baseObject, weightIndex, target, fullWeight):
        # type: (general.PyNode, int, general.PyNode, float) -> None
        do, final_do, outTypes = _f.getDoArgs([baseObject, weightIndex, target, fullWeight], [('baseObject', 'MObject', 'in', None), ('weightIndex', 'int', 'in', None), ('target', 'MObject', 'in', None), ('fullWeight', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'removeTarget', final_do)
        return res

    @_f.addMelDocs('blendShape', 'resetTargetDelta')
    def resetTargetDelta(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'resetTargetDelta', val)

    @_f.addMelDocs('blendShape', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'geometry', val)

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'setOrigin')
    def setOrigin(self, space):
        # type: (BlendShapeDeformer.Origin) -> None
        do, final_do, outTypes = _f.processApiArgs([space], [('space', ('MFnBlendShapeDeformer', 'Origin'), 'in', None)], self.getOrigin, self.setOrigin, [])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'setOrigin', final_do)
        return res

    @_f.addMelDocs('blendShape', 'symmetryAxis')
    def setSymmetryAxis(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'symmetryAxis', val)

    @_f.addMelDocs('blendShape', 'symmetryEdge')
    def setSymmetryEdge(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'symmetryEdge', val)

    @_f.addMelDocs('blendShape', 'symmetrySpace')
    def setSymmetrySpace(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'symmetrySpace', val)

    @_f.addMelDocs('blendShape', 'target')
    def setTarget(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'target', val)

    @_f.addMelDocs('blendShape', 'transform')
    def setTransform(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'transform', val)

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'setWeight')
    def setWeight(self, index, weight):
        # type: (int, float) -> None
        do, final_do, outTypes = _f.processApiArgs([index, weight], [('index', 'uint', 'in', None), ('weight', 'float', 'in', None)], self.getWeight, self.setWeight, ['index'])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'setWeight', final_do)
        return res

    @_f.addMelDocs('blendShape', 'weightCount')
    def setWeightCount(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'weightCount', val)

    @_f.addMelDocs('blendShape', 'tangentSpace')
    def tangentSpace(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendShape, kwargs, 'tangentSpace', val)

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'targetItemIndexList')
    def targetItemIndexList(self, weightIndex, baseObject):
        # type: (int, general.PyNode) -> List[int]
        do, final_do, outTypes = _f.getDoArgs([weightIndex, baseObject], [('weightIndex', 'uint', 'in', None), ('baseObject', 'MObject', 'in', None), ('targetItemIndices', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'targetItemIndexList', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnBlendShapeDeformer, 'weightIndexList')
    def weightIndexList(self):
        # type: () -> List[int]
        do, final_do, outTypes = _f.getDoArgs([], [('indexList', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnBlendShapeDeformer, 'weightIndexList', final_do)
        return _f.processApiResult(res, outTypes, do)


class THblendShape(BlendShape):
    __melnode__ = u'THblendShape'
    __slots__ = ()


class Sculpt(GeometryFilter):
    __melcmd__ = staticmethod(animation.sculpt)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'sculpt'
    __melnode__ = u'sculpt'
    __slots__ = ()

    @_f.addMelDocs('sculpt', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'after', val)

    @_f.addMelDocs('sculpt', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'afterReference', val)

    @_f.addMelDocs('sculpt', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'before', val)

    @_f.addMelDocs('sculpt', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('sculpt', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('sculpt', 'dropoffDistance')
    def getDropoffDistance(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'dropoffDistance')
        return res

    @_f.addMelDocs('sculpt', 'dropoffType')
    def getDropoffType(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'dropoffType')
        return res

    @_f.addMelDocs('sculpt', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('sculpt', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'geometry')
        return res

    @_f.addMelDocs('sculpt', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('sculpt', 'insideMode')
    def getInsideMode(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'insideMode')
        return res

    @_f.addMelDocs('sculpt', 'maxDisplacement')
    def getMaxDisplacement(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'maxDisplacement')
        return res

    @_f.addMelDocs('sculpt', 'mode')
    def getMode(self, **kwargs):
        res = _f.asQuery(self, animation.sculpt, kwargs, 'mode')
        return res

    @_f.addMelDocs('sculpt', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'parallel', val)

    @_f.addMelDocs('sculpt', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'prune', val)

    @_f.addMelDocs('sculpt', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'remove', val)

    @_f.addMelDocs('sculpt', 'dropoffDistance')
    def setDropoffDistance(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'dropoffDistance', val)

    @_f.addMelDocs('sculpt', 'dropoffType')
    def setDropoffType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'dropoffType', val)

    @_f.addMelDocs('sculpt', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'geometry', val)

    @_f.addMelDocs('sculpt', 'insideMode')
    def setInsideMode(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'insideMode', val)

    @_f.addMelDocs('sculpt', 'maxDisplacement')
    def setMaxDisplacement(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'maxDisplacement', val)

    @_f.addMelDocs('sculpt', 'mode')
    def setMode(self, val=True, **kwargs):
        return _f.asEdit(self, animation.sculpt, kwargs, 'mode', val)


class HistorySwitch(GeometryFilter):
    __melnode__ = u'historySwitch'
    __slots__ = ()


class THgeometryFilter(GeometryFilter):
    __melnode__ = u'THgeometryFilter'
    __slots__ = ()


class Wrap(GeometryFilter):
    __melnode__ = u'wrap'
    __slots__ = ()


class JointLattice(GeometryFilter):
    __melcmd__ = staticmethod(animation.jointLattice)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'jointLattice'
    __melnode__ = u'jointLattice'
    __slots__ = ()

    @_f.addMelDocs('jointLattice', 'after')
    def after(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'after', val)

    @_f.addMelDocs('jointLattice', 'afterReference')
    def afterReference(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'afterReference', val)

    @_f.addMelDocs('jointLattice', 'before')
    def before(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'before', val)

    @_f.addMelDocs('jointLattice', 'frontOfChain')
    def frontOfChain(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'frontOfChain', val)

    @_f.addMelDocs('jointLattice', 'creasing')
    def getCreasing(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'creasing')
        return res

    @_f.addMelDocs('jointLattice', 'deformerTools')
    def getDeformerTools(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'deformerTools')
        return res

    @_f.addMelDocs('jointLattice', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('jointLattice', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'geometry')
        return res

    @_f.addMelDocs('jointLattice', 'geometryIndices')
    def getGeometryIndices(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'geometryIndices')
        return res

    @_f.addMelDocs('jointLattice', 'lengthIn')
    def getLengthIn(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'lengthIn')
        return res

    @_f.addMelDocs('jointLattice', 'lengthOut')
    def getLengthOut(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'lengthOut')
        return res

    @_f.addMelDocs('jointLattice', 'rounding')
    def getRounding(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'rounding')
        return res

    @_f.addMelDocs('jointLattice', 'widthLeft')
    def getWidthLeft(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'widthLeft')
        return res

    @_f.addMelDocs('jointLattice', 'widthRight')
    def getWidthRight(self, **kwargs):
        res = _f.asQuery(self, animation.jointLattice, kwargs, 'widthRight')
        return res

    @_f.addMelDocs('jointLattice', 'parallel')
    def parallel(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'parallel', val)

    @_f.addMelDocs('jointLattice', 'prune')
    def prune(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'prune', val)

    @_f.addMelDocs('jointLattice', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'remove', val)

    @_f.addMelDocs('jointLattice', 'creasing')
    def setCreasing(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'creasing', val)

    @_f.addMelDocs('jointLattice', 'geometry')
    def setGeometry(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'geometry', val)

    @_f.addMelDocs('jointLattice', 'lengthIn')
    def setLengthIn(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'lengthIn', val)

    @_f.addMelDocs('jointLattice', 'lengthOut')
    def setLengthOut(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'lengthOut', val)

    @_f.addMelDocs('jointLattice', 'rounding')
    def setRounding(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'rounding', val)

    @_f.addMelDocs('jointLattice', 'widthLeft')
    def setWidthLeft(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'widthLeft', val)

    @_f.addMelDocs('jointLattice', 'widthRight')
    def setWidthRight(self, val=True, **kwargs):
        return _f.asEdit(self, animation.jointLattice, kwargs, 'widthRight', val)


class AddDoubleLinear(DependNode):
    __melnode__ = u'addDoubleLinear'
    __slots__ = ()


class FrameCache(DependNode):
    __melnode__ = u'frameCache'
    __slots__ = ()


class Facade(DependNode):
    __melnode__ = u'facade'
    __slots__ = ()


class MaterialFacade(Facade):
    __melnode__ = u'materialFacade'
    __slots__ = ()


class EnvFacade(Facade):
    __melnode__ = u'envFacade'
    __slots__ = ()


class AISEnvFacade(EnvFacade):
    __melnode__ = u'AISEnvFacade'
    __slots__ = ()


class ImageSource(DependNode):
    __apicls__ = _api.MFnImageSource
    __melnode__ = u'imageSource'
    __slots__ = ()


class RenderedImageSource(ImageSource):
    __melnode__ = u'renderedImageSource'
    __slots__ = ()


class RenderTarget(ImageSource):
    __melnode__ = u'renderTarget'
    __slots__ = ()


class RenderPass(ImageSource):
    __apicls__ = _api.MFnRenderPass
    __melnode__ = u'renderPass'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnRenderPass, 'customTokenString')
    def customTokenString(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnRenderPass, 'customTokenString')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.addApiDocs(_api.MFnRenderPass, 'frameBufferChannels')
    def frameBufferChannels(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnRenderPass, 'frameBufferChannels')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnRenderPass, 'passID')
    def passID(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnRenderPass, 'passID')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.addApiDocs(_api.MFnRenderPass, 'usesFiltering')
    def usesFiltering(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnRenderPass, 'usesFiltering')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)


class RemapColor(DependNode):
    __melnode__ = u'remapColor'
    __slots__ = ()


class TimeEditorTracks(DependNode):
    __melcmd__ = staticmethod(animation.timeEditorTracks)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'timeEditorTracks'
    __melnode__ = u'timeEditorTracks'
    __slots__ = ()

    @_f.addMelDocs('timeEditorTracks', 'addTrack')
    def addTrack(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'addTrack', val)

    @_f.addMelDocs('timeEditorTracks', 'activeClipWeight')
    def getActiveClipWeight(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'activeClipWeight')
        return res

    @_f.addMelDocs('timeEditorTracks', 'activeClipWeightId')
    def getActiveClipWeightId(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'activeClipWeightId')
        return res

    @_f.addMelDocs('timeEditorTracks', 'allClips')
    def getAllClips(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'allClips')
        return res

    @_f.addMelDocs('timeEditorTracks', 'allTracks')
    def getAllTracks(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'allTracks')
        return res

    @_f.addMelDocs('timeEditorTracks', 'allTracksRecursive')
    def getAllTracksRecursive(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'allTracksRecursive')
        return res

    @_f.addMelDocs('timeEditorTracks', 'composition')
    def getComposition(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'composition')
        return res

    @_f.addMelDocs('timeEditorTracks', 'plugIndex')
    def getPlugIndex(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'plugIndex')
        return res

    @_f.addMelDocs('timeEditorTracks', 'selectedTracks')
    def getSelectedTracks(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'selectedTracks')
        return res

    @_f.addMelDocs('timeEditorTracks', 'trackGhost')
    def getTrackGhost(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'trackGhost')
        return res

    @_f.addMelDocs('timeEditorTracks', 'trackIndex')
    def getTrackIndex(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'trackIndex')
        return res

    @_f.addMelDocs('timeEditorTracks', 'trackMuted')
    def getTrackMuted(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'trackMuted')
        return res

    @_f.addMelDocs('timeEditorTracks', 'trackName')
    def getTrackName(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'trackName')
        return res

    @_f.addMelDocs('timeEditorTracks', 'trackSolo')
    def getTrackSolo(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'trackSolo')
        return res

    @_f.addMelDocs('timeEditorTracks', 'trackType')
    def getTrackType(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorTracks, kwargs, 'trackType')
        return res

    @_f.addMelDocs('timeEditorTracks', 'path')
    def path(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'path', val)

    @_f.addMelDocs('timeEditorTracks', 'removeTrack')
    def removeTrack(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'removeTrack', val)

    @_f.addMelDocs('timeEditorTracks', 'removeTrackByPath')
    def removeTrackByPath(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'removeTrackByPath', val)

    @_f.addMelDocs('timeEditorTracks', 'reorderTrack')
    def reorderTrack(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'reorderTrack', val)

    @_f.addMelDocs('timeEditorTracks', 'plugIndex')
    def setPlugIndex(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'plugIndex', val)

    @_f.addMelDocs('timeEditorTracks', 'trackGhost')
    def setTrackGhost(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'trackGhost', val)

    @_f.addMelDocs('timeEditorTracks', 'trackIndex')
    def setTrackIndex(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'trackIndex', val)

    @_f.addMelDocs('timeEditorTracks', 'trackMuted')
    def setTrackMuted(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'trackMuted', val)

    @_f.addMelDocs('timeEditorTracks', 'trackName')
    def setTrackName(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'trackName', val)

    @_f.addMelDocs('timeEditorTracks', 'trackSolo')
    def setTrackSolo(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'trackSolo', val)

    @_f.addMelDocs('timeEditorTracks', 'trackType')
    def setTrackType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorTracks, kwargs, 'trackType', val)


class ClosestPointOnMesh(DependNode):
    __melnode__ = u'closestPointOnMesh'
    __slots__ = ()


class MultDoubleLinear(DependNode):
    __melnode__ = u'multDoubleLinear'
    __slots__ = ()


class TimeEditorInterpolator(DependNode):
    __melnode__ = u'timeEditorInterpolator'
    __slots__ = ()


class HyperLayout(DependNode):
    __melnode__ = u'hyperLayout'
    __slots__ = ()


class PassMatrix(DependNode):
    __melnode__ = u'passMatrix'
    __slots__ = ()


class Mute(DependNode):
    __melcmd__ = staticmethod(animation.mute)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'mute'
    __melnode__ = u'mute'
    __slots__ = ()


class PolyToSubdiv(DependNode):
    __melcmd__ = staticmethod(modeling.polyToSubdiv)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyToSubdiv'
    __melnode__ = u'polyToSubdiv'
    __slots__ = ()

    @_f.addMelDocs('polyToSubdiv', 'absolutePosition')
    def getAbsolutePosition(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'absolutePosition')
        return res

    @_f.addMelDocs('polyToSubdiv', 'applyMatrixToResult')
    def getApplyMatrixToResult(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'applyMatrixToResult')
        return res

    @_f.addMelDocs('polyToSubdiv', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyToSubdiv', 'maxEdgesPerVert')
    def getMaxEdgesPerVert(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'maxEdgesPerVert')
        return res

    @_f.addMelDocs('polyToSubdiv', 'maxPolyCount')
    def getMaxPolyCount(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'maxPolyCount')
        return res

    @_f.addMelDocs('polyToSubdiv', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyToSubdiv', 'preserveVertexOrdering')
    def getPreserveVertexOrdering(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'preserveVertexOrdering')
        return res

    @_f.addMelDocs('polyToSubdiv', 'quickConvert')
    def getQuickConvert(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'quickConvert')
        return res

    @_f.addMelDocs('polyToSubdiv', 'uvPoints')
    def getUvPoints(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'uvPoints')
        return res

    @_f.addMelDocs('polyToSubdiv', 'uvPointsU')
    def getUvPointsU(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'uvPointsU')
        return res

    @_f.addMelDocs('polyToSubdiv', 'uvPointsV')
    def getUvPointsV(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'uvPointsV')
        return res

    @_f.addMelDocs('polyToSubdiv', 'uvTreatment')
    def getUvTreatment(self, **kwargs):
        res = _f.asQuery(self, modeling.polyToSubdiv, kwargs, 'uvTreatment')
        return res

    @_f.addMelDocs('polyToSubdiv', 'absolutePosition')
    def setAbsolutePosition(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'absolutePosition', val)

    @_f.addMelDocs('polyToSubdiv', 'applyMatrixToResult')
    def setApplyMatrixToResult(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'applyMatrixToResult', val)

    @_f.addMelDocs('polyToSubdiv', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'caching', val)

    @_f.addMelDocs('polyToSubdiv', 'maxEdgesPerVert')
    def setMaxEdgesPerVert(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'maxEdgesPerVert', val)

    @_f.addMelDocs('polyToSubdiv', 'maxPolyCount')
    def setMaxPolyCount(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'maxPolyCount', val)

    @_f.addMelDocs('polyToSubdiv', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyToSubdiv', 'preserveVertexOrdering')
    def setPreserveVertexOrdering(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'preserveVertexOrdering', val)

    @_f.addMelDocs('polyToSubdiv', 'quickConvert')
    def setQuickConvert(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'quickConvert', val)

    @_f.addMelDocs('polyToSubdiv', 'uvPoints')
    def setUvPoints(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'uvPoints', val)

    @_f.addMelDocs('polyToSubdiv', 'uvPointsU')
    def setUvPointsU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'uvPointsU', val)

    @_f.addMelDocs('polyToSubdiv', 'uvPointsV')
    def setUvPointsV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'uvPointsV', val)

    @_f.addMelDocs('polyToSubdiv', 'uvTreatment')
    def setUvTreatment(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyToSubdiv, kwargs, 'uvTreatment', val)


class CacheBase(DependNode):
    __melnode__ = u'cacheBase'
    __slots__ = ()


class CacheBlend(CacheBase):
    __melnode__ = u'cacheBlend'
    __slots__ = ()


class CacheFile(CacheBase):
    __melcmd__ = staticmethod(system.cacheFile)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'cacheFile'
    __melnode__ = u'cacheFile'
    __slots__ = ()

    @_f.addMelDocs('cacheFile', 'cacheFormat')
    def getCacheFormat(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'cacheFormat')
        return res

    @_f.addMelDocs('cacheFile', 'cacheInfo')
    def getCacheInfo(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'cacheInfo')
        return res

    @_f.addMelDocs('cacheFile', 'cacheableAttrs')
    def getCacheableAttrs(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'cacheableAttrs')
        return res

    @_f.addMelDocs('cacheFile', 'channelIndex')
    def getChannelIndex(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'channelIndex')
        return res

    @_f.addMelDocs('cacheFile', 'channelName')
    def getChannelName(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'channelName')
        return res

    @_f.addMelDocs('cacheFile', 'dataSize')
    def getDataSize(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'dataSize')
        return res

    @_f.addMelDocs('cacheFile', 'descriptionFileName')
    def getDescriptionFileName(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'descriptionFileName')
        return res

    @_f.addMelDocs('cacheFile', 'directory')
    def getDirectory(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'directory')
        return res

    @_f.addMelDocs('cacheFile', 'fileName')
    def getFileName(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'fileName')
        return res

    @_f.addMelDocs('cacheFile', 'geometry')
    def getGeometry(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'geometry')
        return res

    @_f.addMelDocs('cacheFile', 'pointCount')
    def getPointCount(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'pointCount')
        return res

    @_f.addMelDocs('cacheFile', 'runupFrames')
    def getRunupFrames(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'runupFrames')
        return res

    @_f.addMelDocs('cacheFile', 'sampleMultiplier')
    def getSampleMultiplier(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'sampleMultiplier')
        return res

    @_f.addMelDocs('cacheFile', 'simulationRate')
    def getSimulationRate(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'simulationRate')
        return res

    @_f.addMelDocs('cacheFile', 'staticCache')
    def getStaticCache(self, **kwargs):
        res = _f.asQuery(self, system.cacheFile, kwargs, 'staticCache')
        return res

    @_f.addMelDocs('cacheFile', 'replaceWithoutSimulating')
    def replaceWithoutSimulating(self, val=True, **kwargs):
        return _f.asEdit(self, system.cacheFile, kwargs, 'replaceWithoutSimulating', val)

    @_f.addMelDocs('cacheFile', 'runupFrames')
    def setRunupFrames(self, val=True, **kwargs):
        return _f.asEdit(self, system.cacheFile, kwargs, 'runupFrames', val)

    @_f.addMelDocs('cacheFile', 'sampleMultiplier')
    def setSampleMultiplier(self, val=True, **kwargs):
        return _f.asEdit(self, system.cacheFile, kwargs, 'sampleMultiplier', val)

    @_f.addMelDocs('cacheFile', 'simulationRate')
    def setSimulationRate(self, val=True, **kwargs):
        return _f.asEdit(self, system.cacheFile, kwargs, 'simulationRate', val)


class PolyBase(DependNode):
    __melnode__ = u'polyBase'
    __slots__ = ()


class PolyModifier(PolyBase):
    __melnode__ = u'polyModifier'
    __slots__ = ()


class PolyAppend(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyAppend)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyAppend'
    __melnode__ = u'polyAppend'
    __slots__ = ()

    @_f.addMelDocs('polyAppend', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAppend, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyAppend', 'subdivision')
    def getSubdivision(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAppend, kwargs, 'subdivision')
        return res

    @_f.addMelDocs('polyAppend', 'texture')
    def getTexture(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAppend, kwargs, 'texture')
        return res

    @_f.addMelDocs('polyAppend', 'subdivision')
    def setSubdivision(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyAppend, kwargs, 'subdivision', val)

    @_f.addMelDocs('polyAppend', 'texture')
    def setTexture(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyAppend, kwargs, 'texture', val)


class PolyDelVertex(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyDelVertex)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyDelVertex'
    __melnode__ = u'polyDelVertex'
    __slots__ = ()

    @_f.addMelDocs('polyDelVertex', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelVertex, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyDelVertex', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelVertex, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyDelVertex', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelVertex, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyDelVertex', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDelVertex, kwargs, 'caching', val)

    @_f.addMelDocs('polyDelVertex', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDelVertex, kwargs, 'nodeState', val)


class PolySplitEdge(PolyModifier):
    __melcmd__ = staticmethod(modeling.polySplitEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySplitEdge'
    __melnode__ = u'polySplitEdge'
    __slots__ = ()

    @_f.addMelDocs('polySplitEdge', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitEdge, kwargs, 'caching')
        return res

    @_f.addMelDocs('polySplitEdge', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitEdge, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polySplitEdge', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitEdge, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polySplitEdge', 'operation')
    def getOperation(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitEdge, kwargs, 'operation')
        return res

    @_f.addMelDocs('polySplitEdge', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitEdge, kwargs, 'caching', val)

    @_f.addMelDocs('polySplitEdge', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitEdge, kwargs, 'nodeState', val)

    @_f.addMelDocs('polySplitEdge', 'operation')
    def setOperation(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitEdge, kwargs, 'operation', val)


class PolyNormal(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyNormal)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyNormal'
    __melnode__ = u'polyNormal'
    __slots__ = ()

    @_f.addMelDocs('polyNormal', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormal, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyNormal', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormal, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyNormal', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormal, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyNormal', 'normalMode')
    def getNormalMode(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormal, kwargs, 'normalMode')
        return res

    @_f.addMelDocs('polyNormal', 'userNormalMode')
    def getUserNormalMode(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormal, kwargs, 'userNormalMode')
        return res

    @_f.addMelDocs('polyNormal', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormal, kwargs, 'caching', val)

    @_f.addMelDocs('polyNormal', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormal, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyNormal', 'normalMode')
    def setNormalMode(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormal, kwargs, 'normalMode', val)

    @_f.addMelDocs('polyNormal', 'userNormalMode')
    def setUserNormalMode(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormal, kwargs, 'userNormalMode', val)


class PolyMergeFace(PolyModifier):
    __melnode__ = u'polyMergeFace'
    __slots__ = ()


class PolyColorMod(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyColorMod)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyColorMod'
    __melnode__ = u'polyColorMod'
    __slots__ = ()

    @_f.addMelDocs('polyColorMod', 'alphaScale_FloatValue')
    def getAlphaScale_FloatValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'alphaScale_FloatValue')
        return res

    @_f.addMelDocs('polyColorMod', 'alphaScale_Interp')
    def getAlphaScale_Interp(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'alphaScale_Interp')
        return res

    @_f.addMelDocs('polyColorMod', 'alphaScale_Position')
    def getAlphaScale_Position(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'alphaScale_Position')
        return res

    @_f.addMelDocs('polyColorMod', 'blueScale_FloatValue')
    def getBlueScale_FloatValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'blueScale_FloatValue')
        return res

    @_f.addMelDocs('polyColorMod', 'blueScale_Interp')
    def getBlueScale_Interp(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'blueScale_Interp')
        return res

    @_f.addMelDocs('polyColorMod', 'blueScale_Position')
    def getBlueScale_Position(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'blueScale_Position')
        return res

    @_f.addMelDocs('polyColorMod', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyColorMod', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyColorMod', 'greenScale_FloatValue')
    def getGreenScale_FloatValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'greenScale_FloatValue')
        return res

    @_f.addMelDocs('polyColorMod', 'greenScale_Interp')
    def getGreenScale_Interp(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'greenScale_Interp')
        return res

    @_f.addMelDocs('polyColorMod', 'greenScale_Position')
    def getGreenScale_Position(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'greenScale_Position')
        return res

    @_f.addMelDocs('polyColorMod', 'huev')
    def getHuev(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'huev')
        return res

    @_f.addMelDocs('polyColorMod', 'intensityScale_FloatValue')
    def getIntensityScale_FloatValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'intensityScale_FloatValue')
        return res

    @_f.addMelDocs('polyColorMod', 'intensityScale_Interp')
    def getIntensityScale_Interp(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'intensityScale_Interp')
        return res

    @_f.addMelDocs('polyColorMod', 'intensityScale_Position')
    def getIntensityScale_Position(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'intensityScale_Position')
        return res

    @_f.addMelDocs('polyColorMod', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyColorMod', 'redScale_FloatValue')
    def getRedScale_FloatValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'redScale_FloatValue')
        return res

    @_f.addMelDocs('polyColorMod', 'redScale_Interp')
    def getRedScale_Interp(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'redScale_Interp')
        return res

    @_f.addMelDocs('polyColorMod', 'redScale_Position')
    def getRedScale_Position(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'redScale_Position')
        return res

    @_f.addMelDocs('polyColorMod', 'satv')
    def getSatv(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'satv')
        return res

    @_f.addMelDocs('polyColorMod', 'value')
    def getValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorMod, kwargs, 'value')
        return res

    @_f.addMelDocs('polyColorMod', 'alphaScale_FloatValue')
    def setAlphaScale_FloatValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'alphaScale_FloatValue', val)

    @_f.addMelDocs('polyColorMod', 'alphaScale_Interp')
    def setAlphaScale_Interp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'alphaScale_Interp', val)

    @_f.addMelDocs('polyColorMod', 'alphaScale_Position')
    def setAlphaScale_Position(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'alphaScale_Position', val)

    @_f.addMelDocs('polyColorMod', 'blueScale_FloatValue')
    def setBlueScale_FloatValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'blueScale_FloatValue', val)

    @_f.addMelDocs('polyColorMod', 'blueScale_Interp')
    def setBlueScale_Interp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'blueScale_Interp', val)

    @_f.addMelDocs('polyColorMod', 'blueScale_Position')
    def setBlueScale_Position(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'blueScale_Position', val)

    @_f.addMelDocs('polyColorMod', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'caching', val)

    @_f.addMelDocs('polyColorMod', 'greenScale_FloatValue')
    def setGreenScale_FloatValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'greenScale_FloatValue', val)

    @_f.addMelDocs('polyColorMod', 'greenScale_Interp')
    def setGreenScale_Interp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'greenScale_Interp', val)

    @_f.addMelDocs('polyColorMod', 'greenScale_Position')
    def setGreenScale_Position(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'greenScale_Position', val)

    @_f.addMelDocs('polyColorMod', 'huev')
    def setHuev(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'huev', val)

    @_f.addMelDocs('polyColorMod', 'intensityScale_FloatValue')
    def setIntensityScale_FloatValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'intensityScale_FloatValue', val)

    @_f.addMelDocs('polyColorMod', 'intensityScale_Interp')
    def setIntensityScale_Interp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'intensityScale_Interp', val)

    @_f.addMelDocs('polyColorMod', 'intensityScale_Position')
    def setIntensityScale_Position(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'intensityScale_Position', val)

    @_f.addMelDocs('polyColorMod', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyColorMod', 'redScale_FloatValue')
    def setRedScale_FloatValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'redScale_FloatValue', val)

    @_f.addMelDocs('polyColorMod', 'redScale_Interp')
    def setRedScale_Interp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'redScale_Interp', val)

    @_f.addMelDocs('polyColorMod', 'redScale_Position')
    def setRedScale_Position(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'redScale_Position', val)

    @_f.addMelDocs('polyColorMod', 'satv')
    def setSatv(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'satv', val)

    @_f.addMelDocs('polyColorMod', 'value')
    def setValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorMod, kwargs, 'value', val)


class PolyMapCut(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyMapCut)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMapCut'
    __melnode__ = u'polyMapCut'
    __slots__ = ()

    @_f.addMelDocs('polyMapCut', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapCut, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyMapCut', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapCut, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyMapCut', 'moveratio')
    def getMoveratio(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapCut, kwargs, 'moveratio')
        return res

    @_f.addMelDocs('polyMapCut', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapCut, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyMapCut', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapCut, kwargs, 'caching', val)

    @_f.addMelDocs('polyMapCut', 'moveratio')
    def setMoveratio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapCut, kwargs, 'moveratio', val)

    @_f.addMelDocs('polyMapCut', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapCut, kwargs, 'nodeState', val)


class PolyTweak(PolyModifier):
    __melnode__ = u'polyTweak'
    __slots__ = ()


class PolySmoothFace(PolyModifier):
    __melnode__ = u'polySmoothFace'
    __slots__ = ()


class PolyMapDel(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyMapDel)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMapDel'
    __melnode__ = u'polyMapDel'
    __slots__ = ()

    @_f.addMelDocs('polyMapDel', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapDel, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyMapDel', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapDel, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyMapDel', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapDel, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyMapDel', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapDel, kwargs, 'caching', val)

    @_f.addMelDocs('polyMapDel', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapDel, kwargs, 'nodeState', val)


class PolyClean(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyClean)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyClean'
    __melnode__ = u'polyClean'
    __slots__ = ()

    @_f.addMelDocs('polyClean', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyClean, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyClean', 'cleanEdges')
    def getCleanEdges(self, **kwargs):
        res = _f.asQuery(self, modeling.polyClean, kwargs, 'cleanEdges')
        return res

    @_f.addMelDocs('polyClean', 'cleanPartialUVMapping')
    def getCleanPartialUVMapping(self, **kwargs):
        res = _f.asQuery(self, modeling.polyClean, kwargs, 'cleanPartialUVMapping')
        return res

    @_f.addMelDocs('polyClean', 'cleanUVs')
    def getCleanUVs(self, **kwargs):
        res = _f.asQuery(self, modeling.polyClean, kwargs, 'cleanUVs')
        return res

    @_f.addMelDocs('polyClean', 'cleanVertices')
    def getCleanVertices(self, **kwargs):
        res = _f.asQuery(self, modeling.polyClean, kwargs, 'cleanVertices')
        return res

    @_f.addMelDocs('polyClean', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyClean, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyClean', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.polyClean, kwargs, 'frozen')
        return res

    @_f.addMelDocs('polyClean', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyClean, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyClean', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyClean, kwargs, 'caching', val)

    @_f.addMelDocs('polyClean', 'cleanEdges')
    def setCleanEdges(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyClean, kwargs, 'cleanEdges', val)

    @_f.addMelDocs('polyClean', 'cleanPartialUVMapping')
    def setCleanPartialUVMapping(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyClean, kwargs, 'cleanPartialUVMapping', val)

    @_f.addMelDocs('polyClean', 'cleanUVs')
    def setCleanUVs(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyClean, kwargs, 'cleanUVs', val)

    @_f.addMelDocs('polyClean', 'cleanVertices')
    def setCleanVertices(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyClean, kwargs, 'cleanVertices', val)

    @_f.addMelDocs('polyClean', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyClean, kwargs, 'frozen', val)

    @_f.addMelDocs('polyClean', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyClean, kwargs, 'nodeState', val)


class PolyCollapseEdge(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyCollapseEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCollapseEdge'
    __melnode__ = u'polyCollapseEdge'
    __slots__ = ()

    @_f.addMelDocs('polyCollapseEdge', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCollapseEdge, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyCollapseEdge', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCollapseEdge, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyCollapseEdge', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCollapseEdge, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyCollapseEdge', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCollapseEdge, kwargs, 'caching', val)

    @_f.addMelDocs('polyCollapseEdge', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCollapseEdge, kwargs, 'nodeState', val)


class PolyColorDel(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyColorDel)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyColorDel'
    __melnode__ = u'polyColorDel'
    __slots__ = ()

    @_f.addMelDocs('polyColorDel', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorDel, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyColorDel', 'colorSetName')
    def getColorSetName(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorDel, kwargs, 'colorSetName')
        return res

    @_f.addMelDocs('polyColorDel', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorDel, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyColorDel', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorDel, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyColorDel', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorDel, kwargs, 'caching', val)

    @_f.addMelDocs('polyColorDel', 'colorSetName')
    def setColorSetName(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorDel, kwargs, 'colorSetName', val)

    @_f.addMelDocs('polyColorDel', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorDel, kwargs, 'nodeState', val)


class PolyDelEdge(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyDelEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyDelEdge'
    __melnode__ = u'polyDelEdge'
    __slots__ = ()

    @_f.addMelDocs('polyDelEdge', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelEdge, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyDelEdge', 'cleanVertices')
    def getCleanVertices(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelEdge, kwargs, 'cleanVertices')
        return res

    @_f.addMelDocs('polyDelEdge', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelEdge, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyDelEdge', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelEdge, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyDelEdge', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDelEdge, kwargs, 'caching', val)

    @_f.addMelDocs('polyDelEdge', 'cleanVertices')
    def setCleanVertices(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDelEdge, kwargs, 'cleanVertices', val)

    @_f.addMelDocs('polyDelEdge', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDelEdge, kwargs, 'nodeState', val)


class PolyUVRectangle(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyUVRectangle)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyUVRectangle'
    __melnode__ = u'polyUVRectangle'
    __slots__ = ()

    @_f.addMelDocs('polyUVRectangle', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyUVRectangle, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyUVRectangle', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyUVRectangle, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyUVRectangle', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyUVRectangle, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyUVRectangle', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyUVRectangle, kwargs, 'caching', val)

    @_f.addMelDocs('polyUVRectangle', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyUVRectangle, kwargs, 'nodeState', val)


class PolyFlipEdge(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyFlipEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyFlipEdge'
    __melnode__ = u'polyFlipEdge'
    __slots__ = ()


class PolySmoothProxy(PolyModifier):
    __melnode__ = u'polySmoothProxy'
    __slots__ = ()


class PolyTweakUV(PolyModifier):
    __melnode__ = u'polyTweakUV'
    __slots__ = ()


class PolyColorPerVertex(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyColorPerVertex)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyColorPerVertex'
    __melnode__ = u'polyColorPerVertex'
    __slots__ = ()

    @_f.addMelDocs('polyColorPerVertex', 'alpha')
    def getAlpha(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'alpha')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'clamped')
    def getClamped(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'clamped')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'colorB')
    def getColorB(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'colorB')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'colorDisplayOption')
    def getColorDisplayOption(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'colorDisplayOption')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'colorG')
    def getColorG(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'colorG')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'colorR')
    def getColorR(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'colorR')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'colorRGB')
    def getColorRGB(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'colorRGB')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'notUndoable')
    def getNotUndoable(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'notUndoable')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'relative')
    def getRelative(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'relative')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'remove')
    def getRemove(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'remove')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'representation')
    def getRepresentation(self, **kwargs):
        res = _f.asQuery(self, modeling.polyColorPerVertex, kwargs, 'representation')
        return res

    @_f.addMelDocs('polyColorPerVertex', 'alpha')
    def setAlpha(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'alpha', val)

    @_f.addMelDocs('polyColorPerVertex', 'clamped')
    def setClamped(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'clamped', val)

    @_f.addMelDocs('polyColorPerVertex', 'colorB')
    def setColorB(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'colorB', val)

    @_f.addMelDocs('polyColorPerVertex', 'colorDisplayOption')
    def setColorDisplayOption(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'colorDisplayOption', val)

    @_f.addMelDocs('polyColorPerVertex', 'colorG')
    def setColorG(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'colorG', val)

    @_f.addMelDocs('polyColorPerVertex', 'colorR')
    def setColorR(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'colorR', val)

    @_f.addMelDocs('polyColorPerVertex', 'colorRGB')
    def setColorRGB(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'colorRGB', val)

    @_f.addMelDocs('polyColorPerVertex', 'notUndoable')
    def setNotUndoable(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'notUndoable', val)

    @_f.addMelDocs('polyColorPerVertex', 'relative')
    def setRelative(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'relative', val)

    @_f.addMelDocs('polyColorPerVertex', 'remove')
    def setRemove(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'remove', val)

    @_f.addMelDocs('polyColorPerVertex', 'representation')
    def setRepresentation(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyColorPerVertex, kwargs, 'representation', val)


class PolyReduce(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyReduce)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyReduce'
    __melnode__ = u'polyReduce'
    __slots__ = ()

    @_f.addMelDocs('polyReduce', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyReduce', 'cachingReduce')
    def getCachingReduce(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'cachingReduce')
        return res

    @_f.addMelDocs('polyReduce', 'colorWeights')
    def getColorWeights(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'colorWeights')
        return res

    @_f.addMelDocs('polyReduce', 'compactness')
    def getCompactness(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'compactness')
        return res

    @_f.addMelDocs('polyReduce', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyReduce', 'geomWeights')
    def getGeomWeights(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'geomWeights')
        return res

    @_f.addMelDocs('polyReduce', 'invertVertexWeights')
    def getInvertVertexWeights(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'invertVertexWeights')
        return res

    @_f.addMelDocs('polyReduce', 'keepBorder')
    def getKeepBorder(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepBorder')
        return res

    @_f.addMelDocs('polyReduce', 'keepBorderWeight')
    def getKeepBorderWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepBorderWeight')
        return res

    @_f.addMelDocs('polyReduce', 'keepColorBorder')
    def getKeepColorBorder(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepColorBorder')
        return res

    @_f.addMelDocs('polyReduce', 'keepColorBorderWeight')
    def getKeepColorBorderWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepColorBorderWeight')
        return res

    @_f.addMelDocs('polyReduce', 'keepCreaseEdge')
    def getKeepCreaseEdge(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepCreaseEdge')
        return res

    @_f.addMelDocs('polyReduce', 'keepCreaseEdgeWeight')
    def getKeepCreaseEdgeWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepCreaseEdgeWeight')
        return res

    @_f.addMelDocs('polyReduce', 'keepFaceGroupBorder')
    def getKeepFaceGroupBorder(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepFaceGroupBorder')
        return res

    @_f.addMelDocs('polyReduce', 'keepFaceGroupBorderWeight')
    def getKeepFaceGroupBorderWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepFaceGroupBorderWeight')
        return res

    @_f.addMelDocs('polyReduce', 'keepHardEdge')
    def getKeepHardEdge(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepHardEdge')
        return res

    @_f.addMelDocs('polyReduce', 'keepHardEdgeWeight')
    def getKeepHardEdgeWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepHardEdgeWeight')
        return res

    @_f.addMelDocs('polyReduce', 'keepMapBorder')
    def getKeepMapBorder(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepMapBorder')
        return res

    @_f.addMelDocs('polyReduce', 'keepMapBorderWeight')
    def getKeepMapBorderWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepMapBorderWeight')
        return res

    @_f.addMelDocs('polyReduce', 'keepOriginalVertices')
    def getKeepOriginalVertices(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepOriginalVertices')
        return res

    @_f.addMelDocs('polyReduce', 'keepQuadsWeight')
    def getKeepQuadsWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'keepQuadsWeight')
        return res

    @_f.addMelDocs('polyReduce', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyReduce', 'percentage')
    def getPercentage(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'percentage')
        return res

    @_f.addMelDocs('polyReduce', 'preserveTopology')
    def getPreserveTopology(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'preserveTopology')
        return res

    @_f.addMelDocs('polyReduce', 'sharpness')
    def getSharpness(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'sharpness')
        return res

    @_f.addMelDocs('polyReduce', 'symmetryPlaneW')
    def getSymmetryPlaneW(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'symmetryPlaneW')
        return res

    @_f.addMelDocs('polyReduce', 'symmetryPlaneX')
    def getSymmetryPlaneX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'symmetryPlaneX')
        return res

    @_f.addMelDocs('polyReduce', 'symmetryPlaneY')
    def getSymmetryPlaneY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'symmetryPlaneY')
        return res

    @_f.addMelDocs('polyReduce', 'symmetryPlaneZ')
    def getSymmetryPlaneZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'symmetryPlaneZ')
        return res

    @_f.addMelDocs('polyReduce', 'symmetryTolerance')
    def getSymmetryTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'symmetryTolerance')
        return res

    @_f.addMelDocs('polyReduce', 'termination')
    def getTermination(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'termination')
        return res

    @_f.addMelDocs('polyReduce', 'triangleCount')
    def getTriangleCount(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'triangleCount')
        return res

    @_f.addMelDocs('polyReduce', 'triangulate')
    def getTriangulate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'triangulate')
        return res

    @_f.addMelDocs('polyReduce', 'useVirtualSymmetry')
    def getUseVirtualSymmetry(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'useVirtualSymmetry')
        return res

    @_f.addMelDocs('polyReduce', 'uvWeights')
    def getUvWeights(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'uvWeights')
        return res

    @_f.addMelDocs('polyReduce', 'version')
    def getVersion(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'version')
        return res

    @_f.addMelDocs('polyReduce', 'vertexCount')
    def getVertexCount(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'vertexCount')
        return res

    @_f.addMelDocs('polyReduce', 'vertexMapName')
    def getVertexMapName(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'vertexMapName')
        return res

    @_f.addMelDocs('polyReduce', 'vertexWeightCoefficient')
    def getVertexWeightCoefficient(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'vertexWeightCoefficient')
        return res

    @_f.addMelDocs('polyReduce', 'weightCoefficient')
    def getWeightCoefficient(self, **kwargs):
        res = _f.asQuery(self, modeling.polyReduce, kwargs, 'weightCoefficient')
        return res

    @_f.addMelDocs('polyReduce', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'caching', val)

    @_f.addMelDocs('polyReduce', 'cachingReduce')
    def setCachingReduce(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'cachingReduce', val)

    @_f.addMelDocs('polyReduce', 'colorWeights')
    def setColorWeights(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'colorWeights', val)

    @_f.addMelDocs('polyReduce', 'compactness')
    def setCompactness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'compactness', val)

    @_f.addMelDocs('polyReduce', 'geomWeights')
    def setGeomWeights(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'geomWeights', val)

    @_f.addMelDocs('polyReduce', 'invertVertexWeights')
    def setInvertVertexWeights(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'invertVertexWeights', val)

    @_f.addMelDocs('polyReduce', 'keepBorder')
    def setKeepBorder(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepBorder', val)

    @_f.addMelDocs('polyReduce', 'keepBorderWeight')
    def setKeepBorderWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepBorderWeight', val)

    @_f.addMelDocs('polyReduce', 'keepColorBorder')
    def setKeepColorBorder(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepColorBorder', val)

    @_f.addMelDocs('polyReduce', 'keepColorBorderWeight')
    def setKeepColorBorderWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepColorBorderWeight', val)

    @_f.addMelDocs('polyReduce', 'keepCreaseEdge')
    def setKeepCreaseEdge(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepCreaseEdge', val)

    @_f.addMelDocs('polyReduce', 'keepCreaseEdgeWeight')
    def setKeepCreaseEdgeWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepCreaseEdgeWeight', val)

    @_f.addMelDocs('polyReduce', 'keepFaceGroupBorder')
    def setKeepFaceGroupBorder(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepFaceGroupBorder', val)

    @_f.addMelDocs('polyReduce', 'keepFaceGroupBorderWeight')
    def setKeepFaceGroupBorderWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepFaceGroupBorderWeight', val)

    @_f.addMelDocs('polyReduce', 'keepHardEdge')
    def setKeepHardEdge(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepHardEdge', val)

    @_f.addMelDocs('polyReduce', 'keepHardEdgeWeight')
    def setKeepHardEdgeWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepHardEdgeWeight', val)

    @_f.addMelDocs('polyReduce', 'keepMapBorder')
    def setKeepMapBorder(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepMapBorder', val)

    @_f.addMelDocs('polyReduce', 'keepMapBorderWeight')
    def setKeepMapBorderWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepMapBorderWeight', val)

    @_f.addMelDocs('polyReduce', 'keepOriginalVertices')
    def setKeepOriginalVertices(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepOriginalVertices', val)

    @_f.addMelDocs('polyReduce', 'keepQuadsWeight')
    def setKeepQuadsWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'keepQuadsWeight', val)

    @_f.addMelDocs('polyReduce', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyReduce', 'percentage')
    def setPercentage(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'percentage', val)

    @_f.addMelDocs('polyReduce', 'preserveTopology')
    def setPreserveTopology(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'preserveTopology', val)

    @_f.addMelDocs('polyReduce', 'sharpness')
    def setSharpness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'sharpness', val)

    @_f.addMelDocs('polyReduce', 'symmetryPlaneW')
    def setSymmetryPlaneW(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'symmetryPlaneW', val)

    @_f.addMelDocs('polyReduce', 'symmetryPlaneX')
    def setSymmetryPlaneX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'symmetryPlaneX', val)

    @_f.addMelDocs('polyReduce', 'symmetryPlaneY')
    def setSymmetryPlaneY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'symmetryPlaneY', val)

    @_f.addMelDocs('polyReduce', 'symmetryPlaneZ')
    def setSymmetryPlaneZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'symmetryPlaneZ', val)

    @_f.addMelDocs('polyReduce', 'symmetryTolerance')
    def setSymmetryTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'symmetryTolerance', val)

    @_f.addMelDocs('polyReduce', 'termination')
    def setTermination(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'termination', val)

    @_f.addMelDocs('polyReduce', 'triangleCount')
    def setTriangleCount(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'triangleCount', val)

    @_f.addMelDocs('polyReduce', 'triangulate')
    def setTriangulate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'triangulate', val)

    @_f.addMelDocs('polyReduce', 'useVirtualSymmetry')
    def setUseVirtualSymmetry(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'useVirtualSymmetry', val)

    @_f.addMelDocs('polyReduce', 'uvWeights')
    def setUvWeights(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'uvWeights', val)

    @_f.addMelDocs('polyReduce', 'version')
    def setVersion(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'version', val)

    @_f.addMelDocs('polyReduce', 'vertexCount')
    def setVertexCount(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'vertexCount', val)

    @_f.addMelDocs('polyReduce', 'vertexWeightCoefficient')
    def setVertexWeightCoefficient(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'vertexWeightCoefficient', val)

    @_f.addMelDocs('polyReduce', 'weightCoefficient')
    def setWeightCoefficient(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyReduce, kwargs, 'weightCoefficient', val)


class PolyAppendVertex(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyAppendVertex)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyAppendVertex'
    __melnode__ = u'polyAppendVertex'
    __slots__ = ()

    @_f.addMelDocs('polyAppendVertex', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAppendVertex, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyAppendVertex', 'texture')
    def getTexture(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAppendVertex, kwargs, 'texture')
        return res

    @_f.addMelDocs('polyAppendVertex', 'texture')
    def setTexture(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyAppendVertex, kwargs, 'texture', val)


class PolyMergeEdge(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyMergeEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMergeEdge'
    __melnode__ = u'polyMergeEdge'
    __slots__ = ()

    @_f.addMelDocs('polyMergeEdge', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeEdge, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyMergeEdge', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeEdge, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyMergeEdge', 'firstEdge')
    def getFirstEdge(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeEdge, kwargs, 'firstEdge')
        return res

    @_f.addMelDocs('polyMergeEdge', 'mergeMode')
    def getMergeMode(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeEdge, kwargs, 'mergeMode')
        return res

    @_f.addMelDocs('polyMergeEdge', 'mergeTexture')
    def getMergeTexture(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeEdge, kwargs, 'mergeTexture')
        return res

    @_f.addMelDocs('polyMergeEdge', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeEdge, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyMergeEdge', 'secondEdge')
    def getSecondEdge(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeEdge, kwargs, 'secondEdge')
        return res

    @_f.addMelDocs('polyMergeEdge', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeEdge, kwargs, 'caching', val)

    @_f.addMelDocs('polyMergeEdge', 'firstEdge')
    def setFirstEdge(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeEdge, kwargs, 'firstEdge', val)

    @_f.addMelDocs('polyMergeEdge', 'mergeMode')
    def setMergeMode(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeEdge, kwargs, 'mergeMode', val)

    @_f.addMelDocs('polyMergeEdge', 'mergeTexture')
    def setMergeTexture(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeEdge, kwargs, 'mergeTexture', val)

    @_f.addMelDocs('polyMergeEdge', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeEdge, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyMergeEdge', 'secondEdge')
    def setSecondEdge(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeEdge, kwargs, 'secondEdge', val)


class PolyDuplicateEdge(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyDuplicateEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyDuplicateEdge'
    __melnode__ = u'polyDuplicateEdge'
    __slots__ = ()

    @_f.addMelDocs('polyDuplicateEdge', 'adjustEdgeFlow')
    def getAdjustEdgeFlow(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'adjustEdgeFlow')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'deleteEdge')
    def getDeleteEdge(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'deleteEdge')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'endVertexOffset')
    def getEndVertexOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'endVertexOffset')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'insertWithEdgeFlow')
    def getInsertWithEdgeFlow(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'insertWithEdgeFlow')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'smoothingAngle')
    def getSmoothingAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'smoothingAngle')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'splitType')
    def getSplitType(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'splitType')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'startVertexOffset')
    def getStartVertexOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDuplicateEdge, kwargs, 'startVertexOffset')
        return res

    @_f.addMelDocs('polyDuplicateEdge', 'adjustEdgeFlow')
    def setAdjustEdgeFlow(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'adjustEdgeFlow', val)

    @_f.addMelDocs('polyDuplicateEdge', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'caching', val)

    @_f.addMelDocs('polyDuplicateEdge', 'deleteEdge')
    def setDeleteEdge(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'deleteEdge', val)

    @_f.addMelDocs('polyDuplicateEdge', 'endVertexOffset')
    def setEndVertexOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'endVertexOffset', val)

    @_f.addMelDocs('polyDuplicateEdge', 'insertWithEdgeFlow')
    def setInsertWithEdgeFlow(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'insertWithEdgeFlow', val)

    @_f.addMelDocs('polyDuplicateEdge', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyDuplicateEdge', 'smoothingAngle')
    def setSmoothingAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'smoothingAngle', val)

    @_f.addMelDocs('polyDuplicateEdge', 'splitType')
    def setSplitType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'splitType', val)

    @_f.addMelDocs('polyDuplicateEdge', 'startVertexOffset')
    def setStartVertexOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDuplicateEdge, kwargs, 'startVertexOffset', val)


class PolySpinEdge(PolyModifier):
    __melcmd__ = staticmethod(other.polySpinEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySpinEdge'
    __melnode__ = u'polySpinEdge'
    __slots__ = ()


class PolyMoveUV(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyMoveUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMoveUV'
    __melnode__ = u'polyMoveUV'
    __slots__ = ()

    @_f.addMelDocs('polyMoveUV', 'axisLen')
    def getAxisLen(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'axisLen')
        return res

    @_f.addMelDocs('polyMoveUV', 'axisLenX')
    def getAxisLenX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'axisLenX')
        return res

    @_f.addMelDocs('polyMoveUV', 'axisLenY')
    def getAxisLenY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'axisLenY')
        return res

    @_f.addMelDocs('polyMoveUV', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyMoveUV', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyMoveUV', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyMoveUV', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'pivot')
        return res

    @_f.addMelDocs('polyMoveUV', 'pivotU')
    def getPivotU(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'pivotU')
        return res

    @_f.addMelDocs('polyMoveUV', 'pivotV')
    def getPivotV(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'pivotV')
        return res

    @_f.addMelDocs('polyMoveUV', 'random')
    def getRandom(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'random')
        return res

    @_f.addMelDocs('polyMoveUV', 'rotationAngle')
    def getRotationAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'rotationAngle')
        return res

    @_f.addMelDocs('polyMoveUV', 'scale')
    def getScale(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'scale')
        return res

    @_f.addMelDocs('polyMoveUV', 'scaleU')
    def getScaleU(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'scaleU')
        return res

    @_f.addMelDocs('polyMoveUV', 'scaleV')
    def getScaleV(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'scaleV')
        return res

    @_f.addMelDocs('polyMoveUV', 'translate')
    def getTranslate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'translate')
        return res

    @_f.addMelDocs('polyMoveUV', 'translateU')
    def getTranslateU(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'translateU')
        return res

    @_f.addMelDocs('polyMoveUV', 'translateV')
    def getTranslateV(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveUV, kwargs, 'translateV')
        return res

    @_f.addMelDocs('polyMoveUV', 'axisLen')
    def setAxisLen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'axisLen', val)

    @_f.addMelDocs('polyMoveUV', 'axisLenX')
    def setAxisLenX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'axisLenX', val)

    @_f.addMelDocs('polyMoveUV', 'axisLenY')
    def setAxisLenY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'axisLenY', val)

    @_f.addMelDocs('polyMoveUV', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'caching', val)

    @_f.addMelDocs('polyMoveUV', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyMoveUV', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'pivot', val)

    @_f.addMelDocs('polyMoveUV', 'pivotU')
    def setPivotU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'pivotU', val)

    @_f.addMelDocs('polyMoveUV', 'pivotV')
    def setPivotV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'pivotV', val)

    @_f.addMelDocs('polyMoveUV', 'random')
    def setRandom(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'random', val)

    @_f.addMelDocs('polyMoveUV', 'rotationAngle')
    def setRotationAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'rotationAngle', val)

    @_f.addMelDocs('polyMoveUV', 'scale')
    def setScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'scale', val)

    @_f.addMelDocs('polyMoveUV', 'scaleU')
    def setScaleU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'scaleU', val)

    @_f.addMelDocs('polyMoveUV', 'scaleV')
    def setScaleV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'scaleV', val)

    @_f.addMelDocs('polyMoveUV', 'translate')
    def setTranslate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'translate', val)

    @_f.addMelDocs('polyMoveUV', 'translateU')
    def setTranslateU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'translateU', val)

    @_f.addMelDocs('polyMoveUV', 'translateV')
    def setTranslateV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveUV, kwargs, 'translateV', val)


class PolyMoveFacetUV(PolyMoveUV):
    __melcmd__ = staticmethod(modeling.polyMoveFacetUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMoveFacetUV'
    __melnode__ = u'polyMoveFacetUV'
    __slots__ = ()


class BlendColorSets(PolyModifier):
    __melnode__ = u'blendColorSets'
    __slots__ = ()


class PolyMapSew(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyMapSew)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMapSew'
    __melnode__ = u'polyMapSew'
    __slots__ = ()

    @_f.addMelDocs('polyMapSew', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSew, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyMapSew', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSew, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyMapSew', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSew, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyMapSew', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapSew, kwargs, 'caching', val)

    @_f.addMelDocs('polyMapSew', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapSew, kwargs, 'nodeState', val)


class PolyCollapseF(PolyModifier):
    __melnode__ = u'polyCollapseF'
    __slots__ = ()


class PolyModifierWorld(PolyModifier):
    __melnode__ = u'polyModifierWorld'
    __slots__ = ()


class PolyProj(PolyModifierWorld):
    __melnode__ = u'polyProj'
    __slots__ = ()


class PolyMergeVert(PolyModifierWorld):
    __melnode__ = u'polyMergeVert'
    __slots__ = ()


class PolyCrease(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyCrease)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCrease'
    __melnode__ = u'polyCrease'
    __slots__ = ()

    @_f.addMelDocs('polyCrease', 'createHistory')
    def getCreateHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCrease, kwargs, 'createHistory')
        return res

    @_f.addMelDocs('polyCrease', 'operation')
    def getOperation(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCrease, kwargs, 'operation')
        return res

    @_f.addMelDocs('polyCrease', 'relativeValue')
    def getRelativeValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCrease, kwargs, 'relativeValue')
        return res

    @_f.addMelDocs('polyCrease', 'value')
    def getValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCrease, kwargs, 'value')
        return res

    @_f.addMelDocs('polyCrease', 'vertexValue')
    def getVertexValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCrease, kwargs, 'vertexValue')
        return res

    @_f.addMelDocs('polyCrease', 'createHistory')
    def setCreateHistory(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCrease, kwargs, 'createHistory', val)

    @_f.addMelDocs('polyCrease', 'operation')
    def setOperation(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCrease, kwargs, 'operation', val)

    @_f.addMelDocs('polyCrease', 'relativeValue')
    def setRelativeValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCrease, kwargs, 'relativeValue', val)

    @_f.addMelDocs('polyCrease', 'value')
    def setValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCrease, kwargs, 'value', val)

    @_f.addMelDocs('polyCrease', 'vertexValue')
    def setVertexValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCrease, kwargs, 'vertexValue', val)


class PolyCreaseEdge(PolyCrease):
    __melnode__ = u'polyCreaseEdge'
    __slots__ = ()


class PolyModifierUV(PolyModifierWorld):
    __melnode__ = u'polyModifierUV'
    __slots__ = ()


class PolyAutoProj(PolyModifierUV):
    __melnode__ = u'polyAutoProj'
    __slots__ = ()


class PolyNormalizeUV(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyNormalizeUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyNormalizeUV'
    __melnode__ = u'polyNormalizeUV'
    __slots__ = ()

    @_f.addMelDocs('polyNormalizeUV', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalizeUV, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyNormalizeUV', 'centerOnTile')
    def getCenterOnTile(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalizeUV, kwargs, 'centerOnTile')
        return res

    @_f.addMelDocs('polyNormalizeUV', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalizeUV, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyNormalizeUV', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalizeUV, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyNormalizeUV', 'normalizeDirection')
    def getNormalizeDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalizeUV, kwargs, 'normalizeDirection')
        return res

    @_f.addMelDocs('polyNormalizeUV', 'normalizeType')
    def getNormalizeType(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalizeUV, kwargs, 'normalizeType')
        return res

    @_f.addMelDocs('polyNormalizeUV', 'preserveAspectRatio')
    def getPreserveAspectRatio(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalizeUV, kwargs, 'preserveAspectRatio')
        return res

    @_f.addMelDocs('polyNormalizeUV', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalizeUV, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyNormalizeUV', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalizeUV, kwargs, 'caching', val)

    @_f.addMelDocs('polyNormalizeUV', 'centerOnTile')
    def setCenterOnTile(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalizeUV, kwargs, 'centerOnTile', val)

    @_f.addMelDocs('polyNormalizeUV', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalizeUV, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyNormalizeUV', 'normalizeDirection')
    def setNormalizeDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalizeUV, kwargs, 'normalizeDirection', val)

    @_f.addMelDocs('polyNormalizeUV', 'normalizeType')
    def setNormalizeType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalizeUV, kwargs, 'normalizeType', val)

    @_f.addMelDocs('polyNormalizeUV', 'preserveAspectRatio')
    def setPreserveAspectRatio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalizeUV, kwargs, 'preserveAspectRatio', val)

    @_f.addMelDocs('polyNormalizeUV', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalizeUV, kwargs, 'worldSpace', val)


class PolyPinUV(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyPinUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPinUV'
    __melnode__ = u'polyPinUV'
    __slots__ = ()

    @_f.addMelDocs('polyPinUV', 'createHistory')
    def getCreateHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPinUV, kwargs, 'createHistory')
        return res

    @_f.addMelDocs('polyPinUV', 'operation')
    def getOperation(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPinUV, kwargs, 'operation')
        return res

    @_f.addMelDocs('polyPinUV', 'unpinned')
    def getUnpinned(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPinUV, kwargs, 'unpinned')
        return res

    @_f.addMelDocs('polyPinUV', 'uvSetName')
    def getUvSetName(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPinUV, kwargs, 'uvSetName')
        return res

    @_f.addMelDocs('polyPinUV', 'value')
    def getValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPinUV, kwargs, 'value')
        return res

    @_f.addMelDocs('polyPinUV', 'createHistory')
    def setCreateHistory(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPinUV, kwargs, 'createHistory', val)

    @_f.addMelDocs('polyPinUV', 'operation')
    def setOperation(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPinUV, kwargs, 'operation', val)

    @_f.addMelDocs('polyPinUV', 'unpinned')
    def setUnpinned(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPinUV, kwargs, 'unpinned', val)

    @_f.addMelDocs('polyPinUV', 'uvSetName')
    def setUvSetName(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPinUV, kwargs, 'uvSetName', val)

    @_f.addMelDocs('polyPinUV', 'value')
    def setValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPinUV, kwargs, 'value', val)


class PolyLayoutUV(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyLayoutUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyLayoutUV'
    __melnode__ = u'polyLayoutUV'
    __slots__ = ()

    @_f.addMelDocs('polyLayoutUV', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyLayoutUV', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyLayoutUV', 'flipReversed')
    def getFlipReversed(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'flipReversed')
        return res

    @_f.addMelDocs('polyLayoutUV', 'layout')
    def getLayout(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'layout')
        return res

    @_f.addMelDocs('polyLayoutUV', 'layoutMethod')
    def getLayoutMethod(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'layoutMethod')
        return res

    @_f.addMelDocs('polyLayoutUV', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyLayoutUV', 'percentageSpace')
    def getPercentageSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'percentageSpace')
        return res

    @_f.addMelDocs('polyLayoutUV', 'rotateForBestFit')
    def getRotateForBestFit(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'rotateForBestFit')
        return res

    @_f.addMelDocs('polyLayoutUV', 'scale')
    def getScale(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'scale')
        return res

    @_f.addMelDocs('polyLayoutUV', 'separate')
    def getSeparate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'separate')
        return res

    @_f.addMelDocs('polyLayoutUV', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyLayoutUV, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyLayoutUV', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'caching', val)

    @_f.addMelDocs('polyLayoutUV', 'flipReversed')
    def setFlipReversed(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'flipReversed', val)

    @_f.addMelDocs('polyLayoutUV', 'layout')
    def setLayout(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'layout', val)

    @_f.addMelDocs('polyLayoutUV', 'layoutMethod')
    def setLayoutMethod(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'layoutMethod', val)

    @_f.addMelDocs('polyLayoutUV', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyLayoutUV', 'percentageSpace')
    def setPercentageSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'percentageSpace', val)

    @_f.addMelDocs('polyLayoutUV', 'rotateForBestFit')
    def setRotateForBestFit(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'rotateForBestFit', val)

    @_f.addMelDocs('polyLayoutUV', 'scale')
    def setScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'scale', val)

    @_f.addMelDocs('polyLayoutUV', 'separate')
    def setSeparate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'separate', val)

    @_f.addMelDocs('polyLayoutUV', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyLayoutUV, kwargs, 'worldSpace', val)


class PolyFlipUV(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyFlipUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyFlipUV'
    __melnode__ = u'polyFlipUV'
    __slots__ = ()

    @_f.addMelDocs('polyFlipUV', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyFlipUV', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyFlipUV', 'cutUV')
    def getCutUV(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'cutUV')
        return res

    @_f.addMelDocs('polyFlipUV', 'flipType')
    def getFlipType(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'flipType')
        return res

    @_f.addMelDocs('polyFlipUV', 'local')
    def getLocal(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'local')
        return res

    @_f.addMelDocs('polyFlipUV', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyFlipUV', 'pivotU')
    def getPivotU(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'pivotU')
        return res

    @_f.addMelDocs('polyFlipUV', 'pivotV')
    def getPivotV(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'pivotV')
        return res

    @_f.addMelDocs('polyFlipUV', 'usePivot')
    def getUsePivot(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'usePivot')
        return res

    @_f.addMelDocs('polyFlipUV', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyFlipUV, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyFlipUV', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'caching', val)

    @_f.addMelDocs('polyFlipUV', 'cutUV')
    def setCutUV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'cutUV', val)

    @_f.addMelDocs('polyFlipUV', 'flipType')
    def setFlipType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'flipType', val)

    @_f.addMelDocs('polyFlipUV', 'local')
    def setLocal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'local', val)

    @_f.addMelDocs('polyFlipUV', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyFlipUV', 'pivotU')
    def setPivotU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'pivotU', val)

    @_f.addMelDocs('polyFlipUV', 'pivotV')
    def setPivotV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'pivotV', val)

    @_f.addMelDocs('polyFlipUV', 'usePivot')
    def setUsePivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'usePivot', val)

    @_f.addMelDocs('polyFlipUV', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyFlipUV, kwargs, 'worldSpace', val)


class PolyMergeUV(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyMergeUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMergeUV'
    __melnode__ = u'polyMergeUV'
    __slots__ = ()

    @_f.addMelDocs('polyMergeUV', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeUV, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyMergeUV', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeUV, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyMergeUV', 'distance')
    def getDistance(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeUV, kwargs, 'distance')
        return res

    @_f.addMelDocs('polyMergeUV', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeUV, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyMergeUV', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMergeUV, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyMergeUV', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeUV, kwargs, 'caching', val)

    @_f.addMelDocs('polyMergeUV', 'distance')
    def setDistance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeUV, kwargs, 'distance', val)

    @_f.addMelDocs('polyMergeUV', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeUV, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyMergeUV', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMergeUV, kwargs, 'worldSpace', val)


class PolyStraightenUVBorder(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyStraightenUVBorder)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyStraightenUVBorder'
    __melnode__ = u'polyStraightenUVBorder'
    __slots__ = ()

    @_f.addMelDocs('polyStraightenUVBorder', 'blendOriginal')
    def getBlendOriginal(self, **kwargs):
        res = _f.asQuery(self, modeling.polyStraightenUVBorder, kwargs, 'blendOriginal')
        return res

    @_f.addMelDocs('polyStraightenUVBorder', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyStraightenUVBorder, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyStraightenUVBorder', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyStraightenUVBorder, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyStraightenUVBorder', 'curvature')
    def getCurvature(self, **kwargs):
        res = _f.asQuery(self, modeling.polyStraightenUVBorder, kwargs, 'curvature')
        return res

    @_f.addMelDocs('polyStraightenUVBorder', 'gapTolerance')
    def getGapTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.polyStraightenUVBorder, kwargs, 'gapTolerance')
        return res

    @_f.addMelDocs('polyStraightenUVBorder', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyStraightenUVBorder, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyStraightenUVBorder', 'preserveLength')
    def getPreserveLength(self, **kwargs):
        res = _f.asQuery(self, modeling.polyStraightenUVBorder, kwargs, 'preserveLength')
        return res

    @_f.addMelDocs('polyStraightenUVBorder', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyStraightenUVBorder, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyStraightenUVBorder', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyStraightenUVBorder, kwargs, 'caching', val)

    @_f.addMelDocs('polyStraightenUVBorder', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyStraightenUVBorder, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyStraightenUVBorder', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyStraightenUVBorder, kwargs, 'worldSpace', val)


class PolyContourProj(PolyModifierUV):
    __melnode__ = u'polyContourProj'
    __slots__ = ()


class PolyOptUvs(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyOptUvs)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyOptUvs'
    __melnode__ = u'polyOptUvs'
    __slots__ = ()

    @_f.addMelDocs('polyOptUvs', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyOptUvs, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyOptUvs', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyOptUvs, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyOptUvs', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyOptUvs, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyOptUvs', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyOptUvs, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyOptUvs', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyOptUvs, kwargs, 'caching', val)

    @_f.addMelDocs('polyOptUvs', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyOptUvs, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyOptUvs', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyOptUvs, kwargs, 'worldSpace', val)


class PolyCopyUV(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyCopyUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCopyUV'
    __melnode__ = u'polyCopyUV'
    __slots__ = ()

    @_f.addMelDocs('polyCopyUV', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCopyUV, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyCopyUV', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCopyUV, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyCopyUV', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCopyUV, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyCopyUV', 'uvSetNameInput')
    def getUvSetNameInput(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCopyUV, kwargs, 'uvSetNameInput')
        return res

    @_f.addMelDocs('polyCopyUV', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCopyUV, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyCopyUV', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCopyUV, kwargs, 'caching', val)

    @_f.addMelDocs('polyCopyUV', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCopyUV, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyCopyUV', 'uvSetNameInput')
    def setUvSetNameInput(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCopyUV, kwargs, 'uvSetNameInput', val)

    @_f.addMelDocs('polyCopyUV', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCopyUV, kwargs, 'worldSpace', val)


class PolyMapSewMove(PolyModifierUV):
    __melcmd__ = staticmethod(modeling.polyMapSewMove)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMapSewMove'
    __melnode__ = u'polyMapSewMove'
    __slots__ = ()

    @_f.addMelDocs('polyMapSewMove', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSewMove, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyMapSewMove', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSewMove, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyMapSewMove', 'limitPieceSize')
    def getLimitPieceSize(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSewMove, kwargs, 'limitPieceSize')
        return res

    @_f.addMelDocs('polyMapSewMove', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSewMove, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyMapSewMove', 'numberFaces')
    def getNumberFaces(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSewMove, kwargs, 'numberFaces')
        return res

    @_f.addMelDocs('polyMapSewMove', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMapSewMove, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyMapSewMove', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapSewMove, kwargs, 'caching', val)

    @_f.addMelDocs('polyMapSewMove', 'limitPieceSize')
    def setLimitPieceSize(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapSewMove, kwargs, 'limitPieceSize', val)

    @_f.addMelDocs('polyMapSewMove', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapSewMove, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyMapSewMove', 'numberFaces')
    def setNumberFaces(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapSewMove, kwargs, 'numberFaces', val)

    @_f.addMelDocs('polyMapSewMove', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMapSewMove, kwargs, 'worldSpace', val)


class PolySplitVert(PolyModifierWorld):
    __melnode__ = u'polySplitVert'
    __slots__ = ()


class PolyExtrudeVertex(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyExtrudeVertex)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyExtrudeVertex'
    __melnode__ = u'polyExtrudeVertex'
    __slots__ = ()

    @_f.addMelDocs('polyExtrudeVertex', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeVertex, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyExtrudeVertex', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeVertex, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyExtrudeVertex', 'divisions')
    def getDivisions(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeVertex, kwargs, 'divisions')
        return res

    @_f.addMelDocs('polyExtrudeVertex', 'length')
    def getLength(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeVertex, kwargs, 'length')
        return res

    @_f.addMelDocs('polyExtrudeVertex', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeVertex, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyExtrudeVertex', 'width')
    def getWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeVertex, kwargs, 'width')
        return res

    @_f.addMelDocs('polyExtrudeVertex', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeVertex, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyExtrudeVertex', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeVertex, kwargs, 'caching', val)

    @_f.addMelDocs('polyExtrudeVertex', 'divisions')
    def setDivisions(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeVertex, kwargs, 'divisions', val)

    @_f.addMelDocs('polyExtrudeVertex', 'length')
    def setLength(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeVertex, kwargs, 'length', val)

    @_f.addMelDocs('polyExtrudeVertex', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeVertex, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyExtrudeVertex', 'width')
    def setWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeVertex, kwargs, 'width', val)

    @_f.addMelDocs('polyExtrudeVertex', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeVertex, kwargs, 'worldSpace', val)


class PolyMirror(PolyModifierWorld):
    __melnode__ = u'polyMirror'
    __slots__ = ()


class PolyBridgeEdge(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyBridgeEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyBridgeEdge'
    __melnode__ = u'polyBridgeEdge'
    __slots__ = ()

    @_f.addMelDocs('polyBridgeEdge', 'bridgeOffset')
    def getBridgeOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'bridgeOffset')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'curveType')
    def getCurveType(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'curveType')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'divisions')
    def getDivisions(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'divisions')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'smoothingAngle')
    def getSmoothingAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'smoothingAngle')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'startVert1')
    def getStartVert1(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'startVert1')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'startVert2')
    def getStartVert2(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'startVert2')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'taper')
    def getTaper(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'taper')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'taperCurve_FloatValue')
    def getTaperCurve_FloatValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'taperCurve_FloatValue')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'taperCurve_Interp')
    def getTaperCurve_Interp(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'taperCurve_Interp')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'taperCurve_Position')
    def getTaperCurve_Position(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'taperCurve_Position')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'twist')
    def getTwist(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'twist')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBridgeEdge, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyBridgeEdge', 'bridgeOffset')
    def setBridgeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'bridgeOffset', val)

    @_f.addMelDocs('polyBridgeEdge', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'caching', val)

    @_f.addMelDocs('polyBridgeEdge', 'curveType')
    def setCurveType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'curveType', val)

    @_f.addMelDocs('polyBridgeEdge', 'divisions')
    def setDivisions(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'divisions', val)

    @_f.addMelDocs('polyBridgeEdge', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyBridgeEdge', 'smoothingAngle')
    def setSmoothingAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'smoothingAngle', val)

    @_f.addMelDocs('polyBridgeEdge', 'startVert1')
    def setStartVert1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'startVert1', val)

    @_f.addMelDocs('polyBridgeEdge', 'startVert2')
    def setStartVert2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'startVert2', val)

    @_f.addMelDocs('polyBridgeEdge', 'taper')
    def setTaper(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'taper', val)

    @_f.addMelDocs('polyBridgeEdge', 'taperCurve_FloatValue')
    def setTaperCurve_FloatValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'taperCurve_FloatValue', val)

    @_f.addMelDocs('polyBridgeEdge', 'taperCurve_Interp')
    def setTaperCurve_Interp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'taperCurve_Interp', val)

    @_f.addMelDocs('polyBridgeEdge', 'taperCurve_Position')
    def setTaperCurve_Position(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'taperCurve_Position', val)

    @_f.addMelDocs('polyBridgeEdge', 'twist')
    def setTwist(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'twist', val)

    @_f.addMelDocs('polyBridgeEdge', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBridgeEdge, kwargs, 'worldSpace', val)


class PolyWedgeFace(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyWedgeFace)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyWedgeFace'
    __melnode__ = u'polyWedgeFace'
    __slots__ = ()

    @_f.addMelDocs('polyWedgeFace', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyWedgeFace, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyWedgeFace', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyWedgeFace, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyWedgeFace', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyWedgeFace, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyWedgeFace', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyWedgeFace, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyWedgeFace', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyWedgeFace, kwargs, 'caching', val)

    @_f.addMelDocs('polyWedgeFace', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyWedgeFace, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyWedgeFace', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyWedgeFace, kwargs, 'worldSpace', val)


class PolyBevel(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyBevel)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyBevel'
    __melnode__ = u'polyBevel'
    __slots__ = ()

    @_f.addMelDocs('polyBevel', 'angleTolerance')
    def getAngleTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'angleTolerance')
        return res

    @_f.addMelDocs('polyBevel', 'autoFit')
    def getAutoFit(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'autoFit')
        return res

    @_f.addMelDocs('polyBevel', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyBevel', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyBevel', 'mergeVertexTolerance')
    def getMergeVertexTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'mergeVertexTolerance')
        return res

    @_f.addMelDocs('polyBevel', 'mergeVertices')
    def getMergeVertices(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'mergeVertices')
        return res

    @_f.addMelDocs('polyBevel', 'miteringAngle')
    def getMiteringAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'miteringAngle')
        return res

    @_f.addMelDocs('polyBevel', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyBevel', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'offset')
        return res

    @_f.addMelDocs('polyBevel', 'offsetAsFraction')
    def getOffsetAsFraction(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'offsetAsFraction')
        return res

    @_f.addMelDocs('polyBevel', 'roundness')
    def getRoundness(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'roundness')
        return res

    @_f.addMelDocs('polyBevel', 'segments')
    def getSegments(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'segments')
        return res

    @_f.addMelDocs('polyBevel', 'smoothingAngle')
    def getSmoothingAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'smoothingAngle')
        return res

    @_f.addMelDocs('polyBevel', 'subdivideNgons')
    def getSubdivideNgons(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'subdivideNgons')
        return res

    @_f.addMelDocs('polyBevel', 'useLegacyBevelAlgorithm')
    def getUseLegacyBevelAlgorithm(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'useLegacyBevelAlgorithm')
        return res

    @_f.addMelDocs('polyBevel', 'uvAssignment')
    def getUvAssignment(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'uvAssignment')
        return res

    @_f.addMelDocs('polyBevel', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyBevel', 'angleTolerance')
    def setAngleTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'angleTolerance', val)

    @_f.addMelDocs('polyBevel', 'autoFit')
    def setAutoFit(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'autoFit', val)

    @_f.addMelDocs('polyBevel', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'caching', val)

    @_f.addMelDocs('polyBevel', 'mergeVertexTolerance')
    def setMergeVertexTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'mergeVertexTolerance', val)

    @_f.addMelDocs('polyBevel', 'mergeVertices')
    def setMergeVertices(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'mergeVertices', val)

    @_f.addMelDocs('polyBevel', 'miteringAngle')
    def setMiteringAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'miteringAngle', val)

    @_f.addMelDocs('polyBevel', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyBevel', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'offset', val)

    @_f.addMelDocs('polyBevel', 'offsetAsFraction')
    def setOffsetAsFraction(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'offsetAsFraction', val)

    @_f.addMelDocs('polyBevel', 'roundness')
    def setRoundness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'roundness', val)

    @_f.addMelDocs('polyBevel', 'segments')
    def setSegments(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'segments', val)

    @_f.addMelDocs('polyBevel', 'smoothingAngle')
    def setSmoothingAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'smoothingAngle', val)

    @_f.addMelDocs('polyBevel', 'subdivideNgons')
    def setSubdivideNgons(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'subdivideNgons', val)

    @_f.addMelDocs('polyBevel', 'useLegacyBevelAlgorithm')
    def setUseLegacyBevelAlgorithm(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'useLegacyBevelAlgorithm', val)

    @_f.addMelDocs('polyBevel', 'uvAssignment')
    def setUvAssignment(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'uvAssignment', val)

    @_f.addMelDocs('polyBevel', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel, kwargs, 'worldSpace', val)


class PolyBevel2(PolyBevel):
    __melnode__ = u'polyBevel2'
    __slots__ = ()


class PolyPlanarProj(PolyModifierWorld):
    __melnode__ = u'polyPlanarProj'
    __slots__ = ()


class PolyCut(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyCut)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCut'
    __melnode__ = u'polyCut'
    __slots__ = ()

    @_f.addMelDocs('polyCut', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyCut', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneCenter')
    def getCutPlaneCenter(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneCenter')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneCenterX')
    def getCutPlaneCenterX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneCenterX')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneCenterY')
    def getCutPlaneCenterY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneCenterY')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneCenterZ')
    def getCutPlaneCenterZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneCenterZ')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneHeight')
    def getCutPlaneHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneHeight')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneRotate')
    def getCutPlaneRotate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneRotate')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneRotateX')
    def getCutPlaneRotateX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneRotateX')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneRotateY')
    def getCutPlaneRotateY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneRotateY')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneRotateZ')
    def getCutPlaneRotateZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneRotateZ')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneSize')
    def getCutPlaneSize(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneSize')
        return res

    @_f.addMelDocs('polyCut', 'cutPlaneWidth')
    def getCutPlaneWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'cutPlaneWidth')
        return res

    @_f.addMelDocs('polyCut', 'deleteFaces')
    def getDeleteFaces(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'deleteFaces')
        return res

    @_f.addMelDocs('polyCut', 'extractFaces')
    def getExtractFaces(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'extractFaces')
        return res

    @_f.addMelDocs('polyCut', 'extractOffset')
    def getExtractOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'extractOffset')
        return res

    @_f.addMelDocs('polyCut', 'extractOffsetX')
    def getExtractOffsetX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'extractOffsetX')
        return res

    @_f.addMelDocs('polyCut', 'extractOffsetY')
    def getExtractOffsetY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'extractOffsetY')
        return res

    @_f.addMelDocs('polyCut', 'extractOffsetZ')
    def getExtractOffsetZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'extractOffsetZ')
        return res

    @_f.addMelDocs('polyCut', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyCut', 'onObject')
    def getOnObject(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'onObject')
        return res

    @_f.addMelDocs('polyCut', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCut, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyCut', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'caching', val)

    @_f.addMelDocs('polyCut', 'cutPlaneCenter')
    def setCutPlaneCenter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneCenter', val)

    @_f.addMelDocs('polyCut', 'cutPlaneCenterX')
    def setCutPlaneCenterX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneCenterX', val)

    @_f.addMelDocs('polyCut', 'cutPlaneCenterY')
    def setCutPlaneCenterY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneCenterY', val)

    @_f.addMelDocs('polyCut', 'cutPlaneCenterZ')
    def setCutPlaneCenterZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneCenterZ', val)

    @_f.addMelDocs('polyCut', 'cutPlaneHeight')
    def setCutPlaneHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneHeight', val)

    @_f.addMelDocs('polyCut', 'cutPlaneRotate')
    def setCutPlaneRotate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneRotate', val)

    @_f.addMelDocs('polyCut', 'cutPlaneRotateX')
    def setCutPlaneRotateX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneRotateX', val)

    @_f.addMelDocs('polyCut', 'cutPlaneRotateY')
    def setCutPlaneRotateY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneRotateY', val)

    @_f.addMelDocs('polyCut', 'cutPlaneRotateZ')
    def setCutPlaneRotateZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneRotateZ', val)

    @_f.addMelDocs('polyCut', 'cutPlaneSize')
    def setCutPlaneSize(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneSize', val)

    @_f.addMelDocs('polyCut', 'cutPlaneWidth')
    def setCutPlaneWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'cutPlaneWidth', val)

    @_f.addMelDocs('polyCut', 'deleteFaces')
    def setDeleteFaces(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'deleteFaces', val)

    @_f.addMelDocs('polyCut', 'extractFaces')
    def setExtractFaces(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'extractFaces', val)

    @_f.addMelDocs('polyCut', 'extractOffset')
    def setExtractOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'extractOffset', val)

    @_f.addMelDocs('polyCut', 'extractOffsetX')
    def setExtractOffsetX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'extractOffsetX', val)

    @_f.addMelDocs('polyCut', 'extractOffsetY')
    def setExtractOffsetY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'extractOffsetY', val)

    @_f.addMelDocs('polyCut', 'extractOffsetZ')
    def setExtractOffsetZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'extractOffsetZ', val)

    @_f.addMelDocs('polyCut', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyCut', 'onObject')
    def setOnObject(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'onObject', val)

    @_f.addMelDocs('polyCut', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCut, kwargs, 'worldSpace', val)


class PolyCircularize(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyCircularize)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCircularize'
    __melnode__ = u'polyCircularize'
    __slots__ = ()

    @_f.addMelDocs('polyCircularize', 'alignment')
    def getAlignment(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'alignment')
        return res

    @_f.addMelDocs('polyCircularize', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyCircularize', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyCircularize', 'evenlyDistribute')
    def getEvenlyDistribute(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'evenlyDistribute')
        return res

    @_f.addMelDocs('polyCircularize', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyCircularize', 'normalOrientation')
    def getNormalOrientation(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'normalOrientation')
        return res

    @_f.addMelDocs('polyCircularize', 'radialOffset')
    def getRadialOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'radialOffset')
        return res

    @_f.addMelDocs('polyCircularize', 'smoothingAngle')
    def getSmoothingAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'smoothingAngle')
        return res

    @_f.addMelDocs('polyCircularize', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCircularize, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyCircularize', 'alignment')
    def setAlignment(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCircularize, kwargs, 'alignment', val)

    @_f.addMelDocs('polyCircularize', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCircularize, kwargs, 'caching', val)

    @_f.addMelDocs('polyCircularize', 'evenlyDistribute')
    def setEvenlyDistribute(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCircularize, kwargs, 'evenlyDistribute', val)

    @_f.addMelDocs('polyCircularize', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCircularize, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyCircularize', 'normalOrientation')
    def setNormalOrientation(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCircularize, kwargs, 'normalOrientation', val)

    @_f.addMelDocs('polyCircularize', 'radialOffset')
    def setRadialOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCircularize, kwargs, 'radialOffset', val)

    @_f.addMelDocs('polyCircularize', 'smoothingAngle')
    def setSmoothingAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCircularize, kwargs, 'smoothingAngle', val)

    @_f.addMelDocs('polyCircularize', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCircularize, kwargs, 'worldSpace', val)


class PolyBevel3(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyBevel3)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyBevel3'
    __melnode__ = u'polyBevel3'
    __slots__ = ()

    @_f.addMelDocs('polyBevel3', 'angleTolerance')
    def getAngleTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'angleTolerance')
        return res

    @_f.addMelDocs('polyBevel3', 'autoFit')
    def getAutoFit(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'autoFit')
        return res

    @_f.addMelDocs('polyBevel3', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyBevel3', 'chamfer')
    def getChamfer(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'chamfer')
        return res

    @_f.addMelDocs('polyBevel3', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyBevel3', 'depth')
    def getDepth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'depth')
        return res

    @_f.addMelDocs('polyBevel3', 'fillNgons')
    def getFillNgons(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'fillNgons')
        return res

    @_f.addMelDocs('polyBevel3', 'mergeVertexTolerance')
    def getMergeVertexTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'mergeVertexTolerance')
        return res

    @_f.addMelDocs('polyBevel3', 'mergeVertices')
    def getMergeVertices(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'mergeVertices')
        return res

    @_f.addMelDocs('polyBevel3', 'miterAlong')
    def getMiterAlong(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'miterAlong')
        return res

    @_f.addMelDocs('polyBevel3', 'mitering')
    def getMitering(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'mitering')
        return res

    @_f.addMelDocs('polyBevel3', 'miteringAngle')
    def getMiteringAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'miteringAngle')
        return res

    @_f.addMelDocs('polyBevel3', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyBevel3', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'offset')
        return res

    @_f.addMelDocs('polyBevel3', 'offsetAsFraction')
    def getOffsetAsFraction(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'offsetAsFraction')
        return res

    @_f.addMelDocs('polyBevel3', 'roundness')
    def getRoundness(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'roundness')
        return res

    @_f.addMelDocs('polyBevel3', 'segments')
    def getSegments(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'segments')
        return res

    @_f.addMelDocs('polyBevel3', 'smoothingAngle')
    def getSmoothingAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'smoothingAngle')
        return res

    @_f.addMelDocs('polyBevel3', 'uvAssignment')
    def getUvAssignment(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'uvAssignment')
        return res

    @_f.addMelDocs('polyBevel3', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBevel3, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyBevel3', 'angleTolerance')
    def setAngleTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'angleTolerance', val)

    @_f.addMelDocs('polyBevel3', 'autoFit')
    def setAutoFit(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'autoFit', val)

    @_f.addMelDocs('polyBevel3', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'caching', val)

    @_f.addMelDocs('polyBevel3', 'chamfer')
    def setChamfer(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'chamfer', val)

    @_f.addMelDocs('polyBevel3', 'depth')
    def setDepth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'depth', val)

    @_f.addMelDocs('polyBevel3', 'fillNgons')
    def setFillNgons(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'fillNgons', val)

    @_f.addMelDocs('polyBevel3', 'mergeVertexTolerance')
    def setMergeVertexTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'mergeVertexTolerance', val)

    @_f.addMelDocs('polyBevel3', 'mergeVertices')
    def setMergeVertices(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'mergeVertices', val)

    @_f.addMelDocs('polyBevel3', 'miterAlong')
    def setMiterAlong(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'miterAlong', val)

    @_f.addMelDocs('polyBevel3', 'mitering')
    def setMitering(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'mitering', val)

    @_f.addMelDocs('polyBevel3', 'miteringAngle')
    def setMiteringAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'miteringAngle', val)

    @_f.addMelDocs('polyBevel3', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyBevel3', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'offset', val)

    @_f.addMelDocs('polyBevel3', 'offsetAsFraction')
    def setOffsetAsFraction(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'offsetAsFraction', val)

    @_f.addMelDocs('polyBevel3', 'roundness')
    def setRoundness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'roundness', val)

    @_f.addMelDocs('polyBevel3', 'segments')
    def setSegments(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'segments', val)

    @_f.addMelDocs('polyBevel3', 'smoothingAngle')
    def setSmoothingAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'smoothingAngle', val)

    @_f.addMelDocs('polyBevel3', 'uvAssignment')
    def setUvAssignment(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'uvAssignment', val)

    @_f.addMelDocs('polyBevel3', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBevel3, kwargs, 'worldSpace', val)


class PolySplitRing(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polySplitRing)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySplitRing'
    __melnode__ = u'polySplitRing'
    __slots__ = ()

    @_f.addMelDocs('polySplitRing', 'adjustEdgeFlow')
    def getAdjustEdgeFlow(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'adjustEdgeFlow')
        return res

    @_f.addMelDocs('polySplitRing', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'caching')
        return res

    @_f.addMelDocs('polySplitRing', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polySplitRing', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'direction')
        return res

    @_f.addMelDocs('polySplitRing', 'divisions')
    def getDivisions(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'divisions')
        return res

    @_f.addMelDocs('polySplitRing', 'enableProfileCurve')
    def getEnableProfileCurve(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'enableProfileCurve')
        return res

    @_f.addMelDocs('polySplitRing', 'fixQuads')
    def getFixQuads(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'fixQuads')
        return res

    @_f.addMelDocs('polySplitRing', 'insertWithEdgeFlow')
    def getInsertWithEdgeFlow(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'insertWithEdgeFlow')
        return res

    @_f.addMelDocs('polySplitRing', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polySplitRing', 'profileCurve_FloatValue')
    def getProfileCurve_FloatValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'profileCurve_FloatValue')
        return res

    @_f.addMelDocs('polySplitRing', 'profileCurve_Interp')
    def getProfileCurve_Interp(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'profileCurve_Interp')
        return res

    @_f.addMelDocs('polySplitRing', 'profileCurve_Position')
    def getProfileCurve_Position(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'profileCurve_Position')
        return res

    @_f.addMelDocs('polySplitRing', 'profileCurveInputOffset')
    def getProfileCurveInputOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'profileCurveInputOffset')
        return res

    @_f.addMelDocs('polySplitRing', 'profileCurveInputScale')
    def getProfileCurveInputScale(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'profileCurveInputScale')
        return res

    @_f.addMelDocs('polySplitRing', 'rootEdge')
    def getRootEdge(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'rootEdge')
        return res

    @_f.addMelDocs('polySplitRing', 'smoothingAngle')
    def getSmoothingAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'smoothingAngle')
        return res

    @_f.addMelDocs('polySplitRing', 'splitType')
    def getSplitType(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'splitType')
        return res

    @_f.addMelDocs('polySplitRing', 'useEqualMultiplier')
    def getUseEqualMultiplier(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'useEqualMultiplier')
        return res

    @_f.addMelDocs('polySplitRing', 'useFaceNormalsAtEnds')
    def getUseFaceNormalsAtEnds(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'useFaceNormalsAtEnds')
        return res

    @_f.addMelDocs('polySplitRing', 'weight')
    def getWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'weight')
        return res

    @_f.addMelDocs('polySplitRing', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplitRing, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polySplitRing', 'adjustEdgeFlow')
    def setAdjustEdgeFlow(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'adjustEdgeFlow', val)

    @_f.addMelDocs('polySplitRing', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'caching', val)

    @_f.addMelDocs('polySplitRing', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'direction', val)

    @_f.addMelDocs('polySplitRing', 'divisions')
    def setDivisions(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'divisions', val)

    @_f.addMelDocs('polySplitRing', 'enableProfileCurve')
    def setEnableProfileCurve(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'enableProfileCurve', val)

    @_f.addMelDocs('polySplitRing', 'fixQuads')
    def setFixQuads(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'fixQuads', val)

    @_f.addMelDocs('polySplitRing', 'insertWithEdgeFlow')
    def setInsertWithEdgeFlow(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'insertWithEdgeFlow', val)

    @_f.addMelDocs('polySplitRing', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'nodeState', val)

    @_f.addMelDocs('polySplitRing', 'profileCurve_FloatValue')
    def setProfileCurve_FloatValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'profileCurve_FloatValue', val)

    @_f.addMelDocs('polySplitRing', 'profileCurve_Interp')
    def setProfileCurve_Interp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'profileCurve_Interp', val)

    @_f.addMelDocs('polySplitRing', 'profileCurve_Position')
    def setProfileCurve_Position(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'profileCurve_Position', val)

    @_f.addMelDocs('polySplitRing', 'profileCurveInputOffset')
    def setProfileCurveInputOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'profileCurveInputOffset', val)

    @_f.addMelDocs('polySplitRing', 'profileCurveInputScale')
    def setProfileCurveInputScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'profileCurveInputScale', val)

    @_f.addMelDocs('polySplitRing', 'rootEdge')
    def setRootEdge(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'rootEdge', val)

    @_f.addMelDocs('polySplitRing', 'smoothingAngle')
    def setSmoothingAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'smoothingAngle', val)

    @_f.addMelDocs('polySplitRing', 'splitType')
    def setSplitType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'splitType', val)

    @_f.addMelDocs('polySplitRing', 'useEqualMultiplier')
    def setUseEqualMultiplier(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'useEqualMultiplier', val)

    @_f.addMelDocs('polySplitRing', 'useFaceNormalsAtEnds')
    def setUseFaceNormalsAtEnds(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'useFaceNormalsAtEnds', val)

    @_f.addMelDocs('polySplitRing', 'weight')
    def setWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'weight', val)

    @_f.addMelDocs('polySplitRing', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplitRing, kwargs, 'worldSpace', val)


class PolySubdEdge(PolyModifierWorld):
    __melnode__ = u'polySubdEdge'
    __slots__ = ()


class PolySewEdge(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polySewEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySewEdge'
    __melnode__ = u'polySewEdge'
    __slots__ = ()

    @_f.addMelDocs('polySewEdge', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polySewEdge, kwargs, 'caching')
        return res

    @_f.addMelDocs('polySewEdge', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polySewEdge, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polySewEdge', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polySewEdge, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polySewEdge', 'texture')
    def getTexture(self, **kwargs):
        res = _f.asQuery(self, modeling.polySewEdge, kwargs, 'texture')
        return res

    @_f.addMelDocs('polySewEdge', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.polySewEdge, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('polySewEdge', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polySewEdge, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polySewEdge', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySewEdge, kwargs, 'caching', val)

    @_f.addMelDocs('polySewEdge', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySewEdge, kwargs, 'nodeState', val)

    @_f.addMelDocs('polySewEdge', 'texture')
    def setTexture(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySewEdge, kwargs, 'texture', val)

    @_f.addMelDocs('polySewEdge', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySewEdge, kwargs, 'tolerance', val)

    @_f.addMelDocs('polySewEdge', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySewEdge, kwargs, 'worldSpace', val)


class PolyQuad(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyQuad)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyQuad'
    __melnode__ = u'polyQuad'
    __slots__ = ()

    @_f.addMelDocs('polyQuad', 'angle')
    def getAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyQuad, kwargs, 'angle')
        return res

    @_f.addMelDocs('polyQuad', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyQuad, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyQuad', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyQuad, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyQuad', 'keepGroupBorder')
    def getKeepGroupBorder(self, **kwargs):
        res = _f.asQuery(self, modeling.polyQuad, kwargs, 'keepGroupBorder')
        return res

    @_f.addMelDocs('polyQuad', 'keepHardEdges')
    def getKeepHardEdges(self, **kwargs):
        res = _f.asQuery(self, modeling.polyQuad, kwargs, 'keepHardEdges')
        return res

    @_f.addMelDocs('polyQuad', 'keepTextureBorders')
    def getKeepTextureBorders(self, **kwargs):
        res = _f.asQuery(self, modeling.polyQuad, kwargs, 'keepTextureBorders')
        return res

    @_f.addMelDocs('polyQuad', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyQuad, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyQuad', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyQuad, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyQuad', 'angle')
    def setAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyQuad, kwargs, 'angle', val)

    @_f.addMelDocs('polyQuad', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyQuad, kwargs, 'caching', val)

    @_f.addMelDocs('polyQuad', 'keepGroupBorder')
    def setKeepGroupBorder(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyQuad, kwargs, 'keepGroupBorder', val)

    @_f.addMelDocs('polyQuad', 'keepHardEdges')
    def setKeepHardEdges(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyQuad, kwargs, 'keepHardEdges', val)

    @_f.addMelDocs('polyQuad', 'keepTextureBorders')
    def setKeepTextureBorders(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyQuad, kwargs, 'keepTextureBorders', val)

    @_f.addMelDocs('polyQuad', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyQuad, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyQuad', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyQuad, kwargs, 'worldSpace', val)


class PolyCylProj(PolyModifierWorld):
    __melnode__ = u'polyCylProj'
    __slots__ = ()


class PolyHoleFace(PolyModifierWorld):
    __melnode__ = u'polyHoleFace'
    __slots__ = ()


class PolySoftEdge(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polySoftEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySoftEdge'
    __melnode__ = u'polySoftEdge'
    __slots__ = ()

    @_f.addMelDocs('polySoftEdge', 'angle')
    def getAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polySoftEdge, kwargs, 'angle')
        return res

    @_f.addMelDocs('polySoftEdge', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polySoftEdge, kwargs, 'caching')
        return res

    @_f.addMelDocs('polySoftEdge', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polySoftEdge, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polySoftEdge', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polySoftEdge, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polySoftEdge', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polySoftEdge, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polySoftEdge', 'angle')
    def setAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySoftEdge, kwargs, 'angle', val)

    @_f.addMelDocs('polySoftEdge', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySoftEdge, kwargs, 'caching', val)

    @_f.addMelDocs('polySoftEdge', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySoftEdge, kwargs, 'nodeState', val)

    @_f.addMelDocs('polySoftEdge', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySoftEdge, kwargs, 'worldSpace', val)


class PolyPassThru(PolyModifierWorld):
    __melnode__ = u'polyPassThru'
    __slots__ = ()


class PolyPoke(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyPoke)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPoke'
    __melnode__ = u'polyPoke'
    __slots__ = ()

    @_f.addMelDocs('polyPoke', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPoke, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyPoke', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPoke, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyPoke', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPoke, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyPoke', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPoke, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyPoke', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPoke, kwargs, 'caching', val)

    @_f.addMelDocs('polyPoke', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPoke, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyPoke', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPoke, kwargs, 'worldSpace', val)


class PolySphProj(PolyModifierWorld):
    __melnode__ = u'polySphProj'
    __slots__ = ()


class PolyAverageVertex(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyAverageVertex)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyAverageVertex'
    __melnode__ = u'polyAverageVertex'
    __slots__ = ()

    @_f.addMelDocs('polyAverageVertex', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAverageVertex, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyAverageVertex', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAverageVertex, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyAverageVertex', 'iterations')
    def getIterations(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAverageVertex, kwargs, 'iterations')
        return res

    @_f.addMelDocs('polyAverageVertex', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAverageVertex, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyAverageVertex', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyAverageVertex, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyAverageVertex', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyAverageVertex, kwargs, 'caching', val)

    @_f.addMelDocs('polyAverageVertex', 'iterations')
    def setIterations(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyAverageVertex, kwargs, 'iterations', val)

    @_f.addMelDocs('polyAverageVertex', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyAverageVertex, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyAverageVertex', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyAverageVertex, kwargs, 'worldSpace', val)


class PolyRemesh(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyRemesh)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyRemesh'
    __melnode__ = u'polyRemesh'
    __slots__ = ()

    @_f.addMelDocs('polyRemesh', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyRemesh, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyRemesh', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyRemesh, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyRemesh', 'interpolationType')
    def getInterpolationType(self, **kwargs):
        res = _f.asQuery(self, modeling.polyRemesh, kwargs, 'interpolationType')
        return res

    @_f.addMelDocs('polyRemesh', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyRemesh, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyRemesh', 'reduceThreshold')
    def getReduceThreshold(self, **kwargs):
        res = _f.asQuery(self, modeling.polyRemesh, kwargs, 'reduceThreshold')
        return res

    @_f.addMelDocs('polyRemesh', 'refineThreshold')
    def getRefineThreshold(self, **kwargs):
        res = _f.asQuery(self, modeling.polyRemesh, kwargs, 'refineThreshold')
        return res

    @_f.addMelDocs('polyRemesh', 'smoothStrength')
    def getSmoothStrength(self, **kwargs):
        res = _f.asQuery(self, modeling.polyRemesh, kwargs, 'smoothStrength')
        return res

    @_f.addMelDocs('polyRemesh', 'tessellateBorders')
    def getTessellateBorders(self, **kwargs):
        res = _f.asQuery(self, modeling.polyRemesh, kwargs, 'tessellateBorders')
        return res

    @_f.addMelDocs('polyRemesh', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyRemesh, kwargs, 'caching', val)

    @_f.addMelDocs('polyRemesh', 'interpolationType')
    def setInterpolationType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyRemesh, kwargs, 'interpolationType', val)

    @_f.addMelDocs('polyRemesh', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyRemesh, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyRemesh', 'reduceThreshold')
    def setReduceThreshold(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyRemesh, kwargs, 'reduceThreshold', val)

    @_f.addMelDocs('polyRemesh', 'refineThreshold')
    def setRefineThreshold(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyRemesh, kwargs, 'refineThreshold', val)

    @_f.addMelDocs('polyRemesh', 'smoothStrength')
    def setSmoothStrength(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyRemesh, kwargs, 'smoothStrength', val)

    @_f.addMelDocs('polyRemesh', 'tessellateBorders')
    def setTessellateBorders(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyRemesh, kwargs, 'tessellateBorders', val)


class PolyMoveVertex(PolyModifierWorld):
    __melcmd__ = staticmethod(modeling.polyMoveVertex)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMoveVertex'
    __melnode__ = u'polyMoveVertex'
    __slots__ = ()

    @_f.addMelDocs('polyMoveVertex', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyMoveVertex', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyMoveVertex', 'gain')
    def getGain(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'gain')
        return res

    @_f.addMelDocs('polyMoveVertex', 'localDirection')
    def getLocalDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'localDirection')
        return res

    @_f.addMelDocs('polyMoveVertex', 'localDirectionX')
    def getLocalDirectionX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'localDirectionX')
        return res

    @_f.addMelDocs('polyMoveVertex', 'localDirectionY')
    def getLocalDirectionY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'localDirectionY')
        return res

    @_f.addMelDocs('polyMoveVertex', 'localDirectionZ')
    def getLocalDirectionZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'localDirectionZ')
        return res

    @_f.addMelDocs('polyMoveVertex', 'localTranslate')
    def getLocalTranslate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'localTranslate')
        return res

    @_f.addMelDocs('polyMoveVertex', 'localTranslateX')
    def getLocalTranslateX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'localTranslateX')
        return res

    @_f.addMelDocs('polyMoveVertex', 'localTranslateY')
    def getLocalTranslateY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'localTranslateY')
        return res

    @_f.addMelDocs('polyMoveVertex', 'localTranslateZ')
    def getLocalTranslateZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'localTranslateZ')
        return res

    @_f.addMelDocs('polyMoveVertex', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyMoveVertex', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'pivot')
        return res

    @_f.addMelDocs('polyMoveVertex', 'pivotX')
    def getPivotX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'pivotX')
        return res

    @_f.addMelDocs('polyMoveVertex', 'pivotY')
    def getPivotY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'pivotY')
        return res

    @_f.addMelDocs('polyMoveVertex', 'pivotZ')
    def getPivotZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'pivotZ')
        return res

    @_f.addMelDocs('polyMoveVertex', 'random')
    def getRandom(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'random')
        return res

    @_f.addMelDocs('polyMoveVertex', 'rotate')
    def getRotate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'rotate')
        return res

    @_f.addMelDocs('polyMoveVertex', 'rotateX')
    def getRotateX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'rotateX')
        return res

    @_f.addMelDocs('polyMoveVertex', 'rotateY')
    def getRotateY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'rotateY')
        return res

    @_f.addMelDocs('polyMoveVertex', 'rotateZ')
    def getRotateZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'rotateZ')
        return res

    @_f.addMelDocs('polyMoveVertex', 'scale')
    def getScale(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'scale')
        return res

    @_f.addMelDocs('polyMoveVertex', 'scaleX')
    def getScaleX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'scaleX')
        return res

    @_f.addMelDocs('polyMoveVertex', 'scaleY')
    def getScaleY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'scaleY')
        return res

    @_f.addMelDocs('polyMoveVertex', 'scaleZ')
    def getScaleZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'scaleZ')
        return res

    @_f.addMelDocs('polyMoveVertex', 'translate')
    def getTranslate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'translate')
        return res

    @_f.addMelDocs('polyMoveVertex', 'translateX')
    def getTranslateX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'translateX')
        return res

    @_f.addMelDocs('polyMoveVertex', 'translateY')
    def getTranslateY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'translateY')
        return res

    @_f.addMelDocs('polyMoveVertex', 'translateZ')
    def getTranslateZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'translateZ')
        return res

    @_f.addMelDocs('polyMoveVertex', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveVertex, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('polyMoveVertex', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'caching', val)

    @_f.addMelDocs('polyMoveVertex', 'gain')
    def setGain(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'gain', val)

    @_f.addMelDocs('polyMoveVertex', 'localDirection')
    def setLocalDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'localDirection', val)

    @_f.addMelDocs('polyMoveVertex', 'localDirectionX')
    def setLocalDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'localDirectionX', val)

    @_f.addMelDocs('polyMoveVertex', 'localDirectionY')
    def setLocalDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'localDirectionY', val)

    @_f.addMelDocs('polyMoveVertex', 'localDirectionZ')
    def setLocalDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'localDirectionZ', val)

    @_f.addMelDocs('polyMoveVertex', 'localTranslate')
    def setLocalTranslate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'localTranslate', val)

    @_f.addMelDocs('polyMoveVertex', 'localTranslateX')
    def setLocalTranslateX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'localTranslateX', val)

    @_f.addMelDocs('polyMoveVertex', 'localTranslateY')
    def setLocalTranslateY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'localTranslateY', val)

    @_f.addMelDocs('polyMoveVertex', 'localTranslateZ')
    def setLocalTranslateZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'localTranslateZ', val)

    @_f.addMelDocs('polyMoveVertex', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyMoveVertex', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'pivot', val)

    @_f.addMelDocs('polyMoveVertex', 'pivotX')
    def setPivotX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'pivotX', val)

    @_f.addMelDocs('polyMoveVertex', 'pivotY')
    def setPivotY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'pivotY', val)

    @_f.addMelDocs('polyMoveVertex', 'pivotZ')
    def setPivotZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'pivotZ', val)

    @_f.addMelDocs('polyMoveVertex', 'random')
    def setRandom(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'random', val)

    @_f.addMelDocs('polyMoveVertex', 'rotate')
    def setRotate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'rotate', val)

    @_f.addMelDocs('polyMoveVertex', 'rotateX')
    def setRotateX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'rotateX', val)

    @_f.addMelDocs('polyMoveVertex', 'rotateY')
    def setRotateY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'rotateY', val)

    @_f.addMelDocs('polyMoveVertex', 'rotateZ')
    def setRotateZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'rotateZ', val)

    @_f.addMelDocs('polyMoveVertex', 'scale')
    def setScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'scale', val)

    @_f.addMelDocs('polyMoveVertex', 'scaleX')
    def setScaleX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'scaleX', val)

    @_f.addMelDocs('polyMoveVertex', 'scaleY')
    def setScaleY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'scaleY', val)

    @_f.addMelDocs('polyMoveVertex', 'scaleZ')
    def setScaleZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'scaleZ', val)

    @_f.addMelDocs('polyMoveVertex', 'translate')
    def setTranslate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'translate', val)

    @_f.addMelDocs('polyMoveVertex', 'translateX')
    def setTranslateX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'translateX', val)

    @_f.addMelDocs('polyMoveVertex', 'translateY')
    def setTranslateY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'translateY', val)

    @_f.addMelDocs('polyMoveVertex', 'translateZ')
    def setTranslateZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'translateZ', val)

    @_f.addMelDocs('polyMoveVertex', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveVertex, kwargs, 'worldSpace', val)


class PolyMoveEdge(PolyMoveVertex):
    __melcmd__ = staticmethod(modeling.polyMoveEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyMoveEdge'
    __melnode__ = u'polyMoveEdge'
    __slots__ = ()

    @_f.addMelDocs('polyMoveEdge', 'localCenter')
    def getLocalCenter(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localCenter')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localRotate')
    def getLocalRotate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localRotate')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localRotateX')
    def getLocalRotateX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localRotateX')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localRotateY')
    def getLocalRotateY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localRotateY')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localRotateZ')
    def getLocalRotateZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localRotateZ')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localScale')
    def getLocalScale(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localScale')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localScaleX')
    def getLocalScaleX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localScaleX')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localScaleY')
    def getLocalScaleY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localScaleY')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localScaleZ')
    def getLocalScaleZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyMoveEdge, kwargs, 'localScaleZ')
        return res

    @_f.addMelDocs('polyMoveEdge', 'localCenter')
    def setLocalCenter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localCenter', val)

    @_f.addMelDocs('polyMoveEdge', 'localRotate')
    def setLocalRotate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localRotate', val)

    @_f.addMelDocs('polyMoveEdge', 'localRotateX')
    def setLocalRotateX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localRotateX', val)

    @_f.addMelDocs('polyMoveEdge', 'localRotateY')
    def setLocalRotateY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localRotateY', val)

    @_f.addMelDocs('polyMoveEdge', 'localRotateZ')
    def setLocalRotateZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localRotateZ', val)

    @_f.addMelDocs('polyMoveEdge', 'localScale')
    def setLocalScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localScale', val)

    @_f.addMelDocs('polyMoveEdge', 'localScaleX')
    def setLocalScaleX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localScaleX', val)

    @_f.addMelDocs('polyMoveEdge', 'localScaleY')
    def setLocalScaleY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localScaleY', val)

    @_f.addMelDocs('polyMoveEdge', 'localScaleZ')
    def setLocalScaleZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyMoveEdge, kwargs, 'localScaleZ', val)


class PolyExtrudeEdge(PolyMoveEdge):
    __melcmd__ = staticmethod(modeling.polyExtrudeEdge)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyExtrudeEdge'
    __melnode__ = u'polyExtrudeEdge'
    __slots__ = ()

    @_f.addMelDocs('polyExtrudeEdge', 'divisions')
    def getDivisions(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'divisions')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'keepFacesTogether')
    def getKeepFacesTogether(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'keepFacesTogether')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'offset')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'smoothingAngle')
    def getSmoothingAngle(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'smoothingAngle')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'taper')
    def getTaper(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'taper')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'taperCurve_FloatValue')
    def getTaperCurve_FloatValue(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'taperCurve_FloatValue')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'taperCurve_Interp')
    def getTaperCurve_Interp(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'taperCurve_Interp')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'taperCurve_Position')
    def getTaperCurve_Position(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'taperCurve_Position')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'thickness')
    def getThickness(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'thickness')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'twist')
    def getTwist(self, **kwargs):
        res = _f.asQuery(self, modeling.polyExtrudeEdge, kwargs, 'twist')
        return res

    @_f.addMelDocs('polyExtrudeEdge', 'divisions')
    def setDivisions(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'divisions', val)

    @_f.addMelDocs('polyExtrudeEdge', 'keepFacesTogether')
    def setKeepFacesTogether(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'keepFacesTogether', val)

    @_f.addMelDocs('polyExtrudeEdge', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'offset', val)

    @_f.addMelDocs('polyExtrudeEdge', 'smoothingAngle')
    def setSmoothingAngle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'smoothingAngle', val)

    @_f.addMelDocs('polyExtrudeEdge', 'taper')
    def setTaper(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'taper', val)

    @_f.addMelDocs('polyExtrudeEdge', 'taperCurve_FloatValue')
    def setTaperCurve_FloatValue(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'taperCurve_FloatValue', val)

    @_f.addMelDocs('polyExtrudeEdge', 'taperCurve_Interp')
    def setTaperCurve_Interp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'taperCurve_Interp', val)

    @_f.addMelDocs('polyExtrudeEdge', 'taperCurve_Position')
    def setTaperCurve_Position(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'taperCurve_Position', val)

    @_f.addMelDocs('polyExtrudeEdge', 'thickness')
    def setThickness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'thickness', val)

    @_f.addMelDocs('polyExtrudeEdge', 'twist')
    def setTwist(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyExtrudeEdge, kwargs, 'twist', val)


class PolyMoveFace(PolyMoveEdge):
    __melnode__ = u'polyMoveFace'
    __slots__ = ()


class PolyExtrudeFace(PolyMoveFace):
    __melnode__ = u'polyExtrudeFace'
    __slots__ = ()


class PolyChipOff(PolyMoveFace):
    __melcmd__ = staticmethod(modeling.polyChipOff)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyChipOff'
    __melnode__ = u'polyChipOff'
    __slots__ = ()

    @_f.addMelDocs('polyChipOff', 'attraction')
    def getAttraction(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'attraction')
        return res

    @_f.addMelDocs('polyChipOff', 'duplicate')
    def getDuplicate(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'duplicate')
        return res

    @_f.addMelDocs('polyChipOff', 'gravity')
    def getGravity(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'gravity')
        return res

    @_f.addMelDocs('polyChipOff', 'gravityX')
    def getGravityX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'gravityX')
        return res

    @_f.addMelDocs('polyChipOff', 'gravityY')
    def getGravityY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'gravityY')
        return res

    @_f.addMelDocs('polyChipOff', 'gravityZ')
    def getGravityZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'gravityZ')
        return res

    @_f.addMelDocs('polyChipOff', 'keepFacesTogether')
    def getKeepFacesTogether(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'keepFacesTogether')
        return res

    @_f.addMelDocs('polyChipOff', 'keepFacetTogether')
    def getKeepFacetTogether(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'keepFacetTogether')
        return res

    @_f.addMelDocs('polyChipOff', 'magnX')
    def getMagnX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'magnX')
        return res

    @_f.addMelDocs('polyChipOff', 'magnY')
    def getMagnY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'magnY')
        return res

    @_f.addMelDocs('polyChipOff', 'magnZ')
    def getMagnZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'magnZ')
        return res

    @_f.addMelDocs('polyChipOff', 'magnet')
    def getMagnet(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'magnet')
        return res

    @_f.addMelDocs('polyChipOff', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'offset')
        return res

    @_f.addMelDocs('polyChipOff', 'weight')
    def getWeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyChipOff, kwargs, 'weight')
        return res

    @_f.addMelDocs('polyChipOff', 'attraction')
    def setAttraction(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'attraction', val)

    @_f.addMelDocs('polyChipOff', 'duplicate')
    def setDuplicate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'duplicate', val)

    @_f.addMelDocs('polyChipOff', 'gravity')
    def setGravity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'gravity', val)

    @_f.addMelDocs('polyChipOff', 'gravityX')
    def setGravityX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'gravityX', val)

    @_f.addMelDocs('polyChipOff', 'gravityY')
    def setGravityY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'gravityY', val)

    @_f.addMelDocs('polyChipOff', 'gravityZ')
    def setGravityZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'gravityZ', val)

    @_f.addMelDocs('polyChipOff', 'keepFacesTogether')
    def setKeepFacesTogether(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'keepFacesTogether', val)

    @_f.addMelDocs('polyChipOff', 'keepFacetTogether')
    def setKeepFacetTogether(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'keepFacetTogether', val)

    @_f.addMelDocs('polyChipOff', 'magnX')
    def setMagnX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'magnX', val)

    @_f.addMelDocs('polyChipOff', 'magnY')
    def setMagnY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'magnY', val)

    @_f.addMelDocs('polyChipOff', 'magnZ')
    def setMagnZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'magnZ', val)

    @_f.addMelDocs('polyChipOff', 'magnet')
    def setMagnet(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'magnet', val)

    @_f.addMelDocs('polyChipOff', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'offset', val)

    @_f.addMelDocs('polyChipOff', 'weight')
    def setWeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyChipOff, kwargs, 'weight', val)


class PolyNormalPerVertex(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyNormalPerVertex)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyNormalPerVertex'
    __melnode__ = u'polyNormalPerVertex'
    __slots__ = ()

    @_f.addMelDocs('polyNormalPerVertex', 'allLocked')
    def getAllLocked(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'allLocked')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'deformable')
    def getDeformable(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'deformable')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'freezeNormal')
    def getFreezeNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'freezeNormal')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'normalX')
    def getNormalX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'normalX')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'normalXYZ')
    def getNormalXYZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'normalXYZ')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'normalY')
    def getNormalY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'normalY')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'normalZ')
    def getNormalZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'normalZ')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'relative')
    def getRelative(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'relative')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'unFreezeNormal')
    def getUnFreezeNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.polyNormalPerVertex, kwargs, 'unFreezeNormal')
        return res

    @_f.addMelDocs('polyNormalPerVertex', 'allLocked')
    def setAllLocked(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'allLocked', val)

    @_f.addMelDocs('polyNormalPerVertex', 'deformable')
    def setDeformable(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'deformable', val)

    @_f.addMelDocs('polyNormalPerVertex', 'freezeNormal')
    def setFreezeNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'freezeNormal', val)

    @_f.addMelDocs('polyNormalPerVertex', 'normalX')
    def setNormalX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'normalX', val)

    @_f.addMelDocs('polyNormalPerVertex', 'normalXYZ')
    def setNormalXYZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'normalXYZ', val)

    @_f.addMelDocs('polyNormalPerVertex', 'normalY')
    def setNormalY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'normalY', val)

    @_f.addMelDocs('polyNormalPerVertex', 'normalZ')
    def setNormalZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'normalZ', val)

    @_f.addMelDocs('polyNormalPerVertex', 'relative')
    def setRelative(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'relative', val)

    @_f.addMelDocs('polyNormalPerVertex', 'unFreezeNormal')
    def setUnFreezeNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyNormalPerVertex, kwargs, 'unFreezeNormal', val)


class PolyEditEdgeFlow(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyEditEdgeFlow)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyEditEdgeFlow'
    __melnode__ = u'polyEditEdgeFlow'
    __slots__ = ()

    @_f.addMelDocs('polyEditEdgeFlow', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyEditEdgeFlow, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyEditEdgeFlow', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyEditEdgeFlow, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyEditEdgeFlow', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyEditEdgeFlow, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyEditEdgeFlow', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyEditEdgeFlow, kwargs, 'caching', val)

    @_f.addMelDocs('polyEditEdgeFlow', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyEditEdgeFlow, kwargs, 'nodeState', val)


class PolyConnectComponents(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyConnectComponents)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyConnectComponents'
    __melnode__ = u'polyConnectComponents'
    __slots__ = ()

    @_f.addMelDocs('polyConnectComponents', 'adjustEdgeFlow')
    def getAdjustEdgeFlow(self, **kwargs):
        res = _f.asQuery(self, modeling.polyConnectComponents, kwargs, 'adjustEdgeFlow')
        return res

    @_f.addMelDocs('polyConnectComponents', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyConnectComponents, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyConnectComponents', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyConnectComponents, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyConnectComponents', 'insertWithEdgeFlow')
    def getInsertWithEdgeFlow(self, **kwargs):
        res = _f.asQuery(self, modeling.polyConnectComponents, kwargs, 'insertWithEdgeFlow')
        return res

    @_f.addMelDocs('polyConnectComponents', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyConnectComponents, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyConnectComponents', 'adjustEdgeFlow')
    def setAdjustEdgeFlow(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyConnectComponents, kwargs, 'adjustEdgeFlow', val)

    @_f.addMelDocs('polyConnectComponents', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyConnectComponents, kwargs, 'caching', val)

    @_f.addMelDocs('polyConnectComponents', 'insertWithEdgeFlow')
    def setInsertWithEdgeFlow(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyConnectComponents, kwargs, 'insertWithEdgeFlow', val)

    @_f.addMelDocs('polyConnectComponents', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyConnectComponents, kwargs, 'nodeState', val)


class PolySplit(PolyModifier):
    __melcmd__ = staticmethod(modeling.polySplit)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySplit'
    __melnode__ = u'polySplit'
    __slots__ = ()

    @_f.addMelDocs('polySplit', 'adjustEdgeFlow')
    def getAdjustEdgeFlow(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplit, kwargs, 'adjustEdgeFlow')
        return res

    @_f.addMelDocs('polySplit', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplit, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polySplit', 'insertWithEdgeFlow')
    def getInsertWithEdgeFlow(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplit, kwargs, 'insertWithEdgeFlow')
        return res

    @_f.addMelDocs('polySplit', 'subdivision')
    def getSubdivision(self, **kwargs):
        res = _f.asQuery(self, modeling.polySplit, kwargs, 'subdivision')
        return res

    @_f.addMelDocs('polySplit', 'adjustEdgeFlow')
    def setAdjustEdgeFlow(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplit, kwargs, 'adjustEdgeFlow', val)

    @_f.addMelDocs('polySplit', 'insertWithEdgeFlow')
    def setInsertWithEdgeFlow(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplit, kwargs, 'insertWithEdgeFlow', val)

    @_f.addMelDocs('polySplit', 'subdivision')
    def setSubdivision(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySplit, kwargs, 'subdivision', val)


class PolySubdFace(PolyModifier):
    __melnode__ = u'polySubdFace'
    __slots__ = ()


class PolyDelFacet(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyDelFacet)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyDelFacet'
    __melnode__ = u'polyDelFacet'
    __slots__ = ()

    @_f.addMelDocs('polyDelFacet', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelFacet, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyDelFacet', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelFacet, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyDelFacet', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyDelFacet, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyDelFacet', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDelFacet, kwargs, 'caching', val)

    @_f.addMelDocs('polyDelFacet', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyDelFacet, kwargs, 'nodeState', val)


class PolySmooth(PolyModifier):
    __melcmd__ = staticmethod(modeling.polySmooth)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySmooth'
    __melnode__ = u'polySmooth'
    __slots__ = ()

    @_f.addMelDocs('polySmooth', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'caching')
        return res

    @_f.addMelDocs('polySmooth', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polySmooth', 'continuity')
    def getContinuity(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'continuity')
        return res

    @_f.addMelDocs('polySmooth', 'divisions')
    def getDivisions(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'divisions')
        return res

    @_f.addMelDocs('polySmooth', 'keepBorder')
    def getKeepBorder(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'keepBorder')
        return res

    @_f.addMelDocs('polySmooth', 'keepHardEdge')
    def getKeepHardEdge(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'keepHardEdge')
        return res

    @_f.addMelDocs('polySmooth', 'keepSelectionBorder')
    def getKeepSelectionBorder(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'keepSelectionBorder')
        return res

    @_f.addMelDocs('polySmooth', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polySmooth', 'osdCreaseMethod')
    def getOsdCreaseMethod(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'osdCreaseMethod')
        return res

    @_f.addMelDocs('polySmooth', 'osdFvarBoundary')
    def getOsdFvarBoundary(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'osdFvarBoundary')
        return res

    @_f.addMelDocs('polySmooth', 'osdFvarPropagateCorners')
    def getOsdFvarPropagateCorners(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'osdFvarPropagateCorners')
        return res

    @_f.addMelDocs('polySmooth', 'osdSmoothTriangles')
    def getOsdSmoothTriangles(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'osdSmoothTriangles')
        return res

    @_f.addMelDocs('polySmooth', 'osdVertBoundary')
    def getOsdVertBoundary(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'osdVertBoundary')
        return res

    @_f.addMelDocs('polySmooth', 'propagateEdgeHardness')
    def getPropagateEdgeHardness(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'propagateEdgeHardness')
        return res

    @_f.addMelDocs('polySmooth', 'subdivisionType')
    def getSubdivisionType(self, **kwargs):
        res = _f.asQuery(self, modeling.polySmooth, kwargs, 'subdivisionType')
        return res

    @_f.addMelDocs('polySmooth', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'caching', val)

    @_f.addMelDocs('polySmooth', 'continuity')
    def setContinuity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'continuity', val)

    @_f.addMelDocs('polySmooth', 'divisions')
    def setDivisions(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'divisions', val)

    @_f.addMelDocs('polySmooth', 'keepBorder')
    def setKeepBorder(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'keepBorder', val)

    @_f.addMelDocs('polySmooth', 'keepHardEdge')
    def setKeepHardEdge(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'keepHardEdge', val)

    @_f.addMelDocs('polySmooth', 'keepSelectionBorder')
    def setKeepSelectionBorder(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'keepSelectionBorder', val)

    @_f.addMelDocs('polySmooth', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'nodeState', val)

    @_f.addMelDocs('polySmooth', 'osdCreaseMethod')
    def setOsdCreaseMethod(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'osdCreaseMethod', val)

    @_f.addMelDocs('polySmooth', 'osdFvarBoundary')
    def setOsdFvarBoundary(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'osdFvarBoundary', val)

    @_f.addMelDocs('polySmooth', 'osdFvarPropagateCorners')
    def setOsdFvarPropagateCorners(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'osdFvarPropagateCorners', val)

    @_f.addMelDocs('polySmooth', 'osdSmoothTriangles')
    def setOsdSmoothTriangles(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'osdSmoothTriangles', val)

    @_f.addMelDocs('polySmooth', 'osdVertBoundary')
    def setOsdVertBoundary(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'osdVertBoundary', val)

    @_f.addMelDocs('polySmooth', 'propagateEdgeHardness')
    def setPropagateEdgeHardness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'propagateEdgeHardness', val)

    @_f.addMelDocs('polySmooth', 'subdivisionType')
    def setSubdivisionType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySmooth, kwargs, 'subdivisionType', val)


class PolyCloseBorder(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyCloseBorder)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCloseBorder'
    __melnode__ = u'polyCloseBorder'
    __slots__ = ()

    @_f.addMelDocs('polyCloseBorder', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCloseBorder, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyCloseBorder', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCloseBorder, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyCloseBorder', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCloseBorder, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyCloseBorder', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCloseBorder, kwargs, 'caching', val)

    @_f.addMelDocs('polyCloseBorder', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCloseBorder, kwargs, 'nodeState', val)


class PolyTriangulate(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyTriangulate)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyTriangulate'
    __melnode__ = u'polyTriangulate'
    __slots__ = ()

    @_f.addMelDocs('polyTriangulate', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTriangulate, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyTriangulate', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTriangulate, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyTriangulate', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTriangulate, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyTriangulate', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTriangulate, kwargs, 'caching', val)

    @_f.addMelDocs('polyTriangulate', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTriangulate, kwargs, 'nodeState', val)


class PolyTransfer(PolyModifier):
    __melcmd__ = staticmethod(modeling.polyTransfer)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyTransfer'
    __melnode__ = u'polyTransfer'
    __slots__ = ()

    @_f.addMelDocs('polyTransfer', 'alternateObject')
    def getAlternateObject(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTransfer, kwargs, 'alternateObject')
        return res

    @_f.addMelDocs('polyTransfer', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTransfer, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyTransfer', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTransfer, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyTransfer', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTransfer, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyTransfer', 'uvSets')
    def getUvSets(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTransfer, kwargs, 'uvSets')
        return res

    @_f.addMelDocs('polyTransfer', 'vertexColor')
    def getVertexColor(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTransfer, kwargs, 'vertexColor')
        return res

    @_f.addMelDocs('polyTransfer', 'vertices')
    def getVertices(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTransfer, kwargs, 'vertices')
        return res

    @_f.addMelDocs('polyTransfer', 'alternateObject')
    def setAlternateObject(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTransfer, kwargs, 'alternateObject', val)

    @_f.addMelDocs('polyTransfer', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTransfer, kwargs, 'caching', val)

    @_f.addMelDocs('polyTransfer', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTransfer, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyTransfer', 'uvSets')
    def setUvSets(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTransfer, kwargs, 'uvSets', val)

    @_f.addMelDocs('polyTransfer', 'vertexColor')
    def setVertexColor(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTransfer, kwargs, 'vertexColor', val)

    @_f.addMelDocs('polyTransfer', 'vertices')
    def setVertices(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTransfer, kwargs, 'vertices', val)


class PolyCreator(PolyBase):
    __melnode__ = u'polyCreator'
    __slots__ = ()


class PolyCreateFace(PolyCreator):
    __melnode__ = u'polyCreateFace'
    __slots__ = ()


class PolyPrimitive(PolyCreator):
    __melcmd__ = staticmethod(modeling.polyPrimitive)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPrimitive'
    __melnode__ = u'polyPrimitive'
    __slots__ = ()

    @_f.addMelDocs('polyPrimitive', 'axis')
    def getAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'axis')
        return res

    @_f.addMelDocs('polyPrimitive', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('polyPrimitive', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('polyPrimitive', 'createUVs')
    def getCreateUVs(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'createUVs')
        res = int(res)
        return res

    @_f.addMelDocs('polyPrimitive', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'frozen')
        return res

    @_f.addMelDocs('polyPrimitive', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('polyPrimitive', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'radius')
        return res

    @_f.addMelDocs('polyPrimitive', 'sideLength')
    def getSideLength(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'sideLength')
        return res

    @_f.addMelDocs('polyPrimitive', 'texture')
    def getTexture(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrimitive, kwargs, 'texture')
        res = int(res)
        return res

    @_f.addMelDocs('polyPrimitive', 'axis')
    def setAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrimitive, kwargs, 'axis', val)

    @_f.addMelDocs('polyPrimitive', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrimitive, kwargs, 'caching', val)

    @_f.addMelDocs('polyPrimitive', 'createUVs')
    def setCreateUVs(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrimitive, kwargs, 'createUVs', val)

    @_f.addMelDocs('polyPrimitive', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrimitive, kwargs, 'frozen', val)

    @_f.addMelDocs('polyPrimitive', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrimitive, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyPrimitive', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrimitive, kwargs, 'radius', val)

    @_f.addMelDocs('polyPrimitive', 'sideLength')
    def setSideLength(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrimitive, kwargs, 'sideLength', val)

    @_f.addMelDocs('polyPrimitive', 'texture')
    def setTexture(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrimitive, kwargs, 'texture', val)


class PolyPlane(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyPlane)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPlane'
    __melnode__ = u'polyPlane'
    __slots__ = ()

    @_f.addMelDocs('polyPlane', 'height')
    def getHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPlane, kwargs, 'height')
        return res

    @_f.addMelDocs('polyPlane', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPlane, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polyPlane', 'subdivisionsWidth')
    def getSubdivisionsWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPlane, kwargs, 'subdivisionsWidth')
        res = int(res)
        return res

    @_f.addMelDocs('polyPlane', 'subdivisionsX')
    def getSubdivisionsX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPlane, kwargs, 'subdivisionsX')
        res = int(res)
        return res

    @_f.addMelDocs('polyPlane', 'subdivisionsY')
    def getSubdivisionsY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPlane, kwargs, 'subdivisionsY')
        res = int(res)
        return res

    @_f.addMelDocs('polyPlane', 'width')
    def getWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPlane, kwargs, 'width')
        return res

    @_f.addMelDocs('polyPlane', 'height')
    def setHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPlane, kwargs, 'height', val)

    @_f.addMelDocs('polyPlane', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPlane, kwargs, 'subdivisionsHeight', val)

    @_f.addMelDocs('polyPlane', 'subdivisionsWidth')
    def setSubdivisionsWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPlane, kwargs, 'subdivisionsWidth', val)

    @_f.addMelDocs('polyPlane', 'subdivisionsX')
    def setSubdivisionsX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPlane, kwargs, 'subdivisionsX', val)

    @_f.addMelDocs('polyPlane', 'subdivisionsY')
    def setSubdivisionsY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPlane, kwargs, 'subdivisionsY', val)

    @_f.addMelDocs('polyPlane', 'width')
    def setWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPlane, kwargs, 'width', val)


class PolyPrimitiveMisc(PolyPrimitive):
    __melcmd__ = staticmethod(other.polyPrimitiveMisc)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPrimitiveMisc'
    __melnode__ = u'polyPrimitiveMisc'
    __slots__ = ()


class PolyCone(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyCone)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCone'
    __melnode__ = u'polyCone'
    __slots__ = ()

    @_f.addMelDocs('polyCone', 'height')
    def getHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCone, kwargs, 'height')
        return res

    @_f.addMelDocs('polyCone', 'roundCap')
    def getRoundCap(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCone, kwargs, 'roundCap')
        res = bool(res)
        return res

    @_f.addMelDocs('polyCone', 'subdivisionsAxis')
    def getSubdivisionsAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCone, kwargs, 'subdivisionsAxis')
        res = int(res)
        return res

    @_f.addMelDocs('polyCone', 'subdivisionsCap')
    def getSubdivisionsCap(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCone, kwargs, 'subdivisionsCap')
        res = int(res)
        return res

    @_f.addMelDocs('polyCone', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCone, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polyCone', 'subdivisionsX')
    def getSubdivisionsX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCone, kwargs, 'subdivisionsX')
        res = int(res)
        return res

    @_f.addMelDocs('polyCone', 'subdivisionsY')
    def getSubdivisionsY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCone, kwargs, 'subdivisionsY')
        res = int(res)
        return res

    @_f.addMelDocs('polyCone', 'subdivisionsZ')
    def getSubdivisionsZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCone, kwargs, 'subdivisionsZ')
        res = int(res)
        return res

    @_f.addMelDocs('polyCone', 'height')
    def setHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCone, kwargs, 'height', val)

    @_f.addMelDocs('polyCone', 'roundCap')
    def setRoundCap(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCone, kwargs, 'roundCap', val)

    @_f.addMelDocs('polyCone', 'subdivisionsAxis')
    def setSubdivisionsAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCone, kwargs, 'subdivisionsAxis', val)

    @_f.addMelDocs('polyCone', 'subdivisionsCap')
    def setSubdivisionsCap(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCone, kwargs, 'subdivisionsCap', val)

    @_f.addMelDocs('polyCone', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCone, kwargs, 'subdivisionsHeight', val)

    @_f.addMelDocs('polyCone', 'subdivisionsX')
    def setSubdivisionsX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCone, kwargs, 'subdivisionsX', val)

    @_f.addMelDocs('polyCone', 'subdivisionsY')
    def setSubdivisionsY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCone, kwargs, 'subdivisionsY', val)

    @_f.addMelDocs('polyCone', 'subdivisionsZ')
    def setSubdivisionsZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCone, kwargs, 'subdivisionsZ', val)


class PolyCylinder(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyCylinder)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCylinder'
    __melnode__ = u'polyCylinder'
    __slots__ = ()

    @_f.addMelDocs('polyCylinder', 'height')
    def getHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCylinder, kwargs, 'height')
        return res

    @_f.addMelDocs('polyCylinder', 'roundCap')
    def getRoundCap(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCylinder, kwargs, 'roundCap')
        res = bool(res)
        return res

    @_f.addMelDocs('polyCylinder', 'subdivisionsAxis')
    def getSubdivisionsAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCylinder, kwargs, 'subdivisionsAxis')
        res = int(res)
        return res

    @_f.addMelDocs('polyCylinder', 'subdivisionsCaps')
    def getSubdivisionsCaps(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCylinder, kwargs, 'subdivisionsCaps')
        res = int(res)
        return res

    @_f.addMelDocs('polyCylinder', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCylinder, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polyCylinder', 'subdivisionsX')
    def getSubdivisionsX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCylinder, kwargs, 'subdivisionsX')
        res = int(res)
        return res

    @_f.addMelDocs('polyCylinder', 'subdivisionsY')
    def getSubdivisionsY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCylinder, kwargs, 'subdivisionsY')
        res = int(res)
        return res

    @_f.addMelDocs('polyCylinder', 'subdivisionsZ')
    def getSubdivisionsZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCylinder, kwargs, 'subdivisionsZ')
        res = int(res)
        return res

    @_f.addMelDocs('polyCylinder', 'height')
    def setHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCylinder, kwargs, 'height', val)

    @_f.addMelDocs('polyCylinder', 'roundCap')
    def setRoundCap(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCylinder, kwargs, 'roundCap', val)

    @_f.addMelDocs('polyCylinder', 'subdivisionsAxis')
    def setSubdivisionsAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCylinder, kwargs, 'subdivisionsAxis', val)

    @_f.addMelDocs('polyCylinder', 'subdivisionsCaps')
    def setSubdivisionsCaps(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCylinder, kwargs, 'subdivisionsCaps', val)

    @_f.addMelDocs('polyCylinder', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCylinder, kwargs, 'subdivisionsHeight', val)

    @_f.addMelDocs('polyCylinder', 'subdivisionsX')
    def setSubdivisionsX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCylinder, kwargs, 'subdivisionsX', val)

    @_f.addMelDocs('polyCylinder', 'subdivisionsY')
    def setSubdivisionsY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCylinder, kwargs, 'subdivisionsY', val)

    @_f.addMelDocs('polyCylinder', 'subdivisionsZ')
    def setSubdivisionsZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCylinder, kwargs, 'subdivisionsZ', val)


class PolyPipe(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyPipe)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPipe'
    __melnode__ = u'polyPipe'
    __slots__ = ()

    @_f.addMelDocs('polyPipe', 'height')
    def getHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPipe, kwargs, 'height')
        return res

    @_f.addMelDocs('polyPipe', 'roundCap')
    def getRoundCap(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPipe, kwargs, 'roundCap')
        res = bool(res)
        return res

    @_f.addMelDocs('polyPipe', 'subdivisionsAxis')
    def getSubdivisionsAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPipe, kwargs, 'subdivisionsAxis')
        res = int(res)
        return res

    @_f.addMelDocs('polyPipe', 'subdivisionsCaps')
    def getSubdivisionsCaps(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPipe, kwargs, 'subdivisionsCaps')
        res = int(res)
        return res

    @_f.addMelDocs('polyPipe', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPipe, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polyPipe', 'thickness')
    def getThickness(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPipe, kwargs, 'thickness')
        return res

    @_f.addMelDocs('polyPipe', 'height')
    def setHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPipe, kwargs, 'height', val)

    @_f.addMelDocs('polyPipe', 'roundCap')
    def setRoundCap(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPipe, kwargs, 'roundCap', val)

    @_f.addMelDocs('polyPipe', 'subdivisionsAxis')
    def setSubdivisionsAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPipe, kwargs, 'subdivisionsAxis', val)

    @_f.addMelDocs('polyPipe', 'subdivisionsCaps')
    def setSubdivisionsCaps(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPipe, kwargs, 'subdivisionsCaps', val)

    @_f.addMelDocs('polyPipe', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPipe, kwargs, 'subdivisionsHeight', val)

    @_f.addMelDocs('polyPipe', 'thickness')
    def setThickness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPipe, kwargs, 'thickness', val)


class PolySphere(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polySphere)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySphere'
    __melnode__ = u'polySphere'
    __slots__ = ()

    @_f.addMelDocs('polySphere', 'subdivisionsAxis')
    def getSubdivisionsAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.polySphere, kwargs, 'subdivisionsAxis')
        res = int(res)
        return res

    @_f.addMelDocs('polySphere', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polySphere, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polySphere', 'subdivisionsX')
    def getSubdivisionsX(self, **kwargs):
        res = _f.asQuery(self, modeling.polySphere, kwargs, 'subdivisionsX')
        res = int(res)
        return res

    @_f.addMelDocs('polySphere', 'subdivisionsY')
    def getSubdivisionsY(self, **kwargs):
        res = _f.asQuery(self, modeling.polySphere, kwargs, 'subdivisionsY')
        res = int(res)
        return res

    @_f.addMelDocs('polySphere', 'subdivisionsAxis')
    def setSubdivisionsAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySphere, kwargs, 'subdivisionsAxis', val)

    @_f.addMelDocs('polySphere', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySphere, kwargs, 'subdivisionsHeight', val)

    @_f.addMelDocs('polySphere', 'subdivisionsX')
    def setSubdivisionsX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySphere, kwargs, 'subdivisionsX', val)

    @_f.addMelDocs('polySphere', 'subdivisionsY')
    def setSubdivisionsY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySphere, kwargs, 'subdivisionsY', val)


class PolyHelix(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyHelix)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyHelix'
    __melnode__ = u'polyHelix'
    __slots__ = ()

    @_f.addMelDocs('polyHelix', 'coils')
    def getCoils(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'coils')
        return res

    @_f.addMelDocs('polyHelix', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'direction')
        res = int(res)
        return res

    @_f.addMelDocs('polyHelix', 'height')
    def getHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'height')
        return res

    @_f.addMelDocs('polyHelix', 'roundCap')
    def getRoundCap(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'roundCap')
        res = bool(res)
        return res

    @_f.addMelDocs('polyHelix', 'subdivisionsAxis')
    def getSubdivisionsAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'subdivisionsAxis')
        res = int(res)
        return res

    @_f.addMelDocs('polyHelix', 'subdivisionsCaps')
    def getSubdivisionsCaps(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'subdivisionsCaps')
        res = int(res)
        return res

    @_f.addMelDocs('polyHelix', 'subdivisionsCoil')
    def getSubdivisionsCoil(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'subdivisionsCoil')
        res = int(res)
        return res

    @_f.addMelDocs('polyHelix', 'useOldInitBehaviour')
    def getUseOldInitBehaviour(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'useOldInitBehaviour')
        res = bool(res)
        return res

    @_f.addMelDocs('polyHelix', 'width')
    def getWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyHelix, kwargs, 'width')
        return res

    @_f.addMelDocs('polyHelix', 'coils')
    def setCoils(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'coils', val)

    @_f.addMelDocs('polyHelix', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'direction', val)

    @_f.addMelDocs('polyHelix', 'height')
    def setHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'height', val)

    @_f.addMelDocs('polyHelix', 'roundCap')
    def setRoundCap(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'roundCap', val)

    @_f.addMelDocs('polyHelix', 'subdivisionsAxis')
    def setSubdivisionsAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'subdivisionsAxis', val)

    @_f.addMelDocs('polyHelix', 'subdivisionsCaps')
    def setSubdivisionsCaps(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'subdivisionsCaps', val)

    @_f.addMelDocs('polyHelix', 'subdivisionsCoil')
    def setSubdivisionsCoil(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'subdivisionsCoil', val)

    @_f.addMelDocs('polyHelix', 'useOldInitBehaviour')
    def setUseOldInitBehaviour(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'useOldInitBehaviour', val)

    @_f.addMelDocs('polyHelix', 'width')
    def setWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyHelix, kwargs, 'width', val)


class PolyCube(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyCube)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCube'
    __melnode__ = u'polyCube'
    __slots__ = ()

    @_f.addMelDocs('polyCube', 'depth')
    def getDepth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'depth')
        return res

    @_f.addMelDocs('polyCube', 'height')
    def getHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'height')
        return res

    @_f.addMelDocs('polyCube', 'subdivisionsDepth')
    def getSubdivisionsDepth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'subdivisionsDepth')
        res = int(res)
        return res

    @_f.addMelDocs('polyCube', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polyCube', 'subdivisionsWidth')
    def getSubdivisionsWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'subdivisionsWidth')
        res = int(res)
        return res

    @_f.addMelDocs('polyCube', 'subdivisionsX')
    def getSubdivisionsX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'subdivisionsX')
        res = int(res)
        return res

    @_f.addMelDocs('polyCube', 'subdivisionsY')
    def getSubdivisionsY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'subdivisionsY')
        res = int(res)
        return res

    @_f.addMelDocs('polyCube', 'subdivisionsZ')
    def getSubdivisionsZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'subdivisionsZ')
        res = int(res)
        return res

    @_f.addMelDocs('polyCube', 'width')
    def getWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCube, kwargs, 'width')
        return res

    @_f.addMelDocs('polyCube', 'depth')
    def setDepth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'depth', val)

    @_f.addMelDocs('polyCube', 'height')
    def setHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'height', val)

    @_f.addMelDocs('polyCube', 'subdivisionsDepth')
    def setSubdivisionsDepth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'subdivisionsDepth', val)

    @_f.addMelDocs('polyCube', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'subdivisionsHeight', val)

    @_f.addMelDocs('polyCube', 'subdivisionsWidth')
    def setSubdivisionsWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'subdivisionsWidth', val)

    @_f.addMelDocs('polyCube', 'subdivisionsX')
    def setSubdivisionsX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'subdivisionsX', val)

    @_f.addMelDocs('polyCube', 'subdivisionsY')
    def setSubdivisionsY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'subdivisionsY', val)

    @_f.addMelDocs('polyCube', 'subdivisionsZ')
    def setSubdivisionsZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'subdivisionsZ', val)

    @_f.addMelDocs('polyCube', 'width')
    def setWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCube, kwargs, 'width', val)


class PolyPyramid(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyPyramid)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPyramid'
    __melnode__ = u'polyPyramid'
    __slots__ = ()

    @_f.addMelDocs('polyPyramid', 'numberOfSides')
    def getNumberOfSides(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPyramid, kwargs, 'numberOfSides')
        res = int(res)
        return res

    @_f.addMelDocs('polyPyramid', 'numderOfSides')
    def getNumderOfSides(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPyramid, kwargs, 'numderOfSides')
        res = int(res)
        return res

    @_f.addMelDocs('polyPyramid', 'subdivisionsCaps')
    def getSubdivisionsCaps(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPyramid, kwargs, 'subdivisionsCaps')
        res = int(res)
        return res

    @_f.addMelDocs('polyPyramid', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPyramid, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polyPyramid', 'numberOfSides')
    def setNumberOfSides(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPyramid, kwargs, 'numberOfSides', val)

    @_f.addMelDocs('polyPyramid', 'numderOfSides')
    def setNumderOfSides(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPyramid, kwargs, 'numderOfSides', val)

    @_f.addMelDocs('polyPyramid', 'subdivisionsCaps')
    def setSubdivisionsCaps(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPyramid, kwargs, 'subdivisionsCaps', val)

    @_f.addMelDocs('polyPyramid', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPyramid, kwargs, 'subdivisionsHeight', val)


class PolyTorus(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyTorus)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyTorus'
    __melnode__ = u'polyTorus'
    __slots__ = ()

    @_f.addMelDocs('polyTorus', 'sectionRadius')
    def getSectionRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTorus, kwargs, 'sectionRadius')
        return res

    @_f.addMelDocs('polyTorus', 'subdivisionsAxis')
    def getSubdivisionsAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTorus, kwargs, 'subdivisionsAxis')
        res = int(res)
        return res

    @_f.addMelDocs('polyTorus', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTorus, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polyTorus', 'subdivisionsX')
    def getSubdivisionsX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTorus, kwargs, 'subdivisionsX')
        res = int(res)
        return res

    @_f.addMelDocs('polyTorus', 'subdivisionsY')
    def getSubdivisionsY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTorus, kwargs, 'subdivisionsY')
        res = int(res)
        return res

    @_f.addMelDocs('polyTorus', 'twist')
    def getTwist(self, **kwargs):
        res = _f.asQuery(self, modeling.polyTorus, kwargs, 'twist')
        return res

    @_f.addMelDocs('polyTorus', 'sectionRadius')
    def setSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTorus, kwargs, 'sectionRadius', val)

    @_f.addMelDocs('polyTorus', 'subdivisionsAxis')
    def setSubdivisionsAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTorus, kwargs, 'subdivisionsAxis', val)

    @_f.addMelDocs('polyTorus', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTorus, kwargs, 'subdivisionsHeight', val)

    @_f.addMelDocs('polyTorus', 'subdivisionsX')
    def setSubdivisionsX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTorus, kwargs, 'subdivisionsX', val)

    @_f.addMelDocs('polyTorus', 'subdivisionsY')
    def setSubdivisionsY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTorus, kwargs, 'subdivisionsY', val)

    @_f.addMelDocs('polyTorus', 'twist')
    def setTwist(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyTorus, kwargs, 'twist', val)


class PolyPrism(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyPrism)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPrism'
    __melnode__ = u'polyPrism'
    __slots__ = ()

    @_f.addMelDocs('polyPrism', 'length')
    def getLength(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrism, kwargs, 'length')
        return res

    @_f.addMelDocs('polyPrism', 'numberOfSides')
    def getNumberOfSides(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrism, kwargs, 'numberOfSides')
        res = int(res)
        return res

    @_f.addMelDocs('polyPrism', 'numderOfSides')
    def getNumderOfSides(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrism, kwargs, 'numderOfSides')
        res = int(res)
        return res

    @_f.addMelDocs('polyPrism', 'subdivisionsCaps')
    def getSubdivisionsCaps(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrism, kwargs, 'subdivisionsCaps')
        res = int(res)
        return res

    @_f.addMelDocs('polyPrism', 'subdivisionsHeight')
    def getSubdivisionsHeight(self, **kwargs):
        res = _f.asQuery(self, modeling.polyPrism, kwargs, 'subdivisionsHeight')
        res = int(res)
        return res

    @_f.addMelDocs('polyPrism', 'length')
    def setLength(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrism, kwargs, 'length', val)

    @_f.addMelDocs('polyPrism', 'numberOfSides')
    def setNumberOfSides(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrism, kwargs, 'numberOfSides', val)

    @_f.addMelDocs('polyPrism', 'numderOfSides')
    def setNumderOfSides(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrism, kwargs, 'numderOfSides', val)

    @_f.addMelDocs('polyPrism', 'subdivisionsCaps')
    def setSubdivisionsCaps(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrism, kwargs, 'subdivisionsCaps', val)

    @_f.addMelDocs('polyPrism', 'subdivisionsHeight')
    def setSubdivisionsHeight(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyPrism, kwargs, 'subdivisionsHeight', val)


class PolyPlatonicSolid(PolyPrimitive):
    __melcmd__ = staticmethod(modeling.polyPlatonicSolid)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyPlatonicSolid'
    __melnode__ = u'polyPlatonicSolid'
    __slots__ = ()


class PolyUnite(PolyCreator):
    __melcmd__ = staticmethod(modeling.polyUnite)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyUnite'
    __melnode__ = u'polyUnite'
    __slots__ = ()

    @_f.addMelDocs('polyUnite', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyUnite, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyUnite', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyUnite, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyUnite', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyUnite, kwargs, 'caching', val)

    @_f.addMelDocs('polyUnite', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyUnite, kwargs, 'nodeState', val)


class PolyBoolOp(PolyUnite):
    __melcmd__ = staticmethod(modeling.polyBoolOp)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyBoolOp'
    __melnode__ = u'polyBoolOp'
    __slots__ = ()

    @_f.addMelDocs('polyBoolOp', 'faceAreaThreshold')
    def getFaceAreaThreshold(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBoolOp, kwargs, 'faceAreaThreshold')
        return res

    @_f.addMelDocs('polyBoolOp', 'mergeUVSets')
    def getMergeUVSets(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBoolOp, kwargs, 'mergeUVSets')
        return res

    @_f.addMelDocs('polyBoolOp', 'operation')
    def getOperation(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBoolOp, kwargs, 'operation')
        return res

    @_f.addMelDocs('polyBoolOp', 'preserveColor')
    def getPreserveColor(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBoolOp, kwargs, 'preserveColor')
        return res

    @_f.addMelDocs('polyBoolOp', 'useThresholds')
    def getUseThresholds(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBoolOp, kwargs, 'useThresholds')
        return res

    @_f.addMelDocs('polyBoolOp', 'vertexDistanceThreshold')
    def getVertexDistanceThreshold(self, **kwargs):
        res = _f.asQuery(self, modeling.polyBoolOp, kwargs, 'vertexDistanceThreshold')
        return res

    @_f.addMelDocs('polyBoolOp', 'faceAreaThreshold')
    def setFaceAreaThreshold(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBoolOp, kwargs, 'faceAreaThreshold', val)

    @_f.addMelDocs('polyBoolOp', 'mergeUVSets')
    def setMergeUVSets(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBoolOp, kwargs, 'mergeUVSets', val)

    @_f.addMelDocs('polyBoolOp', 'operation')
    def setOperation(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBoolOp, kwargs, 'operation', val)

    @_f.addMelDocs('polyBoolOp', 'preserveColor')
    def setPreserveColor(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBoolOp, kwargs, 'preserveColor', val)

    @_f.addMelDocs('polyBoolOp', 'useThresholds')
    def setUseThresholds(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBoolOp, kwargs, 'useThresholds', val)

    @_f.addMelDocs('polyBoolOp', 'vertexDistanceThreshold')
    def setVertexDistanceThreshold(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyBoolOp, kwargs, 'vertexDistanceThreshold', val)


class PolyCBoolOp(PolyBoolOp):
    __melcmd__ = staticmethod(modeling.polyCBoolOp)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyCBoolOp'
    __melnode__ = u'polyCBoolOp'
    __slots__ = ()

    @_f.addMelDocs('polyCBoolOp', 'classification')
    def getClassification(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCBoolOp, kwargs, 'classification')
        return res

    @_f.addMelDocs('polyCBoolOp', 'useCarveBooleans')
    def getUseCarveBooleans(self, **kwargs):
        res = _f.asQuery(self, modeling.polyCBoolOp, kwargs, 'useCarveBooleans')
        return res

    @_f.addMelDocs('polyCBoolOp', 'classification')
    def setClassification(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCBoolOp, kwargs, 'classification', val)

    @_f.addMelDocs('polyCBoolOp', 'useCarveBooleans')
    def setUseCarveBooleans(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyCBoolOp, kwargs, 'useCarveBooleans', val)


class TexLattice(DependNode):
    __melnode__ = u'texLattice'
    __slots__ = ()


class DisplayLayerManager(DependNode):
    __melnode__ = u'displayLayerManager'
    __slots__ = ()


class LodThresholds(DependNode):
    __melnode__ = u'lodThresholds'
    __slots__ = ()


class TimeToUnitConversion(DependNode):
    __melnode__ = u'timeToUnitConversion'
    __slots__ = ()


class HardwareRenderingGlobals(DependNode):
    __melnode__ = u'hardwareRenderingGlobals'
    __slots__ = ()


class NodeGraphEditorBookmarks(DependNode):
    __melnode__ = u'nodeGraphEditorBookmarks'
    __slots__ = ()


class Clamp(DependNode):
    __melnode__ = u'clamp'
    __slots__ = ()


class RenderPassSet(DependNode):
    __melnode__ = u'renderPassSet'
    __slots__ = ()


class CopyColorSet(DependNode):
    __melnode__ = u'copyColorSet'
    __slots__ = ()


class SkinBinding(DependNode):
    __melnode__ = u'skinBinding'
    __slots__ = ()


class ShadingDependNode(DependNode):
    __melnode__ = u'shadingDependNode'
    __slots__ = ()


class OceanShader(ShadingDependNode):
    __melnode__ = u'oceanShader'
    __slots__ = ()


class SamplerInfo(ShadingDependNode):
    __melnode__ = u'samplerInfo'
    __slots__ = ()


class LayeredShader(ShadingDependNode):
    __apicls__ = _api.MFnLayeredShader
    __melnode__ = u'layeredShader'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnLayeredShader, 'color')
    def getColor(self, lIndex=0):
        # type: (int) -> Color
        do, final_do, outTypes = _f.getDoArgs([lIndex], [('lIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'color', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MColor', None)
        return res

    @_f.addApiDocs(_api.MFnLayeredShader, 'compositingFlag')
    def getCompositingFlag(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'compositingFlag')
        return _f.ApiArgUtil._castResult(self, res, 'short', None)

    @_f.addApiDocs(_api.MFnLayeredShader, 'glowColor')
    def getGlowColor(self, lIndex=0):
        # type: (int) -> Color
        do, final_do, outTypes = _f.getDoArgs([lIndex], [('lIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'glowColor', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MColor', None)
        return res

    @_f.addApiDocs(_api.MFnLayeredShader, 'hardwareColor')
    def getHardwareColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'hardwareColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLayeredShader, 'hardwareShader')
    def getHardwareShader(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'hardwareShader')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLayeredShader, 'transparency')
    def getTransparency(self, lIndex=0):
        # type: (int) -> Color
        do, final_do, outTypes = _f.getDoArgs([lIndex], [('lIndex', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'transparency', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MColor', None)
        return res

    @_f.addApiDocs(_api.MFnLayeredShader, 'setColor')
    def setColor(self, col, lIndex=0):
        # type: (Color, int) -> None
        do, final_do, outTypes = _f.processApiArgs([col, lIndex], [('col', 'MColor', 'in', None), ('lIndex', 'uint', 'in', None)], self.getColor, self.setColor, ['lIndex'])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'setColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnLayeredShader, 'setCompositingFlag')
    def setCompositingFlag(self, cflag):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([cflag], [('cflag', 'short', 'in', None)], self.getCompositingFlag, self.setCompositingFlag, [])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'setCompositingFlag', final_do)
        return res

    @_f.addApiDocs(_api.MFnLayeredShader, 'setGlowColor')
    def setGlowColor(self, glow_color, lIndex=0):
        # type: (Color, int) -> None
        do, final_do, outTypes = _f.processApiArgs([glow_color, lIndex], [('glow_color', 'MColor', 'in', None), ('lIndex', 'uint', 'in', None)], self.getGlowColor, self.setGlowColor, ['lIndex'])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'setGlowColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnLayeredShader, 'setHardwareColor')
    def setHardwareColor(self, hardware_color):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([hardware_color], [('hardware_color', 'MColor', 'in', None)], self.getHardwareColor, self.setHardwareColor, [])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'setHardwareColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnLayeredShader, 'setHardwareShader')
    def setHardwareShader(self, hardware_shader):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([hardware_shader], [('hardware_shader', 'MColor', 'in', None)], self.getHardwareShader, self.setHardwareShader, [])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'setHardwareShader', final_do)
        return res

    @_f.addApiDocs(_api.MFnLayeredShader, 'setTransparency')
    def setTransparency(self, transp, lIndex=0):
        # type: (Color, int) -> None
        do, final_do, outTypes = _f.processApiArgs([transp, lIndex], [('transp', 'MColor', 'in', None), ('lIndex', 'uint', 'in', None)], self.getTransparency, self.setTransparency, ['lIndex'])
        res = _f.getProxyResult(self, _api.MFnLayeredShader, 'setTransparency', final_do)
        return res


class ShadingMap(ShadingDependNode):
    __melnode__ = u'shadingMap'
    __slots__ = ()


class Bump2d(ShadingDependNode):
    __melnode__ = u'bump2d'
    __slots__ = ()


class Place2dTexture(ShadingDependNode):
    __melnode__ = u'place2dTexture'
    __slots__ = ()


class Lambert(ShadingDependNode):
    __apicls__ = _api.MFnLambertShader
    __melnode__ = u'lambert'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnLambertShader, 'ambientColor')
    def getAmbientColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'ambientColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'color')
    def getColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'color')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'diffuseCoeff')
    def getDiffuseCoeff(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'diffuseCoeff')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'glowIntensity')
    def getGlowIntensity(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'glowIntensity')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'hideSource')
    def getHideSource(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'hideSource')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'incandescence')
    def getIncandescence(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'incandescence')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'refractedRayDepthLimit')
    def getRefractedRayDepthLimit(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'refractedRayDepthLimit')
        return _f.ApiArgUtil._castResult(self, res, 'short', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'refractiveIndex')
    def getRefractiveIndex(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'refractiveIndex')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'rtRefractedColor')
    def getRtRefractedColor(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'rtRefractedColor')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'translucenceCoeff')
    def getTranslucenceCoeff(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'translucenceCoeff')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'transparency')
    def getTransparency(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'transparency')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLambertShader, 'setAmbientColor')
    def setAmbientColor(self, ambient_color):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([ambient_color], [('ambient_color', 'MColor', 'in', None)], self.getAmbientColor, self.setAmbientColor, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setAmbientColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setColor')
    def setColor(self, col):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([col], [('col', 'MColor', 'in', None)], self.getColor, self.setColor, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setDiffuseCoeff')
    def setDiffuseCoeff(self, diffuse_coeff):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([diffuse_coeff], [('diffuse_coeff', 'float', 'in', None)], self.getDiffuseCoeff, self.setDiffuseCoeff, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setDiffuseCoeff', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setGlowIntensity')
    def setGlowIntensity(self, glow_intensity):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([glow_intensity], [('glow_intensity', 'float', 'in', None)], self.getGlowIntensity, self.setGlowIntensity, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setGlowIntensity', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setHideSource')
    def setHideSource(self, hide_source):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([hide_source], [('hide_source', 'bool', 'in', None)], self.getHideSource, self.setHideSource, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setHideSource', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setIncandescence')
    def setIncandescence(self, incand):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([incand], [('incand', 'MColor', 'in', None)], self.getIncandescence, self.setIncandescence, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setIncandescence', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setRefractedRayDepthLimit')
    def setRefractedRayDepthLimit(self, refracted_ray_depth_limit):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([refracted_ray_depth_limit], [('refracted_ray_depth_limit', 'short', 'in', None)], self.getRefractedRayDepthLimit, self.setRefractedRayDepthLimit, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setRefractedRayDepthLimit', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setRefractiveIndex')
    def setRefractiveIndex(self, refractive_index):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([refractive_index], [('refractive_index', 'float', 'in', None)], self.getRefractiveIndex, self.setRefractiveIndex, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setRefractiveIndex', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setRtRefractedColor')
    def setRtRefractedColor(self, rt_refracted_color):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([rt_refracted_color], [('rt_refracted_color', 'bool', 'in', None)], self.getRtRefractedColor, self.setRtRefractedColor, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setRtRefractedColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setTranslucenceCoeff')
    def setTranslucenceCoeff(self, translucence_coeff):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([translucence_coeff], [('translucence_coeff', 'float', 'in', None)], self.getTranslucenceCoeff, self.setTranslucenceCoeff, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setTranslucenceCoeff', final_do)
        return res

    @_f.addApiDocs(_api.MFnLambertShader, 'setTransparency')
    def setTransparency(self, transp):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([transp], [('transp', 'MColor', 'in', None)], self.getTransparency, self.setTransparency, [])
        res = _f.getProxyResult(self, _api.MFnLambertShader, 'setTransparency', final_do)
        return res


class Reflect(Lambert):
    __apicls__ = _api.MFnReflectShader
    __melnode__ = u'reflect'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnReflectShader, 'reflectedColor')
    def getReflectedColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnReflectShader, 'reflectedColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnReflectShader, 'reflectedRayDepthLimit')
    def getReflectedRayDepthLimit(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnReflectShader, 'reflectedRayDepthLimit')
        return _f.ApiArgUtil._castResult(self, res, 'short', None)

    @_f.addApiDocs(_api.MFnReflectShader, 'reflectivity')
    def getReflectivity(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnReflectShader, 'reflectivity')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnReflectShader, 'specularColor')
    def getSpecularColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnReflectShader, 'specularColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnReflectShader, 'setReflectedColor')
    def setReflectedColor(self, reflected_color):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([reflected_color], [('reflected_color', 'MColor', 'in', None)], self.getReflectedColor, self.setReflectedColor, [])
        res = _f.getProxyResult(self, _api.MFnReflectShader, 'setReflectedColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnReflectShader, 'setReflectedRayDepthLimit')
    def setReflectedRayDepthLimit(self, reflected_ray_depth_limit):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([reflected_ray_depth_limit], [('reflected_ray_depth_limit', 'short', 'in', None)], self.getReflectedRayDepthLimit, self.setReflectedRayDepthLimit, [])
        res = _f.getProxyResult(self, _api.MFnReflectShader, 'setReflectedRayDepthLimit', final_do)
        return res

    @_f.addApiDocs(_api.MFnReflectShader, 'setReflectivity')
    def setReflectivity(self, reflect):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([reflect], [('reflect', 'float', 'in', None)], self.getReflectivity, self.setReflectivity, [])
        res = _f.getProxyResult(self, _api.MFnReflectShader, 'setReflectivity', final_do)
        return res

    @_f.addApiDocs(_api.MFnReflectShader, 'setSpecularColor')
    def setSpecularColor(self, specular_color):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([specular_color], [('specular_color', 'MColor', 'in', None)], self.getSpecularColor, self.setSpecularColor, [])
        res = _f.getProxyResult(self, _api.MFnReflectShader, 'setSpecularColor', final_do)
        return res


class Phong(Reflect):
    __apicls__ = _api.MFnPhongShader
    __melnode__ = u'phong'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnPhongShader, 'cosPower')
    def getCosPower(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnPhongShader, 'cosPower')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnPhongShader, 'setCosPower')
    def setCosPower(self, cos_power):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([cos_power], [('cos_power', 'float', 'in', None)], self.getCosPower, self.setCosPower, [])
        res = _f.getProxyResult(self, _api.MFnPhongShader, 'setCosPower', final_do)
        return res


class Blinn(Reflect):
    __apicls__ = _api.MFnBlinnShader
    __melnode__ = u'blinn'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnBlinnShader, 'eccentricity')
    def getEccentricity(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnBlinnShader, 'eccentricity')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnBlinnShader, 'specularRollOff')
    def getSpecularRollOff(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnBlinnShader, 'specularRollOff')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnBlinnShader, 'setEccentricity')
    def setEccentricity(self, eccentr):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([eccentr], [('eccentr', 'float', 'in', None)], self.getEccentricity, self.setEccentricity, [])
        res = _f.getProxyResult(self, _api.MFnBlinnShader, 'setEccentricity', final_do)
        return res

    @_f.addApiDocs(_api.MFnBlinnShader, 'setSpecularRollOff')
    def setSpecularRollOff(self, specular_rolloff):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([specular_rolloff], [('specular_rolloff', 'float', 'in', None)], self.getSpecularRollOff, self.setSpecularRollOff, [])
        res = _f.getProxyResult(self, _api.MFnBlinnShader, 'setSpecularRollOff', final_do)
        return res


class Anisotropic(Reflect):
    __apicls__ = _api.MFnAnisotropyShader
    __melnode__ = u'anisotropic'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'anisotropicReflectivity')
    def getAnisotropicReflectivity(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'anisotropicReflectivity')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'correlationX')
    def getCorrelationX(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'correlationX')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'correlationY')
    def getCorrelationY(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'correlationY')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'rotateAngle')
    def getRotateAngle(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'rotateAngle')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'roughness')
    def getRoughness(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'roughness')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'tangentUCamera')
    def getTangentUCamera(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'tangentUCamera')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'tangentVCamera')
    def getTangentVCamera(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'tangentVCamera')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'setAnisotropicReflectivity')
    def setAnisotropicReflectivity(self, anisotropic_reflectivity):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([anisotropic_reflectivity], [('anisotropic_reflectivity', 'bool', 'in', None)], self.getAnisotropicReflectivity, self.setAnisotropicReflectivity, [])
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'setAnisotropicReflectivity', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'setCorrelationX')
    def setCorrelationX(self, correl_x):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([correl_x], [('correl_x', 'float', 'in', None)], self.getCorrelationX, self.setCorrelationX, [])
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'setCorrelationX', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'setCorrelationY')
    def setCorrelationY(self, correl_y):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([correl_y], [('correl_y', 'float', 'in', None)], self.getCorrelationY, self.setCorrelationY, [])
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'setCorrelationY', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'setRotateAngle')
    def setRotateAngle(self, rotate_angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([rotate_angle], [('rotate_angle', 'float', 'in', None)], self.getRotateAngle, self.setRotateAngle, [])
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'setRotateAngle', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'setRoughness')
    def setRoughness(self, roughness):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([roughness], [('roughness', 'float', 'in', None)], self.getRoughness, self.setRoughness, [])
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'setRoughness', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'setTangentUCamera')
    def setTangentUCamera(self, tangu_camera):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([tangu_camera], [('tangu_camera', 'MColor', 'in', None)], self.getTangentUCamera, self.setTangentUCamera, [])
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'setTangentUCamera', final_do)
        return res

    @_f.addApiDocs(_api.MFnAnisotropyShader, 'setTangentVCamera')
    def setTangentVCamera(self, tangv_camera):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([tangv_camera], [('tangv_camera', 'MColor', 'in', None)], self.getTangentVCamera, self.setTangentVCamera, [])
        res = _f.getProxyResult(self, _api.MFnAnisotropyShader, 'setTangentVCamera', final_do)
        return res


class PhongE(Reflect):
    __apicls__ = _api.MFnPhongEShader
    __melnode__ = u'phongE'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnPhongEShader, 'highlightSize')
    def getHighlightSize(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnPhongEShader, 'highlightSize')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnPhongEShader, 'roughness')
    def getRoughness(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnPhongEShader, 'roughness')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnPhongEShader, 'whiteness')
    def getWhiteness(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnPhongEShader, 'whiteness')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnPhongEShader, 'setHighlightSize')
    def setHighlightSize(self, highlight_size):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([highlight_size], [('highlight_size', 'float', 'in', None)], self.getHighlightSize, self.setHighlightSize, [])
        res = _f.getProxyResult(self, _api.MFnPhongEShader, 'setHighlightSize', final_do)
        return res

    @_f.addApiDocs(_api.MFnPhongEShader, 'setRoughness')
    def setRoughness(self, roughness):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([roughness], [('roughness', 'float', 'in', None)], self.getRoughness, self.setRoughness, [])
        res = _f.getProxyResult(self, _api.MFnPhongEShader, 'setRoughness', final_do)
        return res

    @_f.addApiDocs(_api.MFnPhongEShader, 'setWhiteness')
    def setWhiteness(self, whiteness):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([whiteness], [('whiteness', 'MColor', 'in', None)], self.getWhiteness, self.setWhiteness, [])
        res = _f.getProxyResult(self, _api.MFnPhongEShader, 'setWhiteness', final_do)
        return res


class HairTubeShader(Reflect):
    __melnode__ = u'hairTubeShader'
    __slots__ = ()


class BaseShadingSwitch(ShadingDependNode):
    __melnode__ = u'baseShadingSwitch'
    __slots__ = ()


class DoubleShadingSwitch(BaseShadingSwitch):
    __melnode__ = u'doubleShadingSwitch'
    __slots__ = ()


class QuadShadingSwitch(BaseShadingSwitch):
    __melnode__ = u'quadShadingSwitch'
    __slots__ = ()


class TripleShadingSwitch(BaseShadingSwitch):
    __melnode__ = u'tripleShadingSwitch'
    __slots__ = ()


class SingleShadingSwitch(BaseShadingSwitch):
    __melnode__ = u'singleShadingSwitch'
    __slots__ = ()


class LayeredTexture(ShadingDependNode):
    __melnode__ = u'layeredTexture'
    __slots__ = ()


class RampShader(ShadingDependNode):
    __melnode__ = u'rampShader'
    __slots__ = ()


class UseBackground(ShadingDependNode):
    __melnode__ = u'useBackground'
    __slots__ = ()


class Texture3d(ShadingDependNode):
    __melnode__ = u'texture3d'
    __slots__ = ()


class Brownian(Texture3d):
    __melnode__ = u'brownian'
    __slots__ = ()


class Crater(Texture3d):
    __melnode__ = u'crater'
    __slots__ = ()


class SolidFractal(Texture3d):
    __melnode__ = u'solidFractal'
    __slots__ = ()


class Projection(Texture3d):
    __melnode__ = u'projection'
    __slots__ = ()


class Mandelbrot3D(Texture3d):
    __melnode__ = u'mandelbrot3D'
    __slots__ = ()


class Marble(Texture3d):
    __melnode__ = u'marble'
    __slots__ = ()


class Leather(Texture3d):
    __melnode__ = u'leather'
    __slots__ = ()


class VolumeNoise(Texture3d):
    __melnode__ = u'volumeNoise'
    __slots__ = ()


class Snow(Texture3d):
    __melnode__ = u'snow'
    __slots__ = ()


class Wood(Texture3d):
    __melnode__ = u'wood'
    __slots__ = ()


class Rock(Texture3d):
    __melnode__ = u'rock'
    __slots__ = ()


class Stucco(Texture3d):
    __melnode__ = u'stucco'
    __slots__ = ()


class Cloud(Texture3d):
    __melnode__ = u'cloud'
    __slots__ = ()


class Granite(Texture3d):
    __melnode__ = u'granite'
    __slots__ = ()


class ParticleCloud(ShadingDependNode):
    __melnode__ = u'particleCloud'
    __slots__ = ()


class PlusMinusAverage(ShadingDependNode):
    __melnode__ = u'plusMinusAverage'
    __slots__ = ()


class Texture2d(ShadingDependNode):
    __melnode__ = u'texture2d'
    __slots__ = ()


class Fractal(Texture2d):
    __melnode__ = u'fractal'
    __slots__ = ()


class Water(Texture2d):
    __melnode__ = u'water'
    __slots__ = ()


class Noise(Texture2d):
    __melnode__ = u'noise'
    __slots__ = ()


class TadskAssetInstanceNode_TdnTx2D(Texture2d):
    __melnode__ = u'TadskAssetInstanceNode_TdnTx2D'
    __slots__ = ()


class Stencil(Texture2d):
    __melnode__ = u'stencil'
    __slots__ = ()


class Checker(Texture2d):
    __melnode__ = u'checker'
    __slots__ = ()


class Mountain(Texture2d):
    __melnode__ = u'mountain'
    __slots__ = ()


class Mandelbrot(Texture2d):
    __melnode__ = u'mandelbrot'
    __slots__ = ()


class Ramp(Texture2d):
    __melnode__ = u'ramp'
    __slots__ = ()


class Ocean(Texture2d):
    __melnode__ = u'ocean'
    __slots__ = ()


class Grid(Texture2d):
    __melcmd__ = staticmethod(modeling.grid)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'grid'
    __melnode__ = u'grid'
    __slots__ = ()

    @_f.addMelDocs('grid', 'default')
    def getDefault(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'default')
        return res

    @_f.addMelDocs('grid', 'displayAxes')
    def getDisplayAxes(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'displayAxes')
        return res

    @_f.addMelDocs('grid', 'displayAxesBold')
    def getDisplayAxesBold(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'displayAxesBold')
        return res

    @_f.addMelDocs('grid', 'displayDivisionLines')
    def getDisplayDivisionLines(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'displayDivisionLines')
        return res

    @_f.addMelDocs('grid', 'displayGridLines')
    def getDisplayGridLines(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'displayGridLines')
        return res

    @_f.addMelDocs('grid', 'displayOrthographicLabels')
    def getDisplayOrthographicLabels(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'displayOrthographicLabels')
        return res

    @_f.addMelDocs('grid', 'displayPerspectiveLabels')
    def getDisplayPerspectiveLabels(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'displayPerspectiveLabels')
        return res

    @_f.addMelDocs('grid', 'divisions')
    def getDivisions(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'divisions')
        return res

    @_f.addMelDocs('grid', 'orthographicLabelPosition')
    def getOrthographicLabelPosition(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'orthographicLabelPosition')
        return res

    @_f.addMelDocs('grid', 'perspectiveLabelPosition')
    def getPerspectiveLabelPosition(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'perspectiveLabelPosition')
        return res

    @_f.addMelDocs('grid', 'size')
    def getSize(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'size')
        return res

    @_f.addMelDocs('grid', 'spacing')
    def getSpacing(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'spacing')
        return res

    @_f.addMelDocs('grid', 'style')
    def getStyle(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'style')
        return res

    @_f.addMelDocs('grid', 'toggle')
    def getToggle(self, **kwargs):
        res = _f.asQuery(self, modeling.grid, kwargs, 'toggle')
        return res


class Bulge(Texture2d):
    __melnode__ = u'bulge'
    __slots__ = ()


class Cloth(Texture2d):
    __melnode__ = u'cloth'
    __slots__ = ()


class File(Texture2d):
    __melnode__ = u'file'
    __slots__ = ()


class Movie(File):
    __melnode__ = u'movie'
    __slots__ = ()


class PsdFileTex(File):
    __melnode__ = u'psdFileTex'
    __slots__ = ()


class HwShader(ShadingDependNode):
    __melnode__ = u'hwShader'
    __slots__ = ()


class THhwShader(HwShader):
    __melnode__ = u'THhwShader'
    __slots__ = ()


class THhardwareShader(HwShader):
    __melnode__ = u'THhardwareShader'
    __slots__ = ()


class ParticleSamplerInfo(ShadingDependNode):
    __melnode__ = u'particleSamplerInfo'
    __slots__ = ()


class LightFog(ShadingDependNode):
    __melnode__ = u'lightFog'
    __slots__ = ()


class EnvFog(LightFog):
    __melnode__ = u'envFog'
    __slots__ = ()


class VectorProduct(ShadingDependNode):
    __melnode__ = u'vectorProduct'
    __slots__ = ()


class TextureEnv(ShadingDependNode):
    __melnode__ = u'textureEnv'
    __slots__ = ()


class EnvBall(TextureEnv):
    __melnode__ = u'envBall'
    __slots__ = ()


class EnvChrome(TextureEnv):
    __melnode__ = u'envChrome'
    __slots__ = ()


class EnvSphere(TextureEnv):
    __melnode__ = u'envSphere'
    __slots__ = ()


class EnvCube(TextureEnv):
    __melnode__ = u'envCube'
    __slots__ = ()


class EnvSky(TextureEnv):
    __melnode__ = u'envSky'
    __slots__ = ()


class VolumeFog(ShadingDependNode):
    __melnode__ = u'volumeFog'
    __slots__ = ()


class MultiplyDivide(ShadingDependNode):
    __melnode__ = u'multiplyDivide'
    __slots__ = ()


class SubdivCollapse(DependNode):
    __melnode__ = u'subdivCollapse'
    __slots__ = ()


class Network(DependNode):
    __melnode__ = u'network'
    __slots__ = ()


class HoldMatrix(DependNode):
    __melnode__ = u'holdMatrix'
    __slots__ = ()


class CreateColorSet(DependNode):
    __melnode__ = u'createColorSet'
    __slots__ = ()


class ClipLibrary(DependNode):
    __melnode__ = u'clipLibrary'
    __slots__ = ()


class PolySeparate(DependNode):
    __melcmd__ = staticmethod(modeling.polySeparate)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polySeparate'
    __melnode__ = u'polySeparate'
    __slots__ = ()

    @_f.addMelDocs('polySeparate', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polySeparate, kwargs, 'caching')
        return res

    @_f.addMelDocs('polySeparate', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polySeparate, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polySeparate', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySeparate, kwargs, 'caching', val)

    @_f.addMelDocs('polySeparate', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polySeparate, kwargs, 'nodeState', val)


class CharacterMap(DependNode):
    __melcmd__ = staticmethod(animation.characterMap)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'characterMap'
    __melnode__ = u'characterMap'
    __slots__ = ()

    @_f.addMelDocs('characterMap', 'mapAttr')
    def getMapAttr(self, **kwargs):
        res = _f.asQuery(self, animation.characterMap, kwargs, 'mapAttr')
        return res

    @_f.addMelDocs('characterMap', 'mapNode')
    def getMapNode(self, **kwargs):
        res = _f.asQuery(self, animation.characterMap, kwargs, 'mapNode')
        return res

    @_f.addMelDocs('characterMap', 'mapping')
    def getMapping(self, **kwargs):
        res = _f.asQuery(self, animation.characterMap, kwargs, 'mapping')
        return res

    @_f.addMelDocs('characterMap', 'proposedMapping')
    def getProposedMapping(self, **kwargs):
        res = _f.asQuery(self, animation.characterMap, kwargs, 'proposedMapping')
        return res

    @_f.addMelDocs('characterMap', 'mapAttr')
    def setMapAttr(self, val=True, **kwargs):
        return _f.asEdit(self, animation.characterMap, kwargs, 'mapAttr', val)

    @_f.addMelDocs('characterMap', 'unmapAttr')
    def unmapAttr(self, val=True, **kwargs):
        return _f.asEdit(self, animation.characterMap, kwargs, 'unmapAttr', val)


class NodeGraphEditorBookmarkInfo(DependNode):
    __melnode__ = u'nodeGraphEditorBookmarkInfo'
    __slots__ = ()


class THdependNode(DependNode):
    __melnode__ = u'THdependNode'
    __slots__ = ()


class AttrHierarchyTest(DependNode):
    __melnode__ = u'attrHierarchyTest'
    __slots__ = ()


class CameraSet(DependNode):
    __apicls__ = _api.MFnCameraSet
    __melcmd__ = staticmethod(rendering.cameraSet)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'cameraSet'
    __melnode__ = u'cameraSet'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnCameraSet, 'appendLayer')
    def appendLayer(self, camera, set):
        # type: (general.PyNode, general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([camera, set], [('camera', 'MDagPath', 'in', None), ('set', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'appendLayer', final_do)
        return res

    @_f.addMelDocs('cameraSet', 'appendTo')
    def appendTo(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'appendTo', val)

    @_f.addApiDocs(_api.MFnCameraSet, 'clear')
    def clear(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'clear')
        return res

    @_f.addMelDocs('cameraSet', 'deleteAll')
    def deleteAll(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'deleteAll', val)

    @_f.addApiDocs(_api.MFnCameraSet, 'deleteLayer')
    def deleteLayer(self, index):
        # type: (int) -> None
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'deleteLayer', final_do)
        return res

    @_f.addMelDocs('cameraSet', 'active')
    def getActive(self, **kwargs):
        res = _f.asQuery(self, rendering.cameraSet, kwargs, 'active')
        return res

    @_f.addMelDocs('cameraSet', 'camera')
    def getCamera(self, **kwargs):
        res = _f.asQuery(self, rendering.cameraSet, kwargs, 'camera')
        return res

    @_f.addMelDocs('cameraSet', 'clearDepth')
    def getClearDepth(self, **kwargs):
        res = _f.asQuery(self, rendering.cameraSet, kwargs, 'clearDepth')
        return res

    @_f.addMelDocs('cameraSet', 'layer')
    def getLayer(self, **kwargs):
        res = _f.asQuery(self, rendering.cameraSet, kwargs, 'layer')
        return res

    @_f.addApiDocs(_api.MFnCameraSet, 'getLayerCamera')
    def getLayerCamera(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None), ('camera', 'MDagPath', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'getLayerCamera', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCameraSet, 'getLayerClearDepthValue')
    def getLayerClearDepthValue(self, index):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None), ('depth', 'bool', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'getLayerClearDepthValue', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCameraSet, 'getLayerOrder')
    def getLayerOrder(self, index):
        # type: (int) -> int
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None), ('order', 'int', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'getLayerOrder', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCameraSet, 'getLayerSceneData')
    def getLayerSceneData(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None), ('set', 'MObject', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'getLayerSceneData', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCameraSet, 'getNumLayers')
    def getNumLayers(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'getNumLayers')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('cameraSet', 'objectSet')
    def getObjectSet(self, **kwargs):
        res = _f.asQuery(self, rendering.cameraSet, kwargs, 'objectSet')
        return res

    @_f.addMelDocs('cameraSet', 'order')
    def getOrder(self, **kwargs):
        res = _f.asQuery(self, rendering.cameraSet, kwargs, 'order')
        return res

    @_f.addMelDocs('cameraSet', 'insertAt')
    def insertAt(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'insertAt', val)

    @_f.addApiDocs(_api.MFnCameraSet, 'insertLayer')
    def insertLayer(self, index, camera, set):
        # type: (int, general.PyNode, general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([index, camera, set], [('index', 'uint', 'in', None), ('camera', 'MDagPath', 'in', None), ('set', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'insertLayer', final_do)
        return res

    @_f.addApiDocs(_api.MFnCameraSet, 'isLayerActive')
    def isLayerActive(self, index):
        # type: (int) -> bool
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'isLayerActive', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addMelDocs('cameraSet', 'active')
    def setActive(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'active', val)

    @_f.addMelDocs('cameraSet', 'camera')
    def setCamera(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'camera', val)

    @_f.addMelDocs('cameraSet', 'clearDepth')
    def setClearDepth(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'clearDepth', val)

    @_f.addMelDocs('cameraSet', 'layer')
    def setLayer(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'layer', val)

    @_f.addApiDocs(_api.MFnCameraSet, 'setLayerActive')
    def setLayerActive(self, index, isActive):
        # type: (int, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([index, isActive], [('index', 'uint', 'in', None), ('isActive', 'bool', 'in', None)], self.isLayerActive, self.setLayerActive, ['index'])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'setLayerActive', final_do)
        return res

    @_f.addApiDocs(_api.MFnCameraSet, 'setLayerCamera')
    def setLayerCamera(self, index, camera):
        # type: (int, general.PyNode) -> None
        do, final_do, outTypes = _f.processApiArgs([index, camera], [('index', 'uint', 'in', None), ('camera', 'MDagPath', 'in', None)], self.getLayerCamera, self.setLayerCamera, ['index'])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'setLayerCamera', final_do)
        return res

    @_f.addApiDocs(_api.MFnCameraSet, 'setLayerClearDepthValue')
    def setLayerClearDepthValue(self, index, depth):
        # type: (int, bool) -> None
        do, final_do, outTypes = _f.processApiArgs([index, depth], [('index', 'uint', 'in', None), ('depth', 'bool', 'in', None)], self.getLayerClearDepthValue, self.setLayerClearDepthValue, ['index'])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'setLayerClearDepthValue', final_do)
        return res

    @_f.addApiDocs(_api.MFnCameraSet, 'setLayerOrder')
    def setLayerOrder(self, index, order):
        # type: (int, int) -> None
        do, final_do, outTypes = _f.processApiArgs([index, order], [('index', 'uint', 'in', None), ('order', 'int', 'in', None)], self.getLayerOrder, self.setLayerOrder, ['index'])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'setLayerOrder', final_do)
        return res

    @_f.addApiDocs(_api.MFnCameraSet, 'setLayerSceneData')
    def setLayerSceneData(self, index, set):
        # type: (int, general.PyNode) -> None
        do, final_do, outTypes = _f.processApiArgs([index, set], [('index', 'uint', 'in', None), ('set', 'MObject', 'in', None)], self.getLayerSceneData, self.setLayerSceneData, ['index'])
        res = _f.getProxyResult(self, _api.MFnCameraSet, 'setLayerSceneData', final_do)
        return res

    @_f.addMelDocs('cameraSet', 'objectSet')
    def setObjectSet(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'objectSet', val)

    @_f.addMelDocs('cameraSet', 'order')
    def setOrder(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraSet, kwargs, 'order', val)


class THcameraSet(CameraSet):
    __melnode__ = u'THcameraSet'
    __slots__ = ()


class EditMetadata(DependNode):
    __melcmd__ = staticmethod(modeling.editMetadata)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'editMetadata'
    __melnode__ = u'editMetadata'
    __slots__ = ()

    @_f.addMelDocs('editMetadata', 'channelName')
    def getChannelName(self, **kwargs):
        res = _f.asQuery(self, modeling.editMetadata, kwargs, 'channelName')
        return res

    @_f.addMelDocs('editMetadata', 'channelType')
    def getChannelType(self, **kwargs):
        res = _f.asQuery(self, modeling.editMetadata, kwargs, 'channelType')
        return res

    @_f.addMelDocs('editMetadata', 'index')
    def getIndex(self, **kwargs):
        res = _f.asQuery(self, modeling.editMetadata, kwargs, 'index')
        return res

    @_f.addMelDocs('editMetadata', 'indexType')
    def getIndexType(self, **kwargs):
        res = _f.asQuery(self, modeling.editMetadata, kwargs, 'indexType')
        return res

    @_f.addMelDocs('editMetadata', 'scene')
    def getScene(self, **kwargs):
        res = _f.asQuery(self, modeling.editMetadata, kwargs, 'scene')
        return res

    @_f.addMelDocs('editMetadata', 'streamName')
    def getStreamName(self, **kwargs):
        res = _f.asQuery(self, modeling.editMetadata, kwargs, 'streamName')
        return res


class Script(DependNode):
    __melnode__ = u'script'
    __slots__ = ()


class Unknown(DependNode):
    __melnode__ = u'unknown'
    __slots__ = ()


class MakeGroup(DependNode):
    __melnode__ = u'makeGroup'
    __slots__ = ()


class CurveFromMesh(DependNode):
    __melnode__ = u'curveFromMesh'
    __slots__ = ()


class CurveFromMeshEdge(CurveFromMesh):
    __melnode__ = u'curveFromMeshEdge'
    __slots__ = ()


class CurveFromMeshCoM(CurveFromMesh):
    __melnode__ = u'curveFromMeshCoM'
    __slots__ = ()


class DistanceBetween(DependNode):
    __melnode__ = u'distanceBetween'
    __slots__ = ()


class NComponent(DependNode):
    __melnode__ = u'nComponent'
    __slots__ = ()


class ClipToGhostData(DependNode):
    __melnode__ = u'clipToGhostData'
    __slots__ = ()


class GeomBind(DependNode):
    __melcmd__ = staticmethod(animation.geomBind)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'geomBind'
    __melnode__ = u'geomBind'
    __slots__ = ()

    @_f.addMelDocs('geomBind', 'falloff')
    def getFalloff(self, **kwargs):
        res = _f.asQuery(self, animation.geomBind, kwargs, 'falloff')
        return res

    @_f.addMelDocs('geomBind', 'geodesicVoxelParams')
    def getGeodesicVoxelParams(self, **kwargs):
        res = _f.asQuery(self, animation.geomBind, kwargs, 'geodesicVoxelParams')
        return res

    @_f.addMelDocs('geomBind', 'maxInfluences')
    def getMaxInfluences(self, **kwargs):
        res = _f.asQuery(self, animation.geomBind, kwargs, 'maxInfluences')
        return res

    @_f.addMelDocs('geomBind', 'falloff')
    def setFalloff(self, val=True, **kwargs):
        return _f.asEdit(self, animation.geomBind, kwargs, 'falloff', val)

    @_f.addMelDocs('geomBind', 'geodesicVoxelParams')
    def setGeodesicVoxelParams(self, val=True, **kwargs):
        return _f.asEdit(self, animation.geomBind, kwargs, 'geodesicVoxelParams', val)

    @_f.addMelDocs('geomBind', 'maxInfluences')
    def setMaxInfluences(self, val=True, **kwargs):
        return _f.asEdit(self, animation.geomBind, kwargs, 'maxInfluences', val)


class TrackInfoManager(DependNode):
    __melnode__ = u'trackInfoManager'
    __slots__ = ()


class DisplacementShader(DependNode):
    __melnode__ = u'displacementShader'
    __slots__ = ()


class CurveNormalizer(DependNode):
    __melnode__ = u'curveNormalizer'
    __slots__ = ()


class CurveNormalizerAngle(CurveNormalizer):
    __melnode__ = u'curveNormalizerAngle'
    __slots__ = ()


class CurveNormalizerLinear(CurveNormalizer):
    __melnode__ = u'curveNormalizerLinear'
    __slots__ = ()


class GeoConnector(DependNode):
    __melnode__ = u'geoConnector'
    __slots__ = ()


class DefaultTextureList(DependNode):
    __melnode__ = u'defaultTextureList'
    __slots__ = ()


class HairConstraint(Shape):
    __melnode__ = u'hairConstraint'
    __slots__ = ()


class GeoConnectable(Shape):
    __melnode__ = u'geoConnectable'
    __slots__ = ()


class StereoRigCamera(Camera):
    __melnode__ = u'stereoRigCamera'
    __slots__ = ()


class BaseLattice(Shape):
    __melnode__ = u'baseLattice'
    __slots__ = ()


class Light(Shape):
    __apicls__ = _api.MFnLight
    __melnode__ = u'light'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnLight, 'centerOfIllumination')
    def getCenterOfIllumination(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnLight, 'centerOfIllumination')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnLight, 'color')
    def getColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLight, 'color')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLight, 'intensity')
    def getIntensity(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnLight, 'intensity')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnLight, 'numShadowSamples')
    def getNumShadowSamples(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnLight, 'numShadowSamples')
        return _f.ApiArgUtil._castResult(self, res, 'short', None)

    @_f.addApiDocs(_api.MFnLight, 'opticalFXvisibility')
    def getOpticalFXvisibility(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLight, 'opticalFXvisibility')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLight, 'rayDepthLimit')
    def getRayDepthLimit(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnLight, 'rayDepthLimit')
        return _f.ApiArgUtil._castResult(self, res, 'short', None)

    @_f.addApiDocs(_api.MFnLight, 'shadowColor')
    def getShadowColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLight, 'shadowColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLight, 'useRayTraceShadows')
    def getUseRayTraceShadows(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnLight, 'useRayTraceShadows')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnLight, 'lightAmbient')
    def lightAmbient(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnLight, 'lightAmbient')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnLight, 'lightDiffuse')
    def lightDiffuse(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnLight, 'lightDiffuse')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnLight, 'lightDirection')
    def lightDirection(self, instance, space='world'):
        # type: (int, datatypes.Space.Space) -> FloatVector
        do, final_do, outTypes = _f.getDoArgs([instance, space], [('instance', 'int', 'in', None), ('space', ('MSpace', 'Space'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnLight, 'lightDirection', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MFloatVector', None)
        return res

    @_f.addApiDocs(_api.MFnLight, 'lightIntensity')
    def lightIntensity(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnLight, 'lightIntensity')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnLight, 'lightSpecular')
    def lightSpecular(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnLight, 'lightSpecular')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnLight, 'setCenterOfIllumination')
    def setCenterOfIllumination(self, dist):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([dist], [('dist', 'double', 'in', u'linear')], self.getCenterOfIllumination, self.setCenterOfIllumination, [])
        res = _f.getProxyResult(self, _api.MFnLight, 'setCenterOfIllumination', final_do)
        return res

    @_f.addApiDocs(_api.MFnLight, 'setColor')
    def setColor(self, col):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([col], [('col', 'MColor', 'in', None)], self.getColor, self.setColor, [])
        res = _f.getProxyResult(self, _api.MFnLight, 'setColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnLight, 'setIntensity')
    def setIntensity(self, intens):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([intens], [('intens', 'float', 'in', None)], self.getIntensity, self.setIntensity, [])
        res = _f.getProxyResult(self, _api.MFnLight, 'setIntensity', final_do)
        return res

    @_f.addApiDocs(_api.MFnLight, 'setNumShadowSamples')
    def setNumShadowSamples(self, num_shadow_samples):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([num_shadow_samples], [('num_shadow_samples', 'short', 'in', None)], self.getNumShadowSamples, self.setNumShadowSamples, [])
        res = _f.getProxyResult(self, _api.MFnLight, 'setNumShadowSamples', final_do)
        return res

    @_f.addApiDocs(_api.MFnLight, 'setOpticalFXvisibility')
    def setOpticalFXvisibility(self, visibility):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([visibility], [('visibility', 'MColor', 'in', None)], self.getOpticalFXvisibility, self.setOpticalFXvisibility, [])
        res = _f.getProxyResult(self, _api.MFnLight, 'setOpticalFXvisibility', final_do)
        return res

    @_f.addApiDocs(_api.MFnLight, 'setRayDepthLimit')
    def setRayDepthLimit(self, ray_depth_limit):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([ray_depth_limit], [('ray_depth_limit', 'short', 'in', None)], self.getRayDepthLimit, self.setRayDepthLimit, [])
        res = _f.getProxyResult(self, _api.MFnLight, 'setRayDepthLimit', final_do)
        return res

    @_f.addApiDocs(_api.MFnLight, 'setShadowColor')
    def setShadowColor(self, shadow_color):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([shadow_color], [('shadow_color', 'MColor', 'in', None)], self.getShadowColor, self.setShadowColor, [])
        res = _f.getProxyResult(self, _api.MFnLight, 'setShadowColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnLight, 'setUseRayTraceShadows')
    def setUseRayTraceShadows(self, useRayTraceShadows):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([useRayTraceShadows], [('useRayTraceShadows', 'bool', 'in', None)], self.getUseRayTraceShadows, self.setUseRayTraceShadows, [])
        res = _f.getProxyResult(self, _api.MFnLight, 'setUseRayTraceShadows', final_do)
        return res


class TadskAssetInstanceNode_TlightShape(Light):
    __melnode__ = u'TadskAssetInstanceNode_TlightShape'
    __slots__ = ()


class RenderLight(Light):
    __melnode__ = u'renderLight'
    __slots__ = ()


class NonAmbientLightShapeNode(RenderLight):
    __apicls__ = _api.MFnNonAmbientLight
    __melnode__ = u'nonAmbientLightShapeNode'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnNonAmbientLight, 'decayRate')
    def getDecayRate(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNonAmbientLight, 'decayRate')
        return _f.ApiArgUtil._castResult(self, res, 'short', None)

    @_f.addApiDocs(_api.MFnNonAmbientLight, 'setDecayRate')
    def setDecayRate(self, decay_rate):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([decay_rate], [('decay_rate', 'short', 'in', None)], self.getDecayRate, self.setDecayRate, [])
        res = _f.getProxyResult(self, _api.MFnNonAmbientLight, 'setDecayRate', final_do)
        return res


class NonExtendedLightShapeNode(NonAmbientLightShapeNode):
    __apicls__ = _api.MFnNonExtendedLight
    __melnode__ = u'nonExtendedLightShapeNode'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'castSoftShadows')
    def getCastSoftShadows(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'castSoftShadows')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'depthMapBias')
    def getDepthMapBias(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'depthMapBias')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'depthMapFilterSize')
    def getDepthMapFilterSize(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'depthMapFilterSize')
        return _f.ApiArgUtil._castResult(self, res, 'short', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'depthMapFocus')
    def getDepthMapFocus(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'depthMapFocus')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'depthMapResolution')
    def getDepthMapResolution(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'depthMapResolution')
        return _f.ApiArgUtil._castResult(self, res, 'short', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'depthMapWidthFocus')
    def getDepthMapWidthFocus(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'depthMapWidthFocus')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'shadowRadius')
    def getShadowRadius(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'shadowRadius')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'useDepthMapAutoFocus')
    def getUseDepthMapAutoFocus(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'useDepthMapAutoFocus')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'useDepthMapShadows')
    def getUseDepthMapShadows(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'useDepthMapShadows')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setCastSoftShadows')
    def setCastSoftShadows(self, cast_soft_shadows):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([cast_soft_shadows], [('cast_soft_shadows', 'bool', 'in', None)], self.getCastSoftShadows, self.setCastSoftShadows, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setCastSoftShadows', final_do)
        return res

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setDepthMapBias')
    def setDepthMapBias(self, depth_map_bias):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([depth_map_bias], [('depth_map_bias', 'float', 'in', None)], self.getDepthMapBias, self.setDepthMapBias, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setDepthMapBias', final_do)
        return res

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setDepthMapFilterSize')
    def setDepthMapFilterSize(self, depth_map_filter_size):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([depth_map_filter_size], [('depth_map_filter_size', 'short', 'in', None)], self.getDepthMapFilterSize, self.setDepthMapFilterSize, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setDepthMapFilterSize', final_do)
        return res

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setDepthMapFocus')
    def setDepthMapFocus(self, depth_map_focus):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([depth_map_focus], [('depth_map_focus', 'float', 'in', None)], self.getDepthMapFocus, self.setDepthMapFocus, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setDepthMapFocus', final_do)
        return res

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setDepthMapResolution')
    def setDepthMapResolution(self, depth_map_resolution):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([depth_map_resolution], [('depth_map_resolution', 'short', 'in', None)], self.getDepthMapResolution, self.setDepthMapResolution, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setDepthMapResolution', final_do)
        return res

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setDepthMapWidthFocus')
    def setDepthMapWidthFocus(self, depth_map_width_focus):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([depth_map_width_focus], [('depth_map_width_focus', 'float', 'in', None)], self.getDepthMapWidthFocus, self.setDepthMapWidthFocus, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setDepthMapWidthFocus', final_do)
        return res

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setShadowRadius')
    def setShadowRadius(self, shadow_radius):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([shadow_radius], [('shadow_radius', 'float', 'in', None)], self.getShadowRadius, self.setShadowRadius, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setShadowRadius', final_do)
        return res

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setUseDepthMapAutoFocus')
    def setUseDepthMapAutoFocus(self, use_depth_map_auto_focus):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([use_depth_map_auto_focus], [('use_depth_map_auto_focus', 'bool', 'in', None)], self.getUseDepthMapAutoFocus, self.setUseDepthMapAutoFocus, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setUseDepthMapAutoFocus', final_do)
        return res

    @_f.addApiDocs(_api.MFnNonExtendedLight, 'setUseDepthMapShadows')
    def setUseDepthMapShadows(self, use_depth_map):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([use_depth_map], [('use_depth_map', 'bool', 'in', None)], self.getUseDepthMapShadows, self.setUseDepthMapShadows, [])
        res = _f.getProxyResult(self, _api.MFnNonExtendedLight, 'setUseDepthMapShadows', final_do)
        return res


class AreaLight(NonExtendedLightShapeNode):
    __apicls__ = _api.MFnAreaLight
    __melnode__ = u'areaLight'
    __slots__ = ()


class PointLight(NonExtendedLightShapeNode):
    __apicls__ = _api.MFnPointLight
    __melcmd__ = staticmethod(rendering.pointLight)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'pointLight'
    __melnode__ = u'pointLight'
    __slots__ = ()

    @_f.addMelDocs('pointLight', 'discRadius')
    def getDiscRadius(self, **kwargs):
        res = _f.asQuery(self, rendering.pointLight, kwargs, 'discRadius')
        return res

    @_f.addMelDocs('pointLight', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, rendering.pointLight, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('pointLight', 'rgb')
    def getRgb(self, **kwargs):
        res = _f.asQuery(self, rendering.pointLight, kwargs, 'rgb')
        return res

    @_f.addMelDocs('pointLight', 'shadowDither')
    def getShadowDither(self, **kwargs):
        res = _f.asQuery(self, rendering.pointLight, kwargs, 'shadowDither')
        return res

    @_f.addMelDocs('pointLight', 'shadowSamples')
    def getShadowSamples(self, **kwargs):
        res = _f.asQuery(self, rendering.pointLight, kwargs, 'shadowSamples')
        return res

    @_f.addMelDocs('pointLight', 'softShadow')
    def getSoftShadow(self, **kwargs):
        res = _f.asQuery(self, rendering.pointLight, kwargs, 'softShadow')
        return res

    @_f.addMelDocs('pointLight', 'discRadius')
    def setDiscRadius(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.pointLight, kwargs, 'discRadius', val)

    @_f.addMelDocs('pointLight', 'exclusive')
    def setExclusive(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.pointLight, kwargs, 'exclusive', val)

    @_f.addMelDocs('pointLight', 'rgb')
    def setRgb(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.pointLight, kwargs, 'rgb', val)

    @_f.addMelDocs('pointLight', 'shadowDither')
    def setShadowDither(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.pointLight, kwargs, 'shadowDither', val)

    @_f.addMelDocs('pointLight', 'shadowSamples')
    def setShadowSamples(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.pointLight, kwargs, 'shadowSamples', val)

    @_f.addMelDocs('pointLight', 'softShadow')
    def setSoftShadow(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.pointLight, kwargs, 'softShadow', val)


class VolumeLight(PointLight):
    __apicls__ = _api.MFnVolumeLight
    __melnode__ = u'volumeLight'
    __slots__ = ()
    MLightDirection = Enum('MLightDirection', {'kOutward': 0, 'outward': 0, 'kInward': 1, 'inward': 1, 'downAxis': 2, 'kDownAxis': 2}, multiKeys=True, defaultKeys={0: 'outward', 1: 'inward', 2: 'downAxis'})
    MLightShape = Enum('MLightShape', {'boxVolume': 0, 'kBoxVolume': 0, 'sphereVolume': 1, 'kSphereVolume': 1, 'kCylinderVolume': 2, 'cylinderVolume': 2, 'kConeVolume': 3, 'coneVolume': 3}, multiKeys=True, defaultKeys={0: 'boxVolume', 1: 'sphereVolume', 2: 'cylinderVolume', 3: 'coneVolume'})

    @_f.addApiDocs(_api.MFnVolumeLight, 'arc')
    def getArc(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'arc')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnVolumeLight, 'coneEndRadius')
    def getConeEndRadius(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'coneEndRadius')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnVolumeLight, 'emitAmbient')
    def getEmitAmbient(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'emitAmbient')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnVolumeLight, 'lightShape')
    def getLightShape(self):
        # type: () -> VolumeLight.MLightShape
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'lightShape')
        return _f.ApiArgUtil._castResult(self, res, ('MFnVolumeLight', 'MLightShape'), None)

    @_f.addApiDocs(_api.MFnVolumeLight, 'shadowAngle')
    def getShadowAngle(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'shadowAngle')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnVolumeLight, 'volumeLightDirection')
    def getVolumeLightDirection(self):
        # type: () -> VolumeLight.MLightDirection
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'volumeLightDirection')
        return _f.ApiArgUtil._castResult(self, res, ('MFnVolumeLight', 'MLightDirection'), None)

    @_f.addApiDocs(_api.MFnVolumeLight, 'setArc')
    def setArc(self, arc):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([arc], [('arc', 'float', 'in', None)], self.getArc, self.setArc, [])
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'setArc', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeLight, 'setConeEndRadius')
    def setConeEndRadius(self, cone_end_radius):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([cone_end_radius], [('cone_end_radius', 'float', 'in', None)], self.getConeEndRadius, self.setConeEndRadius, [])
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'setConeEndRadius', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeLight, 'setEmitAmbient')
    def setEmitAmbient(self, emit_ambient):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([emit_ambient], [('emit_ambient', 'bool', 'in', None)], self.getEmitAmbient, self.setEmitAmbient, [])
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'setEmitAmbient', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeLight, 'setLightShape')
    def setLightShape(self, light_shape):
        # type: (VolumeLight.MLightShape) -> None
        do, final_do, outTypes = _f.processApiArgs([light_shape], [('light_shape', ('MFnVolumeLight', 'MLightShape'), 'in', None)], self.getLightShape, self.setLightShape, [])
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'setLightShape', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeLight, 'setShadowAngle')
    def setShadowAngle(self, shadow_angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([shadow_angle], [('shadow_angle', 'float', 'in', None)], self.getShadowAngle, self.setShadowAngle, [])
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'setShadowAngle', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeLight, 'setVolumeLightDirection')
    def setVolumeLightDirection(self, volume_light_direction):
        # type: (VolumeLight.MLightDirection) -> None
        do, final_do, outTypes = _f.processApiArgs([volume_light_direction], [('volume_light_direction', ('MFnVolumeLight', 'MLightDirection'), 'in', None)], self.getVolumeLightDirection, self.setVolumeLightDirection, [])
        res = _f.getProxyResult(self, _api.MFnVolumeLight, 'setVolumeLightDirection', final_do)
        return res


class SpotLight(NonExtendedLightShapeNode):
    __apicls__ = _api.MFnSpotLight
    __melcmd__ = staticmethod(rendering.spotLight)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'spotLight'
    __melnode__ = u'spotLight'
    __slots__ = ()
    MBarnDoor = Enum('MBarnDoor', {'kLeft': 0, 'left': 0, 'right': 1, 'kRight': 1, 'kTop': 2, 'top': 2, 'bottom': 3, 'kBottom': 3}, multiKeys=True, defaultKeys={0: 'left', 1: 'right', 2: 'top', 3: 'bottom'})
    MDecayRegion = Enum('MDecayRegion', {'kFirst': 0, 'first': 0, 'kSecond': 1, 'second': 1, 'kThird': 2, 'third': 2}, multiKeys=True, defaultKeys={0: 'first', 1: 'second', 2: 'third'})

    @_f.addApiDocs(_api.MFnSpotLight, 'barnDoorAngle')
    def getBarnDoorAngle(self, which_door):
        # type: (SpotLight.MBarnDoor) -> float
        do, final_do, outTypes = _f.getDoArgs([which_door], [('which_door', ('MFnSpotLight', 'MBarnDoor'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'barnDoorAngle', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', 'angular')
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'barnDoors')
    def getBarnDoors(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'barnDoors')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addMelDocs('spotLight', 'bottomBarnDoorAngle')
    def getBottomBarnDoorAngle(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'bottomBarnDoorAngle')
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'coneAngle')
    def getConeAngle(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'coneAngle')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'angular')

    @_f.addMelDocs('spotLight', 'discRadius')
    def getDiscRadius(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'discRadius')
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'dropOff')
    def getDropOff(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'dropOff')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnSpotLight, 'endDistance')
    def getEndDistance(self, which_region):
        # type: (SpotLight.MDecayRegion) -> float
        do, final_do, outTypes = _f.getDoArgs([which_region], [('which_region', ('MFnSpotLight', 'MDecayRegion'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'endDistance', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'float', None)
        return res

    @_f.addMelDocs('spotLight', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('spotLight', 'leftBarnDoorAngle')
    def getLeftBarnDoorAngle(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'leftBarnDoorAngle')
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'penumbraAngle')
    def getPenumbra(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'penumbraAngle')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'angular')

    @_f.addMelDocs('spotLight', 'rgb')
    def getRgb(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'rgb')
        return res

    @_f.addMelDocs('spotLight', 'rightBarnDoorAngle')
    def getRightBarnDoorAngle(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'rightBarnDoorAngle')
        return res

    @_f.addMelDocs('spotLight', 'shadowDither')
    def getShadowDither(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'shadowDither')
        return res

    @_f.addMelDocs('spotLight', 'shadowSamples')
    def getShadowSamples(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'shadowSamples')
        return res

    @_f.addMelDocs('spotLight', 'softShadow')
    def getSoftShadow(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'softShadow')
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'startDistance')
    def getStartDistance(self, which_region):
        # type: (SpotLight.MDecayRegion) -> float
        do, final_do, outTypes = _f.getDoArgs([which_region], [('which_region', ('MFnSpotLight', 'MDecayRegion'), 'in', None)])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'startDistance', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'float', None)
        return res

    @_f.addMelDocs('spotLight', 'topBarnDoorAngle')
    def getTopBarnDoorAngle(self, **kwargs):
        res = _f.asQuery(self, rendering.spotLight, kwargs, 'topBarnDoorAngle')
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'useDecayRegions')
    def getUseDecayRegions(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'useDecayRegions')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnSpotLight, 'setBarnDoorAngle')
    def setBarnDoorAngle(self, which_door, barn_door_angle):
        # type: (SpotLight.MBarnDoor, float) -> None
        do, final_do, outTypes = _f.processApiArgs([which_door, barn_door_angle], [('which_door', ('MFnSpotLight', 'MBarnDoor'), 'in', None), ('barn_door_angle', 'double', 'in', u'angular')], self.getBarnDoorAngle, self.setBarnDoorAngle, ['which_door'])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'setBarnDoorAngle', final_do)
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'setBarnDoors')
    def setBarnDoors(self, barn_doors):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([barn_doors], [('barn_doors', 'bool', 'in', None)], self.getBarnDoors, self.setBarnDoors, [])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'setBarnDoors', final_do)
        return res

    @_f.addMelDocs('spotLight', 'bottomBarnDoorAngle')
    def setBottomBarnDoorAngle(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.spotLight, kwargs, 'bottomBarnDoorAngle', val)

    @_f.addApiDocs(_api.MFnSpotLight, 'setConeAngle')
    def setConeAngle(self, cone_angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([cone_angle], [('cone_angle', 'double', 'in', u'angular')], self.getConeAngle, self.setConeAngle, [])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'setConeAngle', final_do)
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'setDropOff')
    def setDropOff(self, drop_off):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([drop_off], [('drop_off', 'double', 'in', None)], self.getDropOff, self.setDropOff, [])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'setDropOff', final_do)
        return res

    @_f.addApiDocs(_api.MFnSpotLight, 'setEndDistance')
    def setEndDistance(self, which_region, end_distance):
        # type: (SpotLight.MDecayRegion, float) -> None
        do, final_do, outTypes = _f.processApiArgs([which_region, end_distance], [('which_region', ('MFnSpotLight', 'MDecayRegion'), 'in', None), ('end_distance', 'float', 'in', None)], self.getEndDistance, self.setEndDistance, ['which_region'])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'setEndDistance', final_do)
        return res

    @_f.addMelDocs('spotLight', 'leftBarnDoorAngle')
    def setLeftBarnDoorAngle(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.spotLight, kwargs, 'leftBarnDoorAngle', val)

    @_f.addApiDocs(_api.MFnSpotLight, 'setPenumbraAngle')
    def setPenumbra(self, penumbra_angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([penumbra_angle], [('penumbra_angle', 'double', 'in', u'angular')], self.getPenumbra, self.setPenumbra, [])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'setPenumbraAngle', final_do)
        return res

    @_f.addMelDocs('spotLight', 'rightBarnDoorAngle')
    def setRightBarnDoorAngle(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.spotLight, kwargs, 'rightBarnDoorAngle', val)

    @_f.addApiDocs(_api.MFnSpotLight, 'setStartDistance')
    def setStartDistance(self, which_region, start_distance):
        # type: (SpotLight.MDecayRegion, float) -> None
        do, final_do, outTypes = _f.processApiArgs([which_region, start_distance], [('which_region', ('MFnSpotLight', 'MDecayRegion'), 'in', None), ('start_distance', 'float', 'in', None)], self.getStartDistance, self.setStartDistance, ['which_region'])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'setStartDistance', final_do)
        return res

    @_f.addMelDocs('spotLight', 'topBarnDoorAngle')
    def setTopBarnDoorAngle(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.spotLight, kwargs, 'topBarnDoorAngle', val)

    @_f.addApiDocs(_api.MFnSpotLight, 'setUseDecayRegions')
    def setUseDecayRegions(self, use_decay_regions):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([use_decay_regions], [('use_decay_regions', 'bool', 'in', None)], self.getUseDecayRegions, self.setUseDecayRegions, [])
        res = _f.getProxyResult(self, _api.MFnSpotLight, 'setUseDecayRegions', final_do)
        return res


class DirectionalLight(NonExtendedLightShapeNode):
    __apicls__ = _api.MFnDirectionalLight
    __melcmd__ = staticmethod(rendering.directionalLight)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'directionalLight'
    __melnode__ = u'directionalLight'
    __slots__ = ()

    @_f.addMelDocs('directionalLight', 'discRadius')
    def getDiscRadius(self, **kwargs):
        res = _f.asQuery(self, rendering.directionalLight, kwargs, 'discRadius')
        return res

    @_f.addMelDocs('directionalLight', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, rendering.directionalLight, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('directionalLight', 'rgb')
    def getRgb(self, **kwargs):
        res = _f.asQuery(self, rendering.directionalLight, kwargs, 'rgb')
        return res

    @_f.addApiDocs(_api.MFnDirectionalLight, 'shadowAngle')
    def getShadowAngle(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnDirectionalLight, 'shadowAngle')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addMelDocs('directionalLight', 'shadowDither')
    def getShadowDither(self, **kwargs):
        res = _f.asQuery(self, rendering.directionalLight, kwargs, 'shadowDither')
        return res

    @_f.addMelDocs('directionalLight', 'shadowSamples')
    def getShadowSamples(self, **kwargs):
        res = _f.asQuery(self, rendering.directionalLight, kwargs, 'shadowSamples')
        return res

    @_f.addMelDocs('directionalLight', 'softShadow')
    def getSoftShadow(self, **kwargs):
        res = _f.asQuery(self, rendering.directionalLight, kwargs, 'softShadow')
        return res

    @_f.addApiDocs(_api.MFnDirectionalLight, 'useLightPosition')
    def getUseLightPosition(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDirectionalLight, 'useLightPosition')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnDirectionalLight, 'setShadowAngle')
    def setShadowAngle(self, shadow_angle):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([shadow_angle], [('shadow_angle', 'float', 'in', None)], self.getShadowAngle, self.setShadowAngle, [])
        res = _f.getProxyResult(self, _api.MFnDirectionalLight, 'setShadowAngle', final_do)
        return res

    @_f.addApiDocs(_api.MFnDirectionalLight, 'setUseLightPosition')
    def setUseLightPosition(self, use_light_position):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([use_light_position], [('use_light_position', 'bool', 'in', None)], self.getUseLightPosition, self.setUseLightPosition, [])
        res = _f.getProxyResult(self, _api.MFnDirectionalLight, 'setUseLightPosition', final_do)
        return res


class AmbientLight(RenderLight):
    __apicls__ = _api.MFnAmbientLight
    __melcmd__ = staticmethod(rendering.ambientLight)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'ambientLight'
    __melnode__ = u'ambientLight'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnAmbientLight, 'ambientShade')
    def getAmbientShade(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAmbientLight, 'ambientShade')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnAmbientLight, 'castSoftShadows')
    def getCastSoftShadows(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAmbientLight, 'castSoftShadows')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addMelDocs('ambientLight', 'discRadius')
    def getDiscRadius(self, **kwargs):
        res = _f.asQuery(self, rendering.ambientLight, kwargs, 'discRadius')
        return res

    @_f.addMelDocs('ambientLight', 'exclusive')
    def getExclusive(self, **kwargs):
        res = _f.asQuery(self, rendering.ambientLight, kwargs, 'exclusive')
        return res

    @_f.addMelDocs('ambientLight', 'position')
    def getPosition(self, **kwargs):
        res = _f.asQuery(self, rendering.ambientLight, kwargs, 'position')
        return res

    @_f.addMelDocs('ambientLight', 'rgb')
    def getRgb(self, **kwargs):
        res = _f.asQuery(self, rendering.ambientLight, kwargs, 'rgb')
        return res

    @_f.addMelDocs('ambientLight', 'rotation')
    def getRotation(self, **kwargs):
        res = _f.asQuery(self, rendering.ambientLight, kwargs, 'rotation')
        return res

    @_f.addMelDocs('ambientLight', 'shadowDither')
    def getShadowDither(self, **kwargs):
        res = _f.asQuery(self, rendering.ambientLight, kwargs, 'shadowDither')
        return res

    @_f.addApiDocs(_api.MFnAmbientLight, 'shadowRadius')
    def getShadowRadius(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAmbientLight, 'shadowRadius')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addMelDocs('ambientLight', 'shadowSamples')
    def getShadowSamples(self, **kwargs):
        res = _f.asQuery(self, rendering.ambientLight, kwargs, 'shadowSamples')
        return res

    @_f.addMelDocs('ambientLight', 'softShadow')
    def getSoftShadow(self, **kwargs):
        res = _f.asQuery(self, rendering.ambientLight, kwargs, 'softShadow')
        return res

    @_f.addApiDocs(_api.MFnAmbientLight, 'setAmbientShade')
    def setAmbientShade(self, ambient_shade):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([ambient_shade], [('ambient_shade', 'float', 'in', None)], self.getAmbientShade, self.setAmbientShade, [])
        res = _f.getProxyResult(self, _api.MFnAmbientLight, 'setAmbientShade', final_do)
        return res

    @_f.addApiDocs(_api.MFnAmbientLight, 'setCastSoftShadows')
    def setCastSoftShadows(self, cast_soft_shadows):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([cast_soft_shadows], [('cast_soft_shadows', 'bool', 'in', None)], self.getCastSoftShadows, self.setCastSoftShadows, [])
        res = _f.getProxyResult(self, _api.MFnAmbientLight, 'setCastSoftShadows', final_do)
        return res

    @_f.addMelDocs('ambientLight', 'discRadius')
    def setDiscRadius(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.ambientLight, kwargs, 'discRadius', val)

    @_f.addMelDocs('ambientLight', 'shadowDither')
    def setShadowDither(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.ambientLight, kwargs, 'shadowDither', val)

    @_f.addApiDocs(_api.MFnAmbientLight, 'setShadowRadius')
    def setShadowRadius(self, shadow_radius):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([shadow_radius], [('shadow_radius', 'float', 'in', None)], self.getShadowRadius, self.setShadowRadius, [])
        res = _f.getProxyResult(self, _api.MFnAmbientLight, 'setShadowRadius', final_do)
        return res

    @_f.addMelDocs('ambientLight', 'shadowSamples')
    def setShadowSamples(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.ambientLight, kwargs, 'shadowSamples', val)

    @_f.addMelDocs('ambientLight', 'softShadow')
    def setSoftShadow(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.ambientLight, kwargs, 'softShadow', val)


class Plane(GeometryShape):
    __melcmd__ = staticmethod(modeling.plane)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'plane'
    __melnode__ = u'plane'
    __slots__ = ()


class SketchPlane(Plane):
    __melnode__ = u'sketchPlane'
    __slots__ = ()


class OrthoGrid(SketchPlane):
    __melnode__ = u'orthoGrid'
    __slots__ = ()


class GroundPlane(SketchPlane):
    __melnode__ = u'groundPlane'
    __slots__ = ()


class Locator(GeometryShape):
    __melcmd__ = staticmethod(general.spaceLocator)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'spaceLocator'
    __melnode__ = u'locator'
    __slots__ = ()

    @_f.addMelDocs('spaceLocator', 'absolute')
    def absolute(self, val=True, **kwargs):
        return _f.asEdit(self, general.spaceLocator, kwargs, 'absolute', val)

    @_f.addMelDocs('spaceLocator', 'position')
    def getPosition(self, **kwargs):
        res = _f.asQuery(self, general.spaceLocator, kwargs, 'position')
        return res

    @_f.addMelDocs('spaceLocator', 'relative')
    def relative(self, val=True, **kwargs):
        return _f.asEdit(self, general.spaceLocator, kwargs, 'relative', val)

    @_f.addMelDocs('spaceLocator', 'position')
    def setPosition(self, val=True, **kwargs):
        return _f.asEdit(self, general.spaceLocator, kwargs, 'position', val)


class PositionMarker(Locator):
    __melnode__ = u'positionMarker'
    __slots__ = ()


class OrientationMarker(PositionMarker):
    __melnode__ = u'orientationMarker'
    __slots__ = ()


class THlocatorShape(Locator):
    __melnode__ = u'THlocatorShape'
    __slots__ = ()


class DropoffLocator(Locator):
    __melcmd__ = staticmethod(animation.dropoffLocator)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'dropoffLocator'
    __melnode__ = u'dropoffLocator'
    __slots__ = ()


class HikFloorContactMarker(Locator):
    __melnode__ = u'hikFloorContactMarker'
    __slots__ = ()


class ImplicitSphere(GeometryShape):
    __melnode__ = u'implicitSphere'
    __slots__ = ()


class RenderSphere(ImplicitSphere):
    __melnode__ = u'renderSphere'
    __slots__ = ()


class GreasePlaneRenderShape(Mesh):
    __melnode__ = u'greasePlaneRenderShape'
    __slots__ = ()


class FluidShape(SurfaceShape):
    __apicls__ = _api.MFnFluid
    __melnode__ = u'fluidShape'
    __slots__ = ()
    ColorMethod = Enum('ColorMethod', {'useShadingColor': 0, 'kUseShadingColor': 0, 'staticColorGrid': 1, 'kStaticColorGrid': 1, 'kDynamicColorGrid': 2, 'dynamicColorGrid': 2}, multiKeys=True, defaultKeys={0: 'useShadingColor', 1: 'staticColorGrid', 2: 'dynamicColorGrid'})
    CoordinateMethod = Enum('CoordinateMethod', {'kFixed': 0, 'fixed': 0, 'kGrid': 1, 'grid': 1}, multiKeys=True, defaultKeys={0: 'fixed', 1: 'grid'})
    FalloffMethod = Enum('FalloffMethod', {'noFalloffGrid': 0, 'kNoFalloffGrid': 0, 'staticFalloffGrid': 1, 'kStaticFalloffGrid': 1}, multiKeys=True, defaultKeys={0: 'noFalloffGrid', 1: 'staticFalloffGrid'})
    FluidGradient = Enum('FluidGradient', {'constant': 0, 'kConstant': 0, 'XGradient': 1, 'kXGradient': 1, 'kYGradient': 2, 'YGradient': 2, 'ZGradient': 3, 'kZGradient': 3, 'kNegXGradient': 4, 'negXGradient': 4, 'kNegYGradient': 5, 'negYGradient': 5, 'negZGradient': 6, 'kNegZGradient': 6, 'kCenterGradient': 7, 'centerGradient': 7}, multiKeys=True, defaultKeys={0: 'constant', 1: 'XGradient', 2: 'YGradient', 3: 'ZGradient', 4: 'negXGradient', 5: 'negYGradient', 6: 'negZGradient', 7: 'centerGradient'})
    FluidMethod = Enum('FluidMethod', {'kZero': 0, 'zero': 0, 'kStaticGrid': 1, 'staticGrid': 1, 'dynamicGrid': 2, 'kDynamicGrid': 2, 'gradient': 3, 'kGradient': 3}, multiKeys=True, defaultKeys={0: 'zero', 1: 'staticGrid', 2: 'dynamicGrid', 3: 'gradient'})

    @_f.addApiDocs(_api.MFnFluid, 'create2D')
    def create2D(self, Xres, Yres, Xdim, Ydim, parent='MObject::kNullObj'):
        # type: (int, int, float, float, general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([Xres, Yres, Xdim, Ydim, parent], [('Xres', 'uint', 'in', None), ('Yres', 'uint', 'in', None), ('Xdim', 'double', 'in', None), ('Ydim', 'double', 'in', None), ('parent', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'create2D', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'create3D')
    def create3D(self, Xres, Yres, Zres, Xdim, Ydim, Zdim, parent='MObject::kNullObj'):
        # type: (int, int, int, float, float, float, general.PyNode) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([Xres, Yres, Zres, Xdim, Ydim, Zdim, parent], [('Xres', 'uint', 'in', None), ('Yres', 'uint', 'in', None), ('Zres', 'uint', 'in', None), ('Xdim', 'double', 'in', None), ('Ydim', 'double', 'in', None), ('Zdim', 'double', 'in', None), ('parent', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'create3D', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'density')
    def density(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnFluid, 'density')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnFluid, 'emitIntoArrays')
    def emitIntoArrays(self, val, x, y, z, density, heat, fuel, doColor, emitColor):
        # type: (float, int, int, int, float, float, float, bool, Color) -> None
        do, final_do, outTypes = _f.getDoArgs([val, x, y, z, density, heat, fuel, doColor, emitColor], [('val', 'float', 'in', None), ('x', 'int', 'in', None), ('y', 'int', 'in', None), ('z', 'int', 'in', None), ('density', 'float', 'in', None), ('heat', 'float', 'in', None), ('fuel', 'float', 'in', None), ('doColor', 'bool', 'in', None), ('emitColor', 'MColor', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'emitIntoArrays', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'expandToInclude')
    def expandToInclude(self, min, max):
        # type: (Point, Point) -> None
        do, final_do, outTypes = _f.getDoArgs([min, max], [('min', 'MPoint', 'in', None), ('max', 'MPoint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'expandToInclude', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'falloff')
    def falloff(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnFluid, 'falloff')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnFluid, 'fuel')
    def fuel(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnFluid, 'fuel')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnFluid, 'getColorMode')
    def getColorMode(self):
        # type: () -> Fluid.ColorMethod
        do, final_do, outTypes = _f.getDoArgs([], [('method', ('MFnFluid', 'ColorMethod'), 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getColorMode', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getColors')
    def getColors(self):
        # type: () -> Tuple[float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('r', 'float', 'out', None), ('g', 'float', 'out', None), ('b', 'float', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getColors', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getCoordinateMode')
    def getCoordinateMode(self):
        # type: () -> Fluid.CoordinateMethod
        do, final_do, outTypes = _f.getDoArgs([], [('method', ('MFnFluid', 'CoordinateMethod'), 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getCoordinateMode', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getCoordinates')
    def getCoordinates(self):
        # type: () -> Tuple[float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('u', 'float', 'out', None), ('v', 'float', 'out', None), ('w', 'float', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getCoordinates', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getDensityMode')
    def getDensityMode(self):
        # type: () -> Tuple[Fluid.FluidMethod, Fluid.FluidGradient]
        do, final_do, outTypes = _f.getDoArgs([], [('method', ('MFnFluid', 'FluidMethod'), 'out', None), ('gradient', ('MFnFluid', 'FluidGradient'), 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getDensityMode', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getDimensions')
    def getDimensions(self):
        # type: () -> Tuple[float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('Xdim', 'double', 'out', None), ('Ydim', 'double', 'out', None), ('Zdim', 'double', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getDimensions', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getFalloffMode')
    def getFalloffMode(self):
        # type: () -> Fluid.FalloffMethod
        do, final_do, outTypes = _f.getDoArgs([], [('method', ('MFnFluid', 'FalloffMethod'), 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getFalloffMode', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getForceAtPoint')
    def getForceAtPoint(self, point, velocity, mass, deltaTime=0.041666666666666664):
        # type: (List[Point], List[Vector], List[float], float) -> List[Vector]
        do, final_do, outTypes = _f.getDoArgs([point, velocity, mass, deltaTime], [('point', 'MPointArray', 'in', None), ('velocity', 'MVectorArray', 'in', None), ('mass', 'MDoubleArray', 'in', None), ('force', 'MVectorArray', 'out', None), ('deltaTime', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getForceAtPoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getFuelMode')
    def getFuelMode(self):
        # type: () -> Tuple[Fluid.FluidMethod, Fluid.FluidGradient]
        do, final_do, outTypes = _f.getDoArgs([], [('method', ('MFnFluid', 'FluidMethod'), 'out', None), ('gradient', ('MFnFluid', 'FluidGradient'), 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getFuelMode', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getResolution')
    def getResolution(self):
        # type: () -> Tuple[int, int, int]
        do, final_do, outTypes = _f.getDoArgs([], [('Xres', 'uint', 'out', None), ('Yres', 'uint', 'out', None), ('Zres', 'uint', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getResolution', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getTemperatureMode')
    def getTemperatureMode(self):
        # type: () -> Tuple[Fluid.FluidMethod, Fluid.FluidGradient]
        do, final_do, outTypes = _f.getDoArgs([], [('method', ('MFnFluid', 'FluidMethod'), 'out', None), ('gradient', ('MFnFluid', 'FluidGradient'), 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getTemperatureMode', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getVelocity')
    def getVelocity(self):
        # type: () -> Tuple[float, float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('Xvel', 'float', 'out', None), ('Yvel', 'float', 'out', None), ('Zvel', 'float', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getVelocity', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'getVelocityMode')
    def getVelocityMode(self):
        # type: () -> Tuple[Fluid.FluidMethod, Fluid.FluidGradient]
        do, final_do, outTypes = _f.getDoArgs([], [('method', ('MFnFluid', 'FluidMethod'), 'out', None), ('gradient', ('MFnFluid', 'FluidGradient'), 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'getVelocityMode', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'gridSize')
    def gridSize(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnFluid, 'gridSize')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnFluid, 'isAutoResize')
    def isAutoResize(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnFluid, 'isAutoResize')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnFluid, 'isResizeToEmitter')
    def isResizeToEmitter(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnFluid, 'isResizeToEmitter')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnFluid, 'pressure')
    def pressure(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnFluid, 'pressure')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnFluid, 'setColorMode')
    def setColorMode(self, method):
        # type: (Fluid.ColorMethod) -> None
        do, final_do, outTypes = _f.processApiArgs([method], [('method', ('MFnFluid', 'ColorMethod'), 'in', None)], self.getColorMode, self.setColorMode, [])
        res = _f.getProxyResult(self, _api.MFnFluid, 'setColorMode', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'setCoordinateMode')
    def setCoordinateMode(self, method):
        # type: (Fluid.CoordinateMethod) -> None
        do, final_do, outTypes = _f.processApiArgs([method], [('method', ('MFnFluid', 'CoordinateMethod'), 'in', None)], self.getCoordinateMode, self.setCoordinateMode, [])
        res = _f.getProxyResult(self, _api.MFnFluid, 'setCoordinateMode', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'setDensityMode')
    def setDensityMode(self, method, gradient):
        # type: (Fluid.FluidMethod, Fluid.FluidGradient) -> None
        do, final_do, outTypes = _f.processApiArgs([method, gradient], [('method', ('MFnFluid', 'FluidMethod'), 'in', None), ('gradient', ('MFnFluid', 'FluidGradient'), 'in', None)], self.getDensityMode, self.setDensityMode, [])
        res = _f.getProxyResult(self, _api.MFnFluid, 'setDensityMode', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'setFalloffMode')
    def setFalloffMode(self, method):
        # type: (Fluid.FalloffMethod) -> None
        do, final_do, outTypes = _f.processApiArgs([method], [('method', ('MFnFluid', 'FalloffMethod'), 'in', None)], self.getFalloffMode, self.setFalloffMode, [])
        res = _f.getProxyResult(self, _api.MFnFluid, 'setFalloffMode', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'setFuelMode')
    def setFuelMode(self, method, gradient):
        # type: (Fluid.FluidMethod, Fluid.FluidGradient) -> None
        do, final_do, outTypes = _f.processApiArgs([method, gradient], [('method', ('MFnFluid', 'FluidMethod'), 'in', None), ('gradient', ('MFnFluid', 'FluidGradient'), 'in', None)], self.getFuelMode, self.setFuelMode, [])
        res = _f.getProxyResult(self, _api.MFnFluid, 'setFuelMode', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'setSize')
    def setSize(self, Xres, Yres, Zres, Xdim, Ydim, Zdim, resample):
        # type: (int, int, int, float, float, float, bool) -> None
        do, final_do, outTypes = _f.getDoArgs([Xres, Yres, Zres, Xdim, Ydim, Zdim, resample], [('Xres', 'uint', 'in', None), ('Yres', 'uint', 'in', None), ('Zres', 'uint', 'in', None), ('Xdim', 'double', 'in', None), ('Ydim', 'double', 'in', None), ('Zdim', 'double', 'in', None), ('resample', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'setSize', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'setTemperatureMode')
    def setTemperatureMode(self, method, gradient):
        # type: (Fluid.FluidMethod, Fluid.FluidGradient) -> None
        do, final_do, outTypes = _f.processApiArgs([method, gradient], [('method', ('MFnFluid', 'FluidMethod'), 'in', None), ('gradient', ('MFnFluid', 'FluidGradient'), 'in', None)], self.getTemperatureMode, self.setTemperatureMode, [])
        res = _f.getProxyResult(self, _api.MFnFluid, 'setTemperatureMode', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'setVelocityMode')
    def setVelocityMode(self, method, gradient):
        # type: (Fluid.FluidMethod, Fluid.FluidGradient) -> None
        do, final_do, outTypes = _f.processApiArgs([method, gradient], [('method', ('MFnFluid', 'FluidMethod'), 'in', None), ('gradient', ('MFnFluid', 'FluidGradient'), 'in', None)], self.getVelocityMode, self.setVelocityMode, [])
        res = _f.getProxyResult(self, _api.MFnFluid, 'setVelocityMode', final_do)
        return res

    @_f.addApiDocs(_api.MFnFluid, 'temperature')
    def temperature(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnFluid, 'temperature')
        return _f.ApiArgUtil._castResult(self, res, 'float', None)

    @_f.addApiDocs(_api.MFnFluid, 'toGridIndex')
    def toGridIndex(self, objectSpacePoint):
        # type: (Point) -> Tuple[bool, Tuple[int, int, int]]
        do, final_do, outTypes = _f.getDoArgs([objectSpacePoint], [('objectSpacePoint', 'MPoint', 'in', None), ('gridCoords', 'int3', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'toGridIndex', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'updateGrid')
    def updateGrid(self):
        # type: () -> None
        res = _f.getProxyResult(self, _api.MFnFluid, 'updateGrid')
        return res

    @_f.addApiDocs(_api.MFnFluid, 'velocityGridSizes')
    def velocityGridSizes(self):
        # type: () -> Tuple[int, int, int]
        do, final_do, outTypes = _f.getDoArgs([], [('xsize', 'int', 'out', None), ('ysize', 'int', 'out', None), ('zsize', 'int', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'velocityGridSizes', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnFluid, 'voxelCenterPosition')
    def voxelCenterPosition(self, xi, yi, zi):
        # type: (int, int, int) -> Point
        do, final_do, outTypes = _f.getDoArgs([xi, yi, zi], [('xi', 'int', 'in', None), ('yi', 'int', 'in', None), ('zi', 'int', 'in', None), ('objectSpacePoint', 'MPoint', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnFluid, 'voxelCenterPosition', final_do)
        return _f.processApiResult(res, outTypes, do)


class FluidTexture3D(FluidShape):
    __melnode__ = u'fluidTexture3D'
    __slots__ = ()


class FluidTexture2D(FluidShape):
    __melnode__ = u'fluidTexture2D'
    __slots__ = ()


class HeightField(SurfaceShape):
    __melnode__ = u'heightField'
    __slots__ = ()


class THsurfaceShape(SurfaceShape):
    __melnode__ = u'THsurfaceShape'
    __slots__ = ()


class BezierCurve(NurbsCurve):
    __melnode__ = u'bezierCurve'
    __slots__ = ()


class SnapshotShape(ControlPoint):
    __melnode__ = u'snapshotShape'
    __slots__ = ()


class MotionTrailShape(SnapshotShape):
    __melnode__ = u'motionTrailShape'
    __slots__ = ()


class NBase(Particle):
    __melcmd__ = staticmethod(effects.nBase)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'nBase'
    __melnode__ = u'nBase'
    __slots__ = ()

    @_f.addMelDocs('nBase', 'clearCachedTextureMap')
    def clearCachedTextureMap(self, val=True, **kwargs):
        return _f.asEdit(self, effects.nBase, kwargs, 'clearCachedTextureMap', val)

    @_f.addMelDocs('nBase', 'clearStart')
    def clearStart(self, val=True, **kwargs):
        return _f.asEdit(self, effects.nBase, kwargs, 'clearStart', val)

    @_f.addMelDocs('nBase', 'stuffStart')
    def stuffStart(self, val=True, **kwargs):
        return _f.asEdit(self, effects.nBase, kwargs, 'stuffStart', val)

    @_f.addMelDocs('nBase', 'textureToVertex')
    def textureToVertex(self, val=True, **kwargs):
        return _f.asEdit(self, effects.nBase, kwargs, 'textureToVertex', val)


class NRigid(NBase):
    __melnode__ = u'nRigid'
    __slots__ = ()


class NCloth(NBase):
    __melnode__ = u'nCloth'
    __slots__ = ()


class NParticle(NBase):
    __melcmd__ = staticmethod(effects.nParticle)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'nParticle'
    __melnode__ = u'nParticle'
    __slots__ = ()


class RenderRect(GeometryShape):
    __melnode__ = u'renderRect'
    __slots__ = ()


class DirectedDisc(GeometryShape):
    __melnode__ = u'directedDisc'
    __slots__ = ()


class ImplicitCone(GeometryShape):
    __melnode__ = u'implicitCone'
    __slots__ = ()


class RenderCone(ImplicitCone):
    __melnode__ = u'renderCone'
    __slots__ = ()


class ImplicitBox(GeometryShape):
    __melnode__ = u'implicitBox'
    __slots__ = ()


class RenderBox(ImplicitBox):
    __melnode__ = u'renderBox'
    __slots__ = ()


class EnvironmentFog(GeometryShape):
    __melnode__ = u'environmentFog'
    __slots__ = ()


class RigidBody(Shape):
    __melcmd__ = staticmethod(effects.rigidBody)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'rigidBody'
    __melnode__ = u'rigidBody'
    __slots__ = ()

    @_f.addMelDocs('rigidBody', 'deleteCache')
    def deleteCache(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'deleteCache', val)

    @_f.addMelDocs('rigidBody', 'active')
    def getActive(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'active')
        return res

    @_f.addMelDocs('rigidBody', 'angularVelocity')
    def getAngularVelocity(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'angularVelocity')
        return res

    @_f.addMelDocs('rigidBody', 'applyForceAt')
    def getApplyForceAt(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'applyForceAt')
        return res

    @_f.addMelDocs('rigidBody', 'bounciness')
    def getBounciness(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'bounciness')
        return res

    @_f.addMelDocs('rigidBody', 'cache')
    def getCache(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'cache')
        return res

    @_f.addMelDocs('rigidBody', 'centerOfMass')
    def getCenterOfMass(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'centerOfMass')
        return res

    @_f.addMelDocs('rigidBody', 'collisions')
    def getCollisions(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'collisions')
        return res

    @_f.addMelDocs('rigidBody', 'contactCount')
    def getContactCount(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'contactCount')
        return res

    @_f.addMelDocs('rigidBody', 'contactName')
    def getContactName(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'contactName')
        return res

    @_f.addMelDocs('rigidBody', 'contactPosition')
    def getContactPosition(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'contactPosition')
        return res

    @_f.addMelDocs('rigidBody', 'damping')
    def getDamping(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'damping')
        return res

    @_f.addMelDocs('rigidBody', 'dynamicFriction')
    def getDynamicFriction(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'dynamicFriction')
        return res

    @_f.addMelDocs('rigidBody', 'force')
    def getForce(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'force')
        return res

    @_f.addMelDocs('rigidBody', 'ignore')
    def getIgnore(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'ignore')
        return res

    @_f.addMelDocs('rigidBody', 'initialAngularVelocity')
    def getInitialAngularVelocity(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'initialAngularVelocity')
        return res

    @_f.addMelDocs('rigidBody', 'initialVelocity')
    def getInitialVelocity(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'initialVelocity')
        return res

    @_f.addMelDocs('rigidBody', 'layer')
    def getLayer(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'layer')
        return res

    @_f.addMelDocs('rigidBody', 'lockCenterOfMass')
    def getLockCenterOfMass(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'lockCenterOfMass')
        return res

    @_f.addMelDocs('rigidBody', 'mass')
    def getMass(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'mass')
        return res

    @_f.addMelDocs('rigidBody', 'orientation')
    def getOrientation(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'orientation')
        return res

    @_f.addMelDocs('rigidBody', 'particleCollision')
    def getParticleCollision(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'particleCollision')
        return res

    @_f.addMelDocs('rigidBody', 'passive')
    def getPassive(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'passive')
        return res

    @_f.addMelDocs('rigidBody', 'position')
    def getPosition(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'position')
        return res

    @_f.addMelDocs('rigidBody', 'removeShape')
    def getRemoveShape(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'removeShape')
        return res

    @_f.addMelDocs('rigidBody', 'solver')
    def getSolver(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'solver')
        return res

    @_f.addMelDocs('rigidBody', 'standInObject')
    def getStandInObject(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'standInObject')
        return res

    @_f.addMelDocs('rigidBody', 'staticFriction')
    def getStaticFriction(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'staticFriction')
        return res

    @_f.addMelDocs('rigidBody', 'tesselationFactor')
    def getTesselationFactor(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'tesselationFactor')
        return res

    @_f.addMelDocs('rigidBody', 'velocity')
    def getVelocity(self, **kwargs):
        res = _f.asQuery(self, effects.rigidBody, kwargs, 'velocity')
        return res

    @_f.addMelDocs('rigidBody', 'impulse')
    def impulse(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'impulse', val)

    @_f.addMelDocs('rigidBody', 'impulsePosition')
    def impulsePosition(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'impulsePosition', val)

    @_f.addMelDocs('rigidBody', 'active')
    def setActive(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'active', val)

    @_f.addMelDocs('rigidBody', 'applyForceAt')
    def setApplyForceAt(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'applyForceAt', val)

    @_f.addMelDocs('rigidBody', 'bounciness')
    def setBounciness(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'bounciness', val)

    @_f.addMelDocs('rigidBody', 'cache')
    def setCache(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'cache', val)

    @_f.addMelDocs('rigidBody', 'centerOfMass')
    def setCenterOfMass(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'centerOfMass', val)

    @_f.addMelDocs('rigidBody', 'collisions')
    def setCollisions(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'collisions', val)

    @_f.addMelDocs('rigidBody', 'damping')
    def setDamping(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'damping', val)

    @_f.addMelDocs('rigidBody', 'dynamicFriction')
    def setDynamicFriction(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'dynamicFriction', val)

    @_f.addMelDocs('rigidBody', 'ignore')
    def setIgnore(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'ignore', val)

    @_f.addMelDocs('rigidBody', 'initialAngularVelocity')
    def setInitialAngularVelocity(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'initialAngularVelocity', val)

    @_f.addMelDocs('rigidBody', 'initialVelocity')
    def setInitialVelocity(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'initialVelocity', val)

    @_f.addMelDocs('rigidBody', 'layer')
    def setLayer(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'layer', val)

    @_f.addMelDocs('rigidBody', 'lockCenterOfMass')
    def setLockCenterOfMass(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'lockCenterOfMass', val)

    @_f.addMelDocs('rigidBody', 'mass')
    def setMass(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'mass', val)

    @_f.addMelDocs('rigidBody', 'orientation')
    def setOrientation(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'orientation', val)

    @_f.addMelDocs('rigidBody', 'particleCollision')
    def setParticleCollision(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'particleCollision', val)

    @_f.addMelDocs('rigidBody', 'passive')
    def setPassive(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'passive', val)

    @_f.addMelDocs('rigidBody', 'position')
    def setPosition(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'position', val)

    @_f.addMelDocs('rigidBody', 'removeShape')
    def setRemoveShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'removeShape', val)

    @_f.addMelDocs('rigidBody', 'solver')
    def setSolver(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'solver', val)

    @_f.addMelDocs('rigidBody', 'standInObject')
    def setStandInObject(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'standInObject', val)

    @_f.addMelDocs('rigidBody', 'staticFriction')
    def setStaticFriction(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'staticFriction', val)

    @_f.addMelDocs('rigidBody', 'spinImpulse')
    def spinImpulse(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidBody, kwargs, 'spinImpulse', val)


class HairSystem(Shape):
    __melnode__ = u'hairSystem'
    __slots__ = ()


class LineModifier(Shape):
    __melnode__ = u'lineModifier'
    __slots__ = ()


class SoftModHandle(Shape):
    __melnode__ = u'softModHandle'
    __slots__ = ()


class Follicle(Shape):
    __melnode__ = u'follicle'
    __slots__ = ()


class ClusterHandle(Shape):
    __melnode__ = u'clusterHandle'
    __slots__ = ()


class DynamicConstraint(Shape):
    __melnode__ = u'dynamicConstraint'
    __slots__ = ()


class DynHolder(Shape):
    __melnode__ = u'dynHolder'
    __slots__ = ()


class DimensionShape(Shape):
    __melnode__ = u'dimensionShape'
    __slots__ = ()


class AngleDimension(DimensionShape):
    __melnode__ = u'angleDimension'
    __slots__ = ()


class AnnotationShape(DimensionShape):
    __melcmd__ = staticmethod(windows.annotate)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'annotate'
    __melnode__ = u'annotationShape'
    __slots__ = ()


class NurbsDimShape(DimensionShape):
    __melnode__ = u'nurbsDimShape'
    __slots__ = ()


class ParamDimension(NurbsDimShape):
    __melcmd__ = staticmethod(general.paramDimension)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'paramDimension'
    __melnode__ = u'paramDimension'
    __slots__ = ()


class ArcLengthDimension(NurbsDimShape):
    __melcmd__ = staticmethod(modeling.arcLengthDimension)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'arcLengthDimension'
    __melnode__ = u'arcLengthDimension'
    __slots__ = ()


class DistanceDimShape(DimensionShape):
    __melnode__ = u'distanceDimShape'
    __slots__ = ()


class FlexorShape(Shape):
    __melnode__ = u'flexorShape'
    __slots__ = ()


class ClusterFlexorShape(FlexorShape):
    __melnode__ = u'clusterFlexorShape'
    __slots__ = ()


class Spring(Shape):
    __melcmd__ = staticmethod(effects.spring)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'spring'
    __melnode__ = u'spring'
    __slots__ = ()

    @_f.addMelDocs('spring', 'allPoints')
    def allPoints(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'allPoints', val)

    @_f.addMelDocs('spring', 'count')
    def getCount(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'count')
        return res

    @_f.addMelDocs('spring', 'damping')
    def getDamping(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'damping')
        return res

    @_f.addMelDocs('spring', 'dampingPS')
    def getDampingPS(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'dampingPS')
        return res

    @_f.addMelDocs('spring', 'endForceWeight')
    def getEndForceWeight(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'endForceWeight')
        return res

    @_f.addMelDocs('spring', 'length')
    def getLength(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'length')
        return res

    @_f.addMelDocs('spring', 'restLength')
    def getRestLength(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'restLength')
        return res

    @_f.addMelDocs('spring', 'restLengthPS')
    def getRestLengthPS(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'restLengthPS')
        return res

    @_f.addMelDocs('spring', 'startForceWeight')
    def getStartForceWeight(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'startForceWeight')
        return res

    @_f.addMelDocs('spring', 'stiffness')
    def getStiffness(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'stiffness')
        return res

    @_f.addMelDocs('spring', 'stiffnessPS')
    def getStiffnessPS(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'stiffnessPS')
        return res

    @_f.addMelDocs('spring', 'useDampingPS')
    def getUseDampingPS(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'useDampingPS')
        return res

    @_f.addMelDocs('spring', 'useRestLengthPS')
    def getUseRestLengthPS(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'useRestLengthPS')
        return res

    @_f.addMelDocs('spring', 'useStiffnessPS')
    def getUseStiffnessPS(self, **kwargs):
        res = _f.asQuery(self, effects.spring, kwargs, 'useStiffnessPS')
        return res

    @_f.addMelDocs('spring', 'maxDistance')
    def maxDistance(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'maxDistance', val)

    @_f.addMelDocs('spring', 'damping')
    def setDamping(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'damping', val)

    @_f.addMelDocs('spring', 'dampingPS')
    def setDampingPS(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'dampingPS', val)

    @_f.addMelDocs('spring', 'endForceWeight')
    def setEndForceWeight(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'endForceWeight', val)

    @_f.addMelDocs('spring', 'length')
    def setLength(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'length', val)

    @_f.addMelDocs('spring', 'restLength')
    def setRestLength(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'restLength', val)

    @_f.addMelDocs('spring', 'restLengthPS')
    def setRestLengthPS(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'restLengthPS', val)

    @_f.addMelDocs('spring', 'startForceWeight')
    def setStartForceWeight(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'startForceWeight', val)

    @_f.addMelDocs('spring', 'stiffness')
    def setStiffness(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'stiffness', val)

    @_f.addMelDocs('spring', 'stiffnessPS')
    def setStiffnessPS(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'stiffnessPS', val)

    @_f.addMelDocs('spring', 'useDampingPS')
    def setUseDampingPS(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'useDampingPS', val)

    @_f.addMelDocs('spring', 'useRestLengthPS')
    def setUseRestLengthPS(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'useRestLengthPS', val)

    @_f.addMelDocs('spring', 'useStiffnessPS')
    def setUseStiffnessPS(self, val=True, **kwargs):
        return _f.asEdit(self, effects.spring, kwargs, 'useStiffnessPS', val)


class THdynSpring(Spring):
    __melnode__ = u'THdynSpring'
    __slots__ = ()


class DeformFunc(Shape):
    __melnode__ = u'deformFunc'
    __slots__ = ()


class DeformTwist(DeformFunc):
    __melnode__ = u'deformTwist'
    __slots__ = ()


class DeformFlare(DeformFunc):
    __melnode__ = u'deformFlare'
    __slots__ = ()


class DeformSine(DeformFunc):
    __melnode__ = u'deformSine'
    __slots__ = ()


class DeformBend(DeformFunc):
    __melnode__ = u'deformBend'
    __slots__ = ()


class DeformWave(DeformFunc):
    __melnode__ = u'deformWave'
    __slots__ = ()


class DeformSquash(DeformFunc):
    __melnode__ = u'deformSquash'
    __slots__ = ()


class PfxGeometry(Shape):
    __apicls__ = _api.MFnPfxGeometry
    __melnode__ = u'pfxGeometry'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnPfxGeometry, 'getBoundingBox')
    def getBoundingBox(self):
        # type: () -> Tuple[float, float]
        do, final_do, outTypes = _f.getDoArgs([], [('min', 'double', 'out', None), ('max', 'double', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnPfxGeometry, 'getBoundingBox', final_do)
        return _f.processApiResult(res, outTypes, do)


class Stroke(PfxGeometry):
    __melcmd__ = staticmethod(effects.stroke)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'stroke'
    __melnode__ = u'stroke'
    __slots__ = ()


class PfxToon(PfxGeometry):
    __melnode__ = u'pfxToon'
    __slots__ = ()


class PfxHair(PfxGeometry):
    __melnode__ = u'pfxHair'
    __slots__ = ()


class ImagePlane(Shape):
    __melcmd__ = staticmethod(rendering.imagePlane)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'imagePlane'
    __melnode__ = u'imagePlane'
    __slots__ = ()

    @_f.addMelDocs('imagePlane', 'detach')
    def detach(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.imagePlane, kwargs, 'detach', val)

    @_f.addMelDocs('imagePlane', 'fileName')
    def fileName(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.imagePlane, kwargs, 'fileName', val)

    @_f.addMelDocs('imagePlane', 'camera')
    def getCamera(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'camera')
        return res

    @_f.addMelDocs('imagePlane', 'dropFrame')
    def getDropFrame(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'dropFrame')
        return res

    @_f.addMelDocs('imagePlane', 'frameDuration')
    def getFrameDuration(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'frameDuration')
        return res

    @_f.addMelDocs('imagePlane', 'height')
    def getHeight(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'height')
        return res

    @_f.addMelDocs('imagePlane', 'imageSize')
    def getImageSize(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'imageSize')
        return res

    @_f.addMelDocs('imagePlane', 'lookThrough')
    def getLookThrough(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'lookThrough')
        return res

    @_f.addMelDocs('imagePlane', 'maintainRatio')
    def getMaintainRatio(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'maintainRatio')
        return res

    @_f.addMelDocs('imagePlane', 'negTimesOK')
    def getNegTimesOK(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'negTimesOK')
        return res

    @_f.addMelDocs('imagePlane', 'numFrames')
    def getNumFrames(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'numFrames')
        return res

    @_f.addMelDocs('imagePlane', 'quickTime')
    def getQuickTime(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'quickTime')
        return res

    @_f.addMelDocs('imagePlane', 'showInAllViews')
    def getShowInAllViews(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'showInAllViews')
        return res

    @_f.addMelDocs('imagePlane', 'timeCode')
    def getTimeCode(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'timeCode')
        return res

    @_f.addMelDocs('imagePlane', 'timeCodeTrack')
    def getTimeCodeTrack(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'timeCodeTrack')
        return res

    @_f.addMelDocs('imagePlane', 'timeScale')
    def getTimeScale(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'timeScale')
        return res

    @_f.addMelDocs('imagePlane', 'twentyFourHourMax')
    def getTwentyFourHourMax(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'twentyFourHourMax')
        return res

    @_f.addMelDocs('imagePlane', 'width')
    def getWidth(self, **kwargs):
        res = _f.asQuery(self, rendering.imagePlane, kwargs, 'width')
        return res

    @_f.addMelDocs('imagePlane', 'camera')
    def setCamera(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.imagePlane, kwargs, 'camera', val)

    @_f.addMelDocs('imagePlane', 'height')
    def setHeight(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.imagePlane, kwargs, 'height', val)

    @_f.addMelDocs('imagePlane', 'lookThrough')
    def setLookThrough(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.imagePlane, kwargs, 'lookThrough', val)

    @_f.addMelDocs('imagePlane', 'maintainRatio')
    def setMaintainRatio(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.imagePlane, kwargs, 'maintainRatio', val)

    @_f.addMelDocs('imagePlane', 'showInAllViews')
    def setShowInAllViews(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.imagePlane, kwargs, 'showInAllViews', val)

    @_f.addMelDocs('imagePlane', 'width')
    def setWidth(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.imagePlane, kwargs, 'width', val)


class THimagePlane(ImagePlane):
    __melnode__ = u'THimagePlane'
    __slots__ = ()


class GreasePlane(ImagePlane):
    __melnode__ = u'greasePlane'
    __slots__ = ()


class UnknownDag(DagNode):
    __melnode__ = u'unknownDag'
    __slots__ = ()


class HikIKEffector(Transform):
    __melnode__ = u'hikIKEffector'
    __slots__ = ()


class DagContainer(Transform):
    __melnode__ = u'dagContainer'
    __slots__ = ()


class Assembly(DagContainer):
    __apicls__ = _api.MFnAssembly
    __melcmd__ = staticmethod(general.assembly)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'assembly'
    __melnode__ = u'assembly'
    __slots__ = ()

    @_f.addMelDocs('assembly', 'deregister')
    def deregister(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'deregister', val)

    @_f.addMelDocs('assembly', 'activeLabel')
    def getActiveLabel(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'activeLabel')
        return res

    @_f.addMelDocs('assembly', 'canCreate')
    def getCanCreate(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'canCreate')
        return res

    @_f.addMelDocs('assembly', 'createOptionBoxProc')
    def getCreateOptionBoxProc(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'createOptionBoxProc')
        return res

    @_f.addMelDocs('assembly', 'defaultType')
    def getDefaultType(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'defaultType')
        return res

    @_f.addMelDocs('assembly', 'isAType')
    def getIsAType(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'isAType')
        return res

    @_f.addMelDocs('assembly', 'isTrackingMemberEdits')
    def getIsTrackingMemberEdits(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'isTrackingMemberEdits')
        return res

    @_f.addMelDocs('assembly', 'label')
    def getLabel(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'label')
        return res

    @_f.addMelDocs('assembly', 'listRepTypes')
    def getListRepTypes(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'listRepTypes')
        return res

    @_f.addMelDocs('assembly', 'listRepTypesProc')
    def getListRepTypesProc(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'listRepTypesProc')
        return res

    @_f.addMelDocs('assembly', 'listRepresentations')
    def getListRepresentations(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'listRepresentations')
        return res

    @_f.addMelDocs('assembly', 'listTypes')
    def getListTypes(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'listTypes')
        return res

    @_f.addMelDocs('assembly', 'postCreateUIProc')
    def getPostCreateUIProc(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'postCreateUIProc')
        return res

    @_f.addMelDocs('assembly', 'repPostCreateUIProc')
    def getRepPostCreateUIProc(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'repPostCreateUIProc')
        return res

    @_f.addMelDocs('assembly', 'repPreCreateUIProc')
    def getRepPreCreateUIProc(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'repPreCreateUIProc')
        return res

    @_f.addMelDocs('assembly', 'repTypeLabel')
    def getRepTypeLabel(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'repTypeLabel')
        return res

    @_f.addMelDocs('assembly', 'repTypeLabelProc')
    def getRepTypeLabelProc(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'repTypeLabelProc')
        return res

    @_f.addMelDocs('assembly', 'type')
    def getType(self, **kwargs):
        res = _f.asQuery(self, general.assembly, kwargs, 'type')
        return res

    @_f.addMelDocs('assembly', 'input')
    def input(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'input', val)

    @_f.addMelDocs('assembly', 'newRepLabel')
    def newRepLabel(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'newRepLabel', val)

    @_f.addMelDocs('assembly', 'proc')
    def proc(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'proc', val)

    @_f.addMelDocs('assembly', 'renameRepresentation')
    def renameRepresentation(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'renameRepresentation', val)

    @_f.addMelDocs('assembly', 'repName')
    def repName(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'repName', val)

    @_f.addMelDocs('assembly', 'active')
    def setActive(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'active', val)

    @_f.addMelDocs('assembly', 'activeLabel')
    def setActiveLabel(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'activeLabel', val)

    @_f.addMelDocs('assembly', 'createOptionBoxProc')
    def setCreateOptionBoxProc(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'createOptionBoxProc', val)

    @_f.addMelDocs('assembly', 'defaultType')
    def setDefaultType(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'defaultType', val)

    @_f.addMelDocs('assembly', 'label')
    def setLabel(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'label', val)

    @_f.addMelDocs('assembly', 'listRepTypesProc')
    def setListRepTypesProc(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'listRepTypesProc', val)

    @_f.addMelDocs('assembly', 'postCreateUIProc')
    def setPostCreateUIProc(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'postCreateUIProc', val)

    @_f.addMelDocs('assembly', 'repPostCreateUIProc')
    def setRepPostCreateUIProc(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'repPostCreateUIProc', val)

    @_f.addMelDocs('assembly', 'repPreCreateUIProc')
    def setRepPreCreateUIProc(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'repPreCreateUIProc', val)

    @_f.addMelDocs('assembly', 'repTypeLabelProc')
    def setRepTypeLabelProc(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'repTypeLabelProc', val)

    @_f.addMelDocs('assembly', 'type')
    def setType(self, val=True, **kwargs):
        return _f.asEdit(self, general.assembly, kwargs, 'type', val)


class THassembly(Assembly):
    __melnode__ = u'THassembly'
    __slots__ = ()


class LodGroup(Transform):
    __melnode__ = u'lodGroup'
    __slots__ = ()


class Instancer(Transform):
    __apicls__ = _api.MFnInstancer
    __melcmd__ = staticmethod(general.instancer)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'instancer'
    __melnode__ = u'instancer'
    __slots__ = ()

    @_f.addMelDocs('instancer', 'addObject')
    def addObject(self, val=True, **kwargs):
        return _f.asEdit(self, general.instancer, kwargs, 'addObject', val)

    @_f.addApiDocs(_api.MFnInstancer, 'allInstances')
    def allInstances(self):
        # type: () -> Tuple[List[general.PyNode], List[Matrix], List[int], List[int]]
        do, final_do, outTypes = _f.getDoArgs([], [('paths', 'MDagPathArray', 'out', None), ('matrices', 'MMatrixArray', 'out', None), ('particlePathStartIndices', 'MIntArray', 'out', None), ('pathIndices', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnInstancer, 'allInstances', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('instancer', 'cycle')
    def getCycle(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'cycle')
        return res

    @_f.addMelDocs('instancer', 'cycleStep')
    def getCycleStep(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'cycleStep')
        return res

    @_f.addMelDocs('instancer', 'cycleStepUnits')
    def getCycleStepUnits(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'cycleStepUnits')
        return res

    @_f.addMelDocs('instancer', 'index')
    def getIndex(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'index')
        return res

    @_f.addMelDocs('instancer', 'levelOfDetail')
    def getLevelOfDetail(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'levelOfDetail')
        return res

    @_f.addMelDocs('instancer', 'object')
    def getObject(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'object')
        return res

    @_f.addMelDocs('instancer', 'objectPosition')
    def getObjectPosition(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'objectPosition')
        return res

    @_f.addMelDocs('instancer', 'objectRotation')
    def getObjectRotation(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'objectRotation')
        return res

    @_f.addMelDocs('instancer', 'objectScale')
    def getObjectScale(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'objectScale')
        return res

    @_f.addMelDocs('instancer', 'pointDataSource')
    def getPointDataSource(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'pointDataSource')
        return res

    @_f.addMelDocs('instancer', 'rotationUnits')
    def getRotationUnits(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'rotationUnits')
        return res

    @_f.addMelDocs('instancer', 'valueName')
    def getValueName(self, **kwargs):
        res = _f.asQuery(self, general.instancer, kwargs, 'valueName')
        return res

    @_f.addApiDocs(_api.MFnInstancer, 'instancesForParticle')
    def instancesForParticle(self, p):
        # type: (int) -> Tuple[int, List[general.PyNode], Matrix]
        do, final_do, outTypes = _f.getDoArgs([p], [('p', 'int', 'in', None), ('paths', 'MDagPathArray', 'out', None), ('instancerMatrix', 'MMatrix', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnInstancer, 'instancesForParticle', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'int', None)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnInstancer, 'particleCount')
    def particleCount(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnInstancer, 'particleCount')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('instancer', 'removeObject')
    def removeObject(self, val=True, **kwargs):
        return _f.asEdit(self, general.instancer, kwargs, 'removeObject', val)

    @_f.addMelDocs('instancer', 'cycle')
    def setCycle(self, val=True, **kwargs):
        return _f.asEdit(self, general.instancer, kwargs, 'cycle', val)

    @_f.addMelDocs('instancer', 'cycleStep')
    def setCycleStep(self, val=True, **kwargs):
        return _f.asEdit(self, general.instancer, kwargs, 'cycleStep', val)

    @_f.addMelDocs('instancer', 'cycleStepUnits')
    def setCycleStepUnits(self, val=True, **kwargs):
        return _f.asEdit(self, general.instancer, kwargs, 'cycleStepUnits', val)

    @_f.addMelDocs('instancer', 'levelOfDetail')
    def setLevelOfDetail(self, val=True, **kwargs):
        return _f.asEdit(self, general.instancer, kwargs, 'levelOfDetail', val)

    @_f.addMelDocs('instancer', 'rotationUnits')
    def setRotationUnits(self, val=True, **kwargs):
        return _f.asEdit(self, general.instancer, kwargs, 'rotationUnits', val)


class THcustomTransform(Transform):
    __melnode__ = u'THcustomTransform'
    __slots__ = ()


class IkEffector(Transform):
    __apicls__ = _api.MFnIkEffector
    __melnode__ = u'ikEffector'
    __slots__ = ()


class UnknownTransform(Transform):
    __melnode__ = u'unknownTransform'
    __slots__ = ()


class HikFKJoint(Joint):
    __melnode__ = u'hikFKJoint'
    __slots__ = ()


class BaseGeometryVarGroup(Transform):
    __melnode__ = u'baseGeometryVarGroup'
    __slots__ = ()


class GeometryVarGroup(BaseGeometryVarGroup):
    __melnode__ = u'geometryVarGroup'
    __slots__ = ()


class SubdivSurfaceVarGroup(BaseGeometryVarGroup):
    __melnode__ = u'subdivSurfaceVarGroup'
    __slots__ = ()


class SurfaceVarGroup(BaseGeometryVarGroup):
    __melnode__ = u'surfaceVarGroup'
    __slots__ = ()


class MeshVarGroup(BaseGeometryVarGroup):
    __melnode__ = u'meshVarGroup'
    __slots__ = ()


class CurveVarGroup(BaseGeometryVarGroup):
    __melnode__ = u'curveVarGroup'
    __slots__ = ()


class DynBase(Transform):
    __melnode__ = u'dynBase'
    __slots__ = ()


class CollisionModel(DynBase):
    __melnode__ = u'collisionModel'
    __slots__ = ()


class PointEmitter(DynBase):
    __melnode__ = u'pointEmitter'
    __slots__ = ()


class FluidEmitter(PointEmitter):
    __melcmd__ = staticmethod(effects.fluidEmitter)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'fluidEmitter'
    __melnode__ = u'fluidEmitter'
    __slots__ = ()

    @_f.addMelDocs('fluidEmitter', 'cycleEmission')
    def getCycleEmission(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'cycleEmission')
        return res

    @_f.addMelDocs('fluidEmitter', 'cycleInterval')
    def getCycleInterval(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'cycleInterval')
        return res

    @_f.addMelDocs('fluidEmitter', 'densityEmissionRate')
    def getDensityEmissionRate(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'densityEmissionRate')
        return res

    @_f.addMelDocs('fluidEmitter', 'fluidDropoff')
    def getFluidDropoff(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'fluidDropoff')
        return res

    @_f.addMelDocs('fluidEmitter', 'fuelEmissionRate')
    def getFuelEmissionRate(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'fuelEmissionRate')
        return res

    @_f.addMelDocs('fluidEmitter', 'heatEmissionRate')
    def getHeatEmissionRate(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'heatEmissionRate')
        return res

    @_f.addMelDocs('fluidEmitter', 'maxDistance')
    def getMaxDistance(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'maxDistance')
        return res

    @_f.addMelDocs('fluidEmitter', 'minDistance')
    def getMinDistance(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'minDistance')
        return res

    @_f.addMelDocs('fluidEmitter', 'position')
    def getPosition(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'position')
        return res

    @_f.addMelDocs('fluidEmitter', 'rate')
    def getRate(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'rate')
        return res

    @_f.addMelDocs('fluidEmitter', 'torusSectionRadius')
    def getTorusSectionRadius(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'torusSectionRadius')
        return res

    @_f.addMelDocs('fluidEmitter', 'type')
    def getType(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'type')
        return res

    @_f.addMelDocs('fluidEmitter', 'volumeOffset')
    def getVolumeOffset(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'volumeOffset')
        return res

    @_f.addMelDocs('fluidEmitter', 'volumeShape')
    def getVolumeShape(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'volumeShape')
        return res

    @_f.addMelDocs('fluidEmitter', 'volumeSweep')
    def getVolumeSweep(self, **kwargs):
        res = _f.asQuery(self, effects.fluidEmitter, kwargs, 'volumeSweep')
        return res

    @_f.addMelDocs('fluidEmitter', 'cycleEmission')
    def setCycleEmission(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'cycleEmission', val)

    @_f.addMelDocs('fluidEmitter', 'cycleInterval')
    def setCycleInterval(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'cycleInterval', val)

    @_f.addMelDocs('fluidEmitter', 'densityEmissionRate')
    def setDensityEmissionRate(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'densityEmissionRate', val)

    @_f.addMelDocs('fluidEmitter', 'fluidDropoff')
    def setFluidDropoff(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'fluidDropoff', val)

    @_f.addMelDocs('fluidEmitter', 'fuelEmissionRate')
    def setFuelEmissionRate(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'fuelEmissionRate', val)

    @_f.addMelDocs('fluidEmitter', 'heatEmissionRate')
    def setHeatEmissionRate(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'heatEmissionRate', val)

    @_f.addMelDocs('fluidEmitter', 'maxDistance')
    def setMaxDistance(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'maxDistance', val)

    @_f.addMelDocs('fluidEmitter', 'minDistance')
    def setMinDistance(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'minDistance', val)

    @_f.addMelDocs('fluidEmitter', 'position')
    def setPosition(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'position', val)

    @_f.addMelDocs('fluidEmitter', 'rate')
    def setRate(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'rate', val)

    @_f.addMelDocs('fluidEmitter', 'torusSectionRadius')
    def setTorusSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'torusSectionRadius', val)

    @_f.addMelDocs('fluidEmitter', 'type')
    def setType(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'type', val)

    @_f.addMelDocs('fluidEmitter', 'volumeOffset')
    def setVolumeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'volumeOffset', val)

    @_f.addMelDocs('fluidEmitter', 'volumeShape')
    def setVolumeShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'volumeShape', val)

    @_f.addMelDocs('fluidEmitter', 'volumeSweep')
    def setVolumeSweep(self, val=True, **kwargs):
        return _f.asEdit(self, effects.fluidEmitter, kwargs, 'volumeSweep', val)


class THfluidEmitter(FluidEmitter):
    __melnode__ = u'THfluidEmitter'
    __slots__ = ()


class THdynEmitter(PointEmitter):
    __melnode__ = u'THdynEmitter'
    __slots__ = ()


class Field(DynBase):
    __apicls__ = _api.MFnField
    __melnode__ = u'field'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnField, 'falloffCurve')
    def falloffCurve(self, param):
        # type: (float) -> float
        do, final_do, outTypes = _f.getDoArgs([param], [('param', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnField, 'falloffCurve', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'double', None)
        return res

    @_f.addApiDocs(_api.MFnField, 'attenuation')
    def getAttenuation(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnField, 'attenuation')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnField, 'getForceAtPoint')
    def getForceAtPoint(self, point, velocity, mass, deltaTime=0.041666666666666664):
        # type: (List[Point], List[Vector], List[float], float) -> List[Vector]
        do, final_do, outTypes = _f.getDoArgs([point, velocity, mass, deltaTime], [('point', 'MPointArray', 'in', None), ('velocity', 'MVectorArray', 'in', None), ('mass', 'MDoubleArray', 'in', None), ('force', 'MVectorArray', 'out', None), ('deltaTime', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnField, 'getForceAtPoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnField, 'magnitude')
    def getMagnitude(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnField, 'magnitude')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnField, 'maxDistance')
    def getMaxDistance(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnField, 'maxDistance')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'linear')

    @_f.addApiDocs(_api.MFnField, 'perVertex')
    def getPerVertex(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnField, 'perVertex')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnField, 'useMaxDistance')
    def getUseMaxDistance(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnField, 'useMaxDistance')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnField, 'isFalloffCurveConstantOne')
    def isFalloffCurveConstantOne(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnField, 'isFalloffCurveConstantOne')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnField, 'setAttenuation')
    def setAttenuation(self, atten):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([atten], [('atten', 'double', 'in', None)], self.getAttenuation, self.setAttenuation, [])
        res = _f.getProxyResult(self, _api.MFnField, 'setAttenuation', final_do)
        return res

    @_f.addApiDocs(_api.MFnField, 'setMagnitude')
    def setMagnitude(self, mag):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([mag], [('mag', 'double', 'in', None)], self.getMagnitude, self.setMagnitude, [])
        res = _f.getProxyResult(self, _api.MFnField, 'setMagnitude', final_do)
        return res

    @_f.addApiDocs(_api.MFnField, 'setMaxDistance')
    def setMaxDistance(self, dist):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([dist], [('dist', 'double', 'in', u'linear')], self.getMaxDistance, self.setMaxDistance, [])
        res = _f.getProxyResult(self, _api.MFnField, 'setMaxDistance', final_do)
        return res

    @_f.addApiDocs(_api.MFnField, 'setPerVertex')
    def setPerVertex(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enable], [('enable', 'bool', 'in', None)], self.getPerVertex, self.setPerVertex, [])
        res = _f.getProxyResult(self, _api.MFnField, 'setPerVertex', final_do)
        return res

    @_f.addApiDocs(_api.MFnField, 'setUseMaxDistance')
    def setUseMaxDistance(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enable], [('enable', 'bool', 'in', None)], self.getUseMaxDistance, self.setUseMaxDistance, [])
        res = _f.getProxyResult(self, _api.MFnField, 'setUseMaxDistance', final_do)
        return res


class VortexField(Field):
    __apicls__ = _api.MFnVortexField
    __melcmd__ = staticmethod(effects.vortex)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'vortex'
    __melnode__ = u'vortexField'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnVortexField, 'axis')
    def getAxis(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnVortexField, 'axis')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addMelDocs('vortex', 'axisX')
    def getAxisX(self, **kwargs):
        res = _f.asQuery(self, effects.vortex, kwargs, 'axisX')
        return res

    @_f.addMelDocs('vortex', 'axisY')
    def getAxisY(self, **kwargs):
        res = _f.asQuery(self, effects.vortex, kwargs, 'axisY')
        return res

    @_f.addMelDocs('vortex', 'axisZ')
    def getAxisZ(self, **kwargs):
        res = _f.asQuery(self, effects.vortex, kwargs, 'axisZ')
        return res

    @_f.addMelDocs('vortex', 'torusSectionRadius')
    def getTorusSectionRadius(self, **kwargs):
        res = _f.asQuery(self, effects.vortex, kwargs, 'torusSectionRadius')
        return res

    @_f.addMelDocs('vortex', 'volumeExclusion')
    def getVolumeExclusion(self, **kwargs):
        res = _f.asQuery(self, effects.vortex, kwargs, 'volumeExclusion')
        return res

    @_f.addMelDocs('vortex', 'volumeOffset')
    def getVolumeOffset(self, **kwargs):
        res = _f.asQuery(self, effects.vortex, kwargs, 'volumeOffset')
        return res

    @_f.addMelDocs('vortex', 'volumeShape')
    def getVolumeShape(self, **kwargs):
        res = _f.asQuery(self, effects.vortex, kwargs, 'volumeShape')
        return res

    @_f.addMelDocs('vortex', 'volumeSweep')
    def getVolumeSweep(self, **kwargs):
        res = _f.asQuery(self, effects.vortex, kwargs, 'volumeSweep')
        return res

    @_f.addApiDocs(_api.MFnVortexField, 'setAxis')
    def setAxis(self, axisVector):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([axisVector], [('axisVector', 'MVector', 'in', None)], self.getAxis, self.setAxis, [])
        res = _f.getProxyResult(self, _api.MFnVortexField, 'setAxis', final_do)
        return res

    @_f.addMelDocs('vortex', 'axisX')
    def setAxisX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.vortex, kwargs, 'axisX', val)

    @_f.addMelDocs('vortex', 'axisY')
    def setAxisY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.vortex, kwargs, 'axisY', val)

    @_f.addMelDocs('vortex', 'axisZ')
    def setAxisZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.vortex, kwargs, 'axisZ', val)

    @_f.addMelDocs('vortex', 'torusSectionRadius')
    def setTorusSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, effects.vortex, kwargs, 'torusSectionRadius', val)

    @_f.addMelDocs('vortex', 'volumeExclusion')
    def setVolumeExclusion(self, val=True, **kwargs):
        return _f.asEdit(self, effects.vortex, kwargs, 'volumeExclusion', val)

    @_f.addMelDocs('vortex', 'volumeOffset')
    def setVolumeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, effects.vortex, kwargs, 'volumeOffset', val)

    @_f.addMelDocs('vortex', 'volumeShape')
    def setVolumeShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.vortex, kwargs, 'volumeShape', val)

    @_f.addMelDocs('vortex', 'volumeSweep')
    def setVolumeSweep(self, val=True, **kwargs):
        return _f.asEdit(self, effects.vortex, kwargs, 'volumeSweep', val)


class VolumeAxisField(Field):
    __apicls__ = _api.MFnVolumeAxisField
    __melcmd__ = staticmethod(effects.volumeAxis)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'volumeAxis'
    __melnode__ = u'volumeAxisField'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'detailTurbulence')
    def detailTurbulence(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'detailTurbulence')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('volumeAxis', 'detailTurbulence')
    def getDetailTurbulence(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'detailTurbulence')
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'direction')
    def getDirection(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'direction')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addMelDocs('volumeAxis', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'directionX')
        return res

    @_f.addMelDocs('volumeAxis', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'directionY')
        return res

    @_f.addMelDocs('volumeAxis', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'directionZ')
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'directionalSpeed')
    def getDirectionalSpeed(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'directionalSpeed')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'invertAttenuation')
    def getInvertAttenuation(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'invertAttenuation')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'speedAlongAxis')
    def getSpeedAlongAxis(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'speedAlongAxis')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'speedAroundAxis')
    def getSpeedAroundAxis(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'speedAroundAxis')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'speedAwayFromAxis')
    def getSpeedAwayFromAxis(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'speedAwayFromAxis')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'speedAwayFromCenter')
    def getSpeedAwayFromCenter(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'speedAwayFromCenter')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('volumeAxis', 'torusSectionRadius')
    def getTorusSectionRadius(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'torusSectionRadius')
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'turbulence')
    def getTurbulence(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'turbulence')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'turbulenceFrequency')
    def getTurbulenceFrequency(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'turbulenceFrequency')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addMelDocs('volumeAxis', 'turbulenceFrequencyX')
    def getTurbulenceFrequencyX(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'turbulenceFrequencyX')
        return res

    @_f.addMelDocs('volumeAxis', 'turbulenceFrequencyY')
    def getTurbulenceFrequencyY(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'turbulenceFrequencyY')
        return res

    @_f.addMelDocs('volumeAxis', 'turbulenceFrequencyZ')
    def getTurbulenceFrequencyZ(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'turbulenceFrequencyZ')
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'turbulenceOffset')
    def getTurbulenceOffset(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'turbulenceOffset')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addMelDocs('volumeAxis', 'turbulenceOffsetX')
    def getTurbulenceOffsetX(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'turbulenceOffsetX')
        return res

    @_f.addMelDocs('volumeAxis', 'turbulenceOffsetY')
    def getTurbulenceOffsetY(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'turbulenceOffsetY')
        return res

    @_f.addMelDocs('volumeAxis', 'turbulenceOffsetZ')
    def getTurbulenceOffsetZ(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'turbulenceOffsetZ')
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'turbulenceSpeed')
    def getTurbulenceSpeed(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'turbulenceSpeed')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('volumeAxis', 'volumeExclusion')
    def getVolumeExclusion(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'volumeExclusion')
        return res

    @_f.addMelDocs('volumeAxis', 'volumeOffset')
    def getVolumeOffset(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'volumeOffset')
        return res

    @_f.addMelDocs('volumeAxis', 'volumeShape')
    def getVolumeShape(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'volumeShape')
        return res

    @_f.addMelDocs('volumeAxis', 'volumeSweep')
    def getVolumeSweep(self, **kwargs):
        res = _f.asQuery(self, effects.volumeAxis, kwargs, 'volumeSweep')
        return res

    @_f.addMelDocs('volumeAxis', 'detailTurbulence')
    def setDetailTurbulence(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'detailTurbulence', val)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setDirection')
    def setDirection(self, direction):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([direction], [('direction', 'MVector', 'in', None)], self.getDirection, self.setDirection, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setDirection', final_do)
        return res

    @_f.addMelDocs('volumeAxis', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'directionX', val)

    @_f.addMelDocs('volumeAxis', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'directionY', val)

    @_f.addMelDocs('volumeAxis', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'directionZ', val)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setDirectionalSpeed')
    def setDirectionalSpeed(self, speed):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([speed], [('speed', 'double', 'in', None)], self.getDirectionalSpeed, self.setDirectionalSpeed, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setDirectionalSpeed', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setInvertAttenuation')
    def setInvertAttenuation(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enable], [('enable', 'bool', 'in', None)], self.getInvertAttenuation, self.setInvertAttenuation, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setInvertAttenuation', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setSpeedAlongAxis')
    def setSpeedAlongAxis(self, speed):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([speed], [('speed', 'double', 'in', None)], self.getSpeedAlongAxis, self.setSpeedAlongAxis, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setSpeedAlongAxis', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setSpeedAroundAxis')
    def setSpeedAroundAxis(self, speed):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([speed], [('speed', 'double', 'in', None)], self.getSpeedAroundAxis, self.setSpeedAroundAxis, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setSpeedAroundAxis', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setSpeedAwayFromAxis')
    def setSpeedAwayFromAxis(self, speed):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([speed], [('speed', 'double', 'in', None)], self.getSpeedAwayFromAxis, self.setSpeedAwayFromAxis, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setSpeedAwayFromAxis', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setSpeedAwayFromCenter')
    def setSpeedAwayFromCenter(self, speed):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([speed], [('speed', 'double', 'in', None)], self.getSpeedAwayFromCenter, self.setSpeedAwayFromCenter, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setSpeedAwayFromCenter', final_do)
        return res

    @_f.addMelDocs('volumeAxis', 'torusSectionRadius')
    def setTorusSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'torusSectionRadius', val)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setTurbulence')
    def setTurbulence(self, value):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'double', 'in', None)], self.getTurbulence, self.setTurbulence, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setTurbulence', final_do)
        return res

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setTurbulenceFrequency')
    def setTurbulenceFrequency(self, value):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'MVector', 'in', None)], self.getTurbulenceFrequency, self.setTurbulenceFrequency, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setTurbulenceFrequency', final_do)
        return res

    @_f.addMelDocs('volumeAxis', 'turbulenceFrequencyX')
    def setTurbulenceFrequencyX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'turbulenceFrequencyX', val)

    @_f.addMelDocs('volumeAxis', 'turbulenceFrequencyY')
    def setTurbulenceFrequencyY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'turbulenceFrequencyY', val)

    @_f.addMelDocs('volumeAxis', 'turbulenceFrequencyZ')
    def setTurbulenceFrequencyZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'turbulenceFrequencyZ', val)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setTurbulenceOffset')
    def setTurbulenceOffset(self, value):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'MVector', 'in', None)], self.getTurbulenceOffset, self.setTurbulenceOffset, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setTurbulenceOffset', final_do)
        return res

    @_f.addMelDocs('volumeAxis', 'turbulenceOffsetX')
    def setTurbulenceOffsetX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'turbulenceOffsetX', val)

    @_f.addMelDocs('volumeAxis', 'turbulenceOffsetY')
    def setTurbulenceOffsetY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'turbulenceOffsetY', val)

    @_f.addMelDocs('volumeAxis', 'turbulenceOffsetZ')
    def setTurbulenceOffsetZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'turbulenceOffsetZ', val)

    @_f.addApiDocs(_api.MFnVolumeAxisField, 'setTurbulenceSpeed')
    def setTurbulenceSpeed(self, value):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'double', 'in', None)], self.getTurbulenceSpeed, self.setTurbulenceSpeed, [])
        res = _f.getProxyResult(self, _api.MFnVolumeAxisField, 'setTurbulenceSpeed', final_do)
        return res

    @_f.addMelDocs('volumeAxis', 'volumeExclusion')
    def setVolumeExclusion(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'volumeExclusion', val)

    @_f.addMelDocs('volumeAxis', 'volumeOffset')
    def setVolumeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'volumeOffset', val)

    @_f.addMelDocs('volumeAxis', 'volumeShape')
    def setVolumeShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'volumeShape', val)

    @_f.addMelDocs('volumeAxis', 'volumeSweep')
    def setVolumeSweep(self, val=True, **kwargs):
        return _f.asEdit(self, effects.volumeAxis, kwargs, 'volumeSweep', val)


class NewtonField(Field):
    __apicls__ = _api.MFnNewtonField
    __melnode__ = u'newtonField'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnNewtonField, 'minDistance')
    def getMinDistance(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnNewtonField, 'minDistance')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnNewtonField, 'setMinDistance')
    def setMinDistance(self, distance):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([distance], [('distance', 'double', 'in', None)], self.getMinDistance, self.setMinDistance, [])
        res = _f.getProxyResult(self, _api.MFnNewtonField, 'setMinDistance', final_do)
        return res


class GravityField(Field):
    __apicls__ = _api.MFnGravityField
    __melcmd__ = staticmethod(effects.gravity)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'gravity'
    __melnode__ = u'gravityField'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnGravityField, 'direction')
    def getDirection(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnGravityField, 'direction')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addMelDocs('gravity', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, effects.gravity, kwargs, 'directionX')
        return res

    @_f.addMelDocs('gravity', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, effects.gravity, kwargs, 'directionY')
        return res

    @_f.addMelDocs('gravity', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, effects.gravity, kwargs, 'directionZ')
        return res

    @_f.addMelDocs('gravity', 'torusSectionRadius')
    def getTorusSectionRadius(self, **kwargs):
        res = _f.asQuery(self, effects.gravity, kwargs, 'torusSectionRadius')
        return res

    @_f.addMelDocs('gravity', 'volumeExclusion')
    def getVolumeExclusion(self, **kwargs):
        res = _f.asQuery(self, effects.gravity, kwargs, 'volumeExclusion')
        return res

    @_f.addMelDocs('gravity', 'volumeOffset')
    def getVolumeOffset(self, **kwargs):
        res = _f.asQuery(self, effects.gravity, kwargs, 'volumeOffset')
        return res

    @_f.addMelDocs('gravity', 'volumeShape')
    def getVolumeShape(self, **kwargs):
        res = _f.asQuery(self, effects.gravity, kwargs, 'volumeShape')
        return res

    @_f.addMelDocs('gravity', 'volumeSweep')
    def getVolumeSweep(self, **kwargs):
        res = _f.asQuery(self, effects.gravity, kwargs, 'volumeSweep')
        return res

    @_f.addApiDocs(_api.MFnGravityField, 'setDirection')
    def setDirection(self, gravityDirection):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([gravityDirection], [('gravityDirection', 'MVector', 'in', None)], self.getDirection, self.setDirection, [])
        res = _f.getProxyResult(self, _api.MFnGravityField, 'setDirection', final_do)
        return res

    @_f.addMelDocs('gravity', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.gravity, kwargs, 'directionX', val)

    @_f.addMelDocs('gravity', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.gravity, kwargs, 'directionY', val)

    @_f.addMelDocs('gravity', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.gravity, kwargs, 'directionZ', val)

    @_f.addMelDocs('gravity', 'torusSectionRadius')
    def setTorusSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, effects.gravity, kwargs, 'torusSectionRadius', val)

    @_f.addMelDocs('gravity', 'volumeExclusion')
    def setVolumeExclusion(self, val=True, **kwargs):
        return _f.asEdit(self, effects.gravity, kwargs, 'volumeExclusion', val)

    @_f.addMelDocs('gravity', 'volumeOffset')
    def setVolumeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, effects.gravity, kwargs, 'volumeOffset', val)

    @_f.addMelDocs('gravity', 'volumeShape')
    def setVolumeShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.gravity, kwargs, 'volumeShape', val)

    @_f.addMelDocs('gravity', 'volumeSweep')
    def setVolumeSweep(self, val=True, **kwargs):
        return _f.asEdit(self, effects.gravity, kwargs, 'volumeSweep', val)


class UniformField(Field):
    __apicls__ = _api.MFnUniformField
    __melcmd__ = staticmethod(effects.uniform)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'uniform'
    __melnode__ = u'uniformField'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnUniformField, 'direction')
    def getDirection(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnUniformField, 'direction')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addMelDocs('uniform', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, effects.uniform, kwargs, 'directionX')
        return res

    @_f.addMelDocs('uniform', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, effects.uniform, kwargs, 'directionY')
        return res

    @_f.addMelDocs('uniform', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, effects.uniform, kwargs, 'directionZ')
        return res

    @_f.addMelDocs('uniform', 'torusSectionRadius')
    def getTorusSectionRadius(self, **kwargs):
        res = _f.asQuery(self, effects.uniform, kwargs, 'torusSectionRadius')
        return res

    @_f.addMelDocs('uniform', 'volumeExclusion')
    def getVolumeExclusion(self, **kwargs):
        res = _f.asQuery(self, effects.uniform, kwargs, 'volumeExclusion')
        return res

    @_f.addMelDocs('uniform', 'volumeOffset')
    def getVolumeOffset(self, **kwargs):
        res = _f.asQuery(self, effects.uniform, kwargs, 'volumeOffset')
        return res

    @_f.addMelDocs('uniform', 'volumeShape')
    def getVolumeShape(self, **kwargs):
        res = _f.asQuery(self, effects.uniform, kwargs, 'volumeShape')
        return res

    @_f.addMelDocs('uniform', 'volumeSweep')
    def getVolumeSweep(self, **kwargs):
        res = _f.asQuery(self, effects.uniform, kwargs, 'volumeSweep')
        return res

    @_f.addApiDocs(_api.MFnUniformField, 'setDirection')
    def setDirection(self, uniformDirection):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([uniformDirection], [('uniformDirection', 'MVector', 'in', None)], self.getDirection, self.setDirection, [])
        res = _f.getProxyResult(self, _api.MFnUniformField, 'setDirection', final_do)
        return res

    @_f.addMelDocs('uniform', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.uniform, kwargs, 'directionX', val)

    @_f.addMelDocs('uniform', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.uniform, kwargs, 'directionY', val)

    @_f.addMelDocs('uniform', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.uniform, kwargs, 'directionZ', val)

    @_f.addMelDocs('uniform', 'torusSectionRadius')
    def setTorusSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, effects.uniform, kwargs, 'torusSectionRadius', val)

    @_f.addMelDocs('uniform', 'volumeExclusion')
    def setVolumeExclusion(self, val=True, **kwargs):
        return _f.asEdit(self, effects.uniform, kwargs, 'volumeExclusion', val)

    @_f.addMelDocs('uniform', 'volumeOffset')
    def setVolumeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, effects.uniform, kwargs, 'volumeOffset', val)

    @_f.addMelDocs('uniform', 'volumeShape')
    def setVolumeShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.uniform, kwargs, 'volumeShape', val)

    @_f.addMelDocs('uniform', 'volumeSweep')
    def setVolumeSweep(self, val=True, **kwargs):
        return _f.asEdit(self, effects.uniform, kwargs, 'volumeSweep', val)


class AirField(Field):
    __apicls__ = _api.MFnAirField
    __melcmd__ = staticmethod(effects.air)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'air'
    __melnode__ = u'airField'
    __slots__ = ()

    @_f.addMelDocs('air', 'fanSetup')
    def fanSetup(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'fanSetup', val)

    @_f.addApiDocs(_api.MFnAirField, 'componentOnly')
    def getComponentOnly(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAirField, 'componentOnly')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnAirField, 'direction')
    def getDirection(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnAirField, 'direction')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addMelDocs('air', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'directionX')
        return res

    @_f.addMelDocs('air', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'directionY')
        return res

    @_f.addMelDocs('air', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'directionZ')
        return res

    @_f.addApiDocs(_api.MFnAirField, 'enableSpread')
    def getEnableSpread(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAirField, 'enableSpread')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnAirField, 'inheritRotation')
    def getInheritRotation(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnAirField, 'inheritRotation')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnAirField, 'inheritVelocity')
    def getInheritVelocity(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAirField, 'inheritVelocity')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('air', 'position')
    def getPosition(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'position')
        return res

    @_f.addApiDocs(_api.MFnAirField, 'speed')
    def getSpeed(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAirField, 'speed')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnAirField, 'spread')
    def getSpread(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnAirField, 'spread')
        return _f.ApiArgUtil._castResult(self, res, 'double', 'angular')

    @_f.addMelDocs('air', 'torusSectionRadius')
    def getTorusSectionRadius(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'torusSectionRadius')
        return res

    @_f.addMelDocs('air', 'velocityComponentOnly')
    def getVelocityComponentOnly(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'velocityComponentOnly')
        return res

    @_f.addMelDocs('air', 'volumeExclusion')
    def getVolumeExclusion(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'volumeExclusion')
        return res

    @_f.addMelDocs('air', 'volumeOffset')
    def getVolumeOffset(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'volumeOffset')
        return res

    @_f.addMelDocs('air', 'volumeShape')
    def getVolumeShape(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'volumeShape')
        return res

    @_f.addMelDocs('air', 'volumeSweep')
    def getVolumeSweep(self, **kwargs):
        res = _f.asQuery(self, effects.air, kwargs, 'volumeSweep')
        return res

    @_f.addApiDocs(_api.MFnAirField, 'setComponentOnly')
    def setComponentOnly(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enable], [('enable', 'bool', 'in', None)], self.getComponentOnly, self.setComponentOnly, [])
        res = _f.getProxyResult(self, _api.MFnAirField, 'setComponentOnly', final_do)
        return res

    @_f.addApiDocs(_api.MFnAirField, 'setDirection')
    def setDirection(self, airDirection):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([airDirection], [('airDirection', 'MVector', 'in', None)], self.getDirection, self.setDirection, [])
        res = _f.getProxyResult(self, _api.MFnAirField, 'setDirection', final_do)
        return res

    @_f.addMelDocs('air', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'directionX', val)

    @_f.addMelDocs('air', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'directionY', val)

    @_f.addMelDocs('air', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'directionZ', val)

    @_f.addApiDocs(_api.MFnAirField, 'setEnableSpread')
    def setEnableSpread(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enable], [('enable', 'bool', 'in', None)], self.getEnableSpread, self.setEnableSpread, [])
        res = _f.getProxyResult(self, _api.MFnAirField, 'setEnableSpread', final_do)
        return res

    @_f.addApiDocs(_api.MFnAirField, 'setInheritRotation')
    def setInheritRotation(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enable], [('enable', 'bool', 'in', None)], self.getInheritRotation, self.setInheritRotation, [])
        res = _f.getProxyResult(self, _api.MFnAirField, 'setInheritRotation', final_do)
        return res

    @_f.addApiDocs(_api.MFnAirField, 'setInheritVelocity')
    def setInheritVelocity(self, velocity):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([velocity], [('velocity', 'double', 'in', None)], self.getInheritVelocity, self.setInheritVelocity, [])
        res = _f.getProxyResult(self, _api.MFnAirField, 'setInheritVelocity', final_do)
        return res

    @_f.addMelDocs('air', 'position')
    def setPosition(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'position', val)

    @_f.addApiDocs(_api.MFnAirField, 'setSpeed')
    def setSpeed(self, value):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'double', 'in', None)], self.getSpeed, self.setSpeed, [])
        res = _f.getProxyResult(self, _api.MFnAirField, 'setSpeed', final_do)
        return res

    @_f.addApiDocs(_api.MFnAirField, 'setSpread')
    def setSpread(self, value):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'double', 'in', u'angular')], self.getSpread, self.setSpread, [])
        res = _f.getProxyResult(self, _api.MFnAirField, 'setSpread', final_do)
        return res

    @_f.addMelDocs('air', 'torusSectionRadius')
    def setTorusSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'torusSectionRadius', val)

    @_f.addMelDocs('air', 'velocityComponentOnly')
    def setVelocityComponentOnly(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'velocityComponentOnly', val)

    @_f.addMelDocs('air', 'volumeExclusion')
    def setVolumeExclusion(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'volumeExclusion', val)

    @_f.addMelDocs('air', 'volumeOffset')
    def setVolumeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'volumeOffset', val)

    @_f.addMelDocs('air', 'volumeShape')
    def setVolumeShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'volumeShape', val)

    @_f.addMelDocs('air', 'volumeSweep')
    def setVolumeSweep(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'volumeSweep', val)

    @_f.addMelDocs('air', 'wakeSetup')
    def wakeSetup(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'wakeSetup', val)

    @_f.addMelDocs('air', 'windSetup')
    def windSetup(self, val=True, **kwargs):
        return _f.asEdit(self, effects.air, kwargs, 'windSetup', val)


class TurbulenceField(Field):
    __apicls__ = _api.MFnTurbulenceField
    __melcmd__ = staticmethod(effects.turbulence)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'turbulence'
    __melnode__ = u'turbulenceField'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnTurbulenceField, 'frequency')
    def getFrequency(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnTurbulenceField, 'frequency')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('turbulence', 'noiseLevel')
    def getNoiseLevel(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'noiseLevel')
        res = int(res)
        return res

    @_f.addMelDocs('turbulence', 'noiseRatio')
    def getNoiseRatio(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'noiseRatio')
        return res

    @_f.addApiDocs(_api.MFnTurbulenceField, 'phase')
    def getPhase(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnTurbulenceField, 'phase')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('turbulence', 'phaseX')
    def getPhaseX(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'phaseX')
        return res

    @_f.addMelDocs('turbulence', 'phaseY')
    def getPhaseY(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'phaseY')
        return res

    @_f.addMelDocs('turbulence', 'phaseZ')
    def getPhaseZ(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'phaseZ')
        return res

    @_f.addMelDocs('turbulence', 'torusSectionRadius')
    def getTorusSectionRadius(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'torusSectionRadius')
        return res

    @_f.addMelDocs('turbulence', 'volumeExclusion')
    def getVolumeExclusion(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'volumeExclusion')
        return res

    @_f.addMelDocs('turbulence', 'volumeOffset')
    def getVolumeOffset(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'volumeOffset')
        return res

    @_f.addMelDocs('turbulence', 'volumeShape')
    def getVolumeShape(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'volumeShape')
        return res

    @_f.addMelDocs('turbulence', 'volumeSweep')
    def getVolumeSweep(self, **kwargs):
        res = _f.asQuery(self, effects.turbulence, kwargs, 'volumeSweep')
        return res

    @_f.addApiDocs(_api.MFnTurbulenceField, 'setFrequency')
    def setFrequency(self, value):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'double', 'in', None)], self.getFrequency, self.setFrequency, [])
        res = _f.getProxyResult(self, _api.MFnTurbulenceField, 'setFrequency', final_do)
        return res

    @_f.addMelDocs('turbulence', 'noiseLevel')
    def setNoiseLevel(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'noiseLevel', val)

    @_f.addMelDocs('turbulence', 'noiseRatio')
    def setNoiseRatio(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'noiseRatio', val)

    @_f.addApiDocs(_api.MFnTurbulenceField, 'setPhase')
    def setPhase(self, value):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'double', 'in', None)], self.getPhase, self.setPhase, [])
        res = _f.getProxyResult(self, _api.MFnTurbulenceField, 'setPhase', final_do)
        return res

    @_f.addMelDocs('turbulence', 'phaseX')
    def setPhaseX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'phaseX', val)

    @_f.addMelDocs('turbulence', 'phaseY')
    def setPhaseY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'phaseY', val)

    @_f.addMelDocs('turbulence', 'phaseZ')
    def setPhaseZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'phaseZ', val)

    @_f.addMelDocs('turbulence', 'torusSectionRadius')
    def setTorusSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'torusSectionRadius', val)

    @_f.addMelDocs('turbulence', 'volumeExclusion')
    def setVolumeExclusion(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'volumeExclusion', val)

    @_f.addMelDocs('turbulence', 'volumeOffset')
    def setVolumeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'volumeOffset', val)

    @_f.addMelDocs('turbulence', 'volumeShape')
    def setVolumeShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'volumeShape', val)

    @_f.addMelDocs('turbulence', 'volumeSweep')
    def setVolumeSweep(self, val=True, **kwargs):
        return _f.asEdit(self, effects.turbulence, kwargs, 'volumeSweep', val)


class RadialField(Field):
    __apicls__ = _api.MFnRadialField
    __melnode__ = u'radialField'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnRadialField, 'radialType')
    def getRadialType(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnRadialField, 'radialType')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.deprecated
    def radialType(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnRadialField, 'radialType')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnRadialField, 'setType')
    def setRadialType(self, value):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'double', 'in', None)], self.getRadialType, self.setRadialType, [])
        res = _f.getProxyResult(self, _api.MFnRadialField, 'setType', final_do)
        return res

    @_f.deprecated
    def setType(self, value):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'double', 'in', None)], self.getRadialType, self.setType, [])
        res = _f.getProxyResult(self, _api.MFnRadialField, 'setType', final_do)
        return res


class DragField(Field):
    __apicls__ = _api.MFnDragField
    __melcmd__ = staticmethod(effects.drag)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'drag'
    __melnode__ = u'dragField'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnDragField, 'direction')
    def getDirection(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnDragField, 'direction')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addMelDocs('drag', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, effects.drag, kwargs, 'directionX')
        return res

    @_f.addMelDocs('drag', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, effects.drag, kwargs, 'directionY')
        return res

    @_f.addMelDocs('drag', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, effects.drag, kwargs, 'directionZ')
        return res

    @_f.addMelDocs('drag', 'torusSectionRadius')
    def getTorusSectionRadius(self, **kwargs):
        res = _f.asQuery(self, effects.drag, kwargs, 'torusSectionRadius')
        return res

    @_f.addApiDocs(_api.MFnDragField, 'useDirection')
    def getUseDirection(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnDragField, 'useDirection')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addMelDocs('drag', 'volumeExclusion')
    def getVolumeExclusion(self, **kwargs):
        res = _f.asQuery(self, effects.drag, kwargs, 'volumeExclusion')
        return res

    @_f.addMelDocs('drag', 'volumeOffset')
    def getVolumeOffset(self, **kwargs):
        res = _f.asQuery(self, effects.drag, kwargs, 'volumeOffset')
        return res

    @_f.addMelDocs('drag', 'volumeShape')
    def getVolumeShape(self, **kwargs):
        res = _f.asQuery(self, effects.drag, kwargs, 'volumeShape')
        return res

    @_f.addMelDocs('drag', 'volumeSweep')
    def getVolumeSweep(self, **kwargs):
        res = _f.asQuery(self, effects.drag, kwargs, 'volumeSweep')
        return res

    @_f.addApiDocs(_api.MFnDragField, 'setDirection')
    def setDirection(self, dragDirection):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([dragDirection], [('dragDirection', 'MVector', 'in', None)], self.getDirection, self.setDirection, [])
        res = _f.getProxyResult(self, _api.MFnDragField, 'setDirection', final_do)
        return res

    @_f.addMelDocs('drag', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, effects.drag, kwargs, 'directionX', val)

    @_f.addMelDocs('drag', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, effects.drag, kwargs, 'directionY', val)

    @_f.addMelDocs('drag', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, effects.drag, kwargs, 'directionZ', val)

    @_f.addMelDocs('drag', 'torusSectionRadius')
    def setTorusSectionRadius(self, val=True, **kwargs):
        return _f.asEdit(self, effects.drag, kwargs, 'torusSectionRadius', val)

    @_f.addApiDocs(_api.MFnDragField, 'setUseDirection')
    def setUseDirection(self, enable):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([enable], [('enable', 'bool', 'in', None)], self.getUseDirection, self.setUseDirection, [])
        res = _f.getProxyResult(self, _api.MFnDragField, 'setUseDirection', final_do)
        return res

    @_f.addMelDocs('drag', 'volumeExclusion')
    def setVolumeExclusion(self, val=True, **kwargs):
        return _f.asEdit(self, effects.drag, kwargs, 'volumeExclusion', val)

    @_f.addMelDocs('drag', 'volumeOffset')
    def setVolumeOffset(self, val=True, **kwargs):
        return _f.asEdit(self, effects.drag, kwargs, 'volumeOffset', val)

    @_f.addMelDocs('drag', 'volumeShape')
    def setVolumeShape(self, val=True, **kwargs):
        return _f.asEdit(self, effects.drag, kwargs, 'volumeShape', val)

    @_f.addMelDocs('drag', 'volumeSweep')
    def setVolumeSweep(self, val=True, **kwargs):
        return _f.asEdit(self, effects.drag, kwargs, 'volumeSweep', val)


class THdynField(Field):
    __melnode__ = u'THdynField'
    __slots__ = ()


class IkHandle(Transform):
    __apicls__ = _api.MFnIkHandle
    __melcmd__ = staticmethod(animation.ikHandle)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'ikHandle'
    __melnode__ = u'ikHandle'
    __slots__ = ()
    Stickiness = Enum('Stickiness', {'stickyOff': 0, 'kStickyOff': 0, 'kStickyOn': 1, 'stickyOn': 1, 'superSticky': 2, 'kSuperSticky': 2}, multiKeys=True, defaultKeys={0: 'stickyOff', 1: 'stickyOn', 2: 'superSticky'})

    @_f.addMelDocs('ikHandle', 'autoPriority')
    def autoPriority(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'autoPriority', val)

    @_f.addMelDocs('ikHandle', 'connectEffector')
    def connectEffector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'connectEffector', val)

    @_f.addMelDocs('ikHandle', 'disableHandles')
    def disableHandles(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'disableHandles', val)

    @_f.addMelDocs('ikHandle', 'enableHandles')
    def enableHandles(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'enableHandles', val)

    @_f.addMelDocs('ikHandle', 'freezeJoints')
    def freezeJoints(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'freezeJoints', val)

    @_f.addMelDocs('ikHandle', 'curve')
    def getCurve(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'curve')
        return res

    @_f.addApiDocs(_api.MFnIkHandle, 'getEffector')
    def getEffector(self):
        # type: () -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([], [('effectorPath', 'MDagPath', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'getEffector', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('ikHandle', 'endEffector')
    def getEndEffector(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'endEffector')
        return res

    @_f.addMelDocs('ikHandle', 'forceSolver')
    def getForceSolver(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'forceSolver')
        return res

    @_f.addMelDocs('ikHandle', 'jointList')
    def getJointList(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'jointList')
        return res

    @_f.addMelDocs('ikHandle', 'positionWeight')
    def getPositionWeight(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'positionWeight')
        return res

    @_f.addApiDocs(_api.MFnIkHandle, 'priority')
    def getPriority(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'priority')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('ikHandle', 'rootOnCurve')
    def getRootOnCurve(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'rootOnCurve')
        return res

    @_f.addMelDocs('ikHandle', 'rootTwistMode')
    def getRootTwistMode(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'rootTwistMode')
        return res

    @_f.addMelDocs('ikHandle', 'snapHandleFlagToggle')
    def getSnapHandleFlagToggle(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'snapHandleFlagToggle')
        return res

    @_f.addApiDocs(_api.MFnIkHandle, 'solver')
    def getSolver(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'solver')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnIkHandle, 'getStartJoint')
    def getStartJoint(self):
        # type: () -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([], [('jointPath', 'MDagPath', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'getStartJoint', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnIkHandle, 'stickiness')
    def getStickiness(self):
        # type: () -> IkHandle.Stickiness
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'stickiness')
        return _f.ApiArgUtil._castResult(self, res, ('MFnIkHandle', 'Stickiness'), None)

    @_f.addMelDocs('ikHandle', 'sticky')
    def getSticky(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'sticky')
        return res

    @_f.addMelDocs('ikHandle', 'twistType')
    def getTwistType(self, **kwargs):
        res = _f.asQuery(self, animation.ikHandle, kwargs, 'twistType')
        return res

    @_f.addApiDocs(_api.MFnIkHandle, 'weight')
    def getWeight(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'weight')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnIkHandle, 'poWeight')
    def poWeight(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'poWeight')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('ikHandle', 'curve')
    def setCurve(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'curve', val)

    @_f.addApiDocs(_api.MFnIkHandle, 'setEffector')
    def setEffector(self, effectorPath):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.processApiArgs([effectorPath], [('effectorPath', 'MDagPath', 'in', None)], self.getEffector, self.setEffector, [])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'setEffector', final_do)
        return res

    @_f.addMelDocs('ikHandle', 'endEffector')
    def setEndEffector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'endEffector', val)

    @_f.addMelDocs('ikHandle', 'forceSolver')
    def setForceSolver(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'forceSolver', val)

    @_f.addApiDocs(_api.MFnIkHandle, 'setPOWeight')
    def setPOWeight(self, poWeight):
        # type: (float) -> None
        do, final_do, outTypes = _f.getDoArgs([poWeight], [('poWeight', 'double', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'setPOWeight', final_do)
        return res

    @_f.addMelDocs('ikHandle', 'positionWeight')
    def setPositionWeight(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'positionWeight', val)

    @_f.addApiDocs(_api.MFnIkHandle, 'setPriority')
    def setPriority(self, priority):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([priority], [('priority', 'uint', 'in', None)], self.getPriority, self.setPriority, [])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'setPriority', final_do)
        return res

    @_f.addMelDocs('ikHandle', 'rootOnCurve')
    def setRootOnCurve(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'rootOnCurve', val)

    @_f.addMelDocs('ikHandle', 'rootTwistMode')
    def setRootTwistMode(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'rootTwistMode', val)

    @_f.addMelDocs('ikHandle', 'snapHandleFlagToggle')
    def setSnapHandleFlagToggle(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'snapHandleFlagToggle', val)

    @_f.addApiDocs(_api.MFnIkHandle, 'setSolver')
    def setSolver(self, solver):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.processApiArgs([solver], [('solver', 'MObject', 'in', None)], self.getSolver, self.setSolver, [])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'setSolver', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkHandle, 'setStartJoint')
    def setStartJoint(self, jointPath):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.processApiArgs([jointPath], [('jointPath', 'MDagPath', 'in', None)], self.getStartJoint, self.setStartJoint, [])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'setStartJoint', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkHandle, 'setStartJointAndEffector')
    def setStartJointAndEffector(self, jointPath, effectorPath):
        # type: (general.PyNode, general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([jointPath, effectorPath], [('jointPath', 'MDagPath', 'in', None), ('effectorPath', 'MDagPath', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'setStartJointAndEffector', final_do)
        return res

    @_f.addApiDocs(_api.MFnIkHandle, 'setStickiness')
    def setStickiness(self, stickiness):
        # type: (IkHandle.Stickiness) -> None
        do, final_do, outTypes = _f.processApiArgs([stickiness], [('stickiness', ('MFnIkHandle', 'Stickiness'), 'in', None)], self.getStickiness, self.setStickiness, [])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'setStickiness', final_do)
        return res

    @_f.addMelDocs('ikHandle', 'sticky')
    def setSticky(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'sticky', val)

    @_f.addMelDocs('ikHandle', 'twistType')
    def setTwistType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'twistType', val)

    @_f.addApiDocs(_api.MFnIkHandle, 'setWeight')
    def setWeight(self, weight):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([weight], [('weight', 'double', 'in', None)], self.getWeight, self.setWeight, [])
        res = _f.getProxyResult(self, _api.MFnIkHandle, 'setWeight', final_do)
        return res

    @_f.addMelDocs('ikHandle', 'setupForRPsolver')
    def setupForRPsolver(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'setupForRPsolver', val)

    @_f.addMelDocs('ikHandle', 'snapHandleToEffector')
    def snapHandleToEffector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikHandle, kwargs, 'snapHandleToEffector', val)


class HikGroundPlane(Transform):
    __melnode__ = u'hikGroundPlane'
    __slots__ = ()


class Place3dTexture(Transform):
    __melnode__ = u'place3dTexture'
    __slots__ = ()


class RigidConstraint(Transform):
    __melnode__ = u'rigidConstraint'
    __slots__ = ()


class FosterParent(Transform):
    __melnode__ = u'fosterParent'
    __slots__ = ()


class PointConstraint(Constraint):
    __melcmd__ = staticmethod(animation.pointConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'pointConstraint'
    __melnode__ = u'pointConstraint'
    __slots__ = ()

    @_f.addMelDocs('pointConstraint', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, animation.pointConstraint, kwargs, 'offset')
        return res

    @_f.addMelDocs('pointConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.pointConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('pointConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.pointConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('pointConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.pointConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('pointConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.pointConstraint, kwargs, 'remove', val)

    @_f.addMelDocs('pointConstraint', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, animation.pointConstraint, kwargs, 'offset', val)

    @_f.addMelDocs('pointConstraint', 'skip')
    def skip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.pointConstraint, kwargs, 'skip', val)


class PoleVectorConstraint(PointConstraint):
    __melcmd__ = staticmethod(animation.poleVectorConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'poleVectorConstraint'
    __melnode__ = u'poleVectorConstraint'
    __slots__ = ()


class TangentConstraint(Constraint):
    __melcmd__ = staticmethod(animation.tangentConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'tangentConstraint'
    __melnode__ = u'tangentConstraint'
    __slots__ = ()

    @_f.addMelDocs('tangentConstraint', 'aimVector')
    def getAimVector(self, **kwargs):
        res = _f.asQuery(self, animation.tangentConstraint, kwargs, 'aimVector')
        return res

    @_f.addMelDocs('tangentConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.tangentConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('tangentConstraint', 'upVector')
    def getUpVector(self, **kwargs):
        res = _f.asQuery(self, animation.tangentConstraint, kwargs, 'upVector')
        return res

    @_f.addMelDocs('tangentConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.tangentConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('tangentConstraint', 'worldUpObject')
    def getWorldUpObject(self, **kwargs):
        res = _f.asQuery(self, animation.tangentConstraint, kwargs, 'worldUpObject')
        return res

    @_f.addMelDocs('tangentConstraint', 'worldUpType')
    def getWorldUpType(self, **kwargs):
        res = _f.asQuery(self, animation.tangentConstraint, kwargs, 'worldUpType')
        return res

    @_f.addMelDocs('tangentConstraint', 'worldUpVector')
    def getWorldUpVector(self, **kwargs):
        res = _f.asQuery(self, animation.tangentConstraint, kwargs, 'worldUpVector')
        return res

    @_f.addMelDocs('tangentConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tangentConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('tangentConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tangentConstraint, kwargs, 'remove', val)

    @_f.addMelDocs('tangentConstraint', 'aimVector')
    def setAimVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tangentConstraint, kwargs, 'aimVector', val)

    @_f.addMelDocs('tangentConstraint', 'upVector')
    def setUpVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tangentConstraint, kwargs, 'upVector', val)

    @_f.addMelDocs('tangentConstraint', 'worldUpObject')
    def setWorldUpObject(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tangentConstraint, kwargs, 'worldUpObject', val)

    @_f.addMelDocs('tangentConstraint', 'worldUpType')
    def setWorldUpType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tangentConstraint, kwargs, 'worldUpType', val)

    @_f.addMelDocs('tangentConstraint', 'worldUpVector')
    def setWorldUpVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.tangentConstraint, kwargs, 'worldUpVector', val)


class OldTangentConstraint(Constraint):
    __melnode__ = u'oldTangentConstraint'
    __slots__ = ()


class THconstraint(Constraint):
    __melnode__ = u'THconstraint'
    __slots__ = ()


class SymmetryConstraint(Constraint):
    __melnode__ = u'symmetryConstraint'
    __slots__ = ()


class GeometryConstraint(Constraint):
    __melcmd__ = staticmethod(animation.geometryConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'geometryConstraint'
    __melnode__ = u'geometryConstraint'
    __slots__ = ()

    @_f.addMelDocs('geometryConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.geometryConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('geometryConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.geometryConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('geometryConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.geometryConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('geometryConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.geometryConstraint, kwargs, 'remove', val)


class OldNormalConstraint(Constraint):
    __melnode__ = u'oldNormalConstraint'
    __slots__ = ()


class AimConstraint(Constraint):
    __melcmd__ = staticmethod(animation.aimConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'aimConstraint'
    __melnode__ = u'aimConstraint'
    __slots__ = ()

    @_f.addMelDocs('aimConstraint', 'aimVector')
    def getAimVector(self, **kwargs):
        res = _f.asQuery(self, animation.aimConstraint, kwargs, 'aimVector')
        return res

    @_f.addMelDocs('aimConstraint', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, animation.aimConstraint, kwargs, 'offset')
        return res

    @_f.addMelDocs('aimConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.aimConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('aimConstraint', 'upVector')
    def getUpVector(self, **kwargs):
        res = _f.asQuery(self, animation.aimConstraint, kwargs, 'upVector')
        return res

    @_f.addMelDocs('aimConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.aimConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('aimConstraint', 'worldUpObject')
    def getWorldUpObject(self, **kwargs):
        res = _f.asQuery(self, animation.aimConstraint, kwargs, 'worldUpObject')
        return res

    @_f.addMelDocs('aimConstraint', 'worldUpType')
    def getWorldUpType(self, **kwargs):
        res = _f.asQuery(self, animation.aimConstraint, kwargs, 'worldUpType')
        return res

    @_f.addMelDocs('aimConstraint', 'worldUpVector')
    def getWorldUpVector(self, **kwargs):
        res = _f.asQuery(self, animation.aimConstraint, kwargs, 'worldUpVector')
        return res

    @_f.addMelDocs('aimConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('aimConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'remove', val)

    @_f.addMelDocs('aimConstraint', 'aimVector')
    def setAimVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'aimVector', val)

    @_f.addMelDocs('aimConstraint', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'offset', val)

    @_f.addMelDocs('aimConstraint', 'upVector')
    def setUpVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'upVector', val)

    @_f.addMelDocs('aimConstraint', 'worldUpObject')
    def setWorldUpObject(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'worldUpObject', val)

    @_f.addMelDocs('aimConstraint', 'worldUpType')
    def setWorldUpType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'worldUpType', val)

    @_f.addMelDocs('aimConstraint', 'worldUpVector')
    def setWorldUpVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'worldUpVector', val)

    @_f.addMelDocs('aimConstraint', 'skip')
    def skip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.aimConstraint, kwargs, 'skip', val)


class LookAt(AimConstraint):
    __melnode__ = u'lookAt'
    __slots__ = ()


class OrientConstraint(Constraint):
    __melcmd__ = staticmethod(animation.orientConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'orientConstraint'
    __melnode__ = u'orientConstraint'
    __slots__ = ()

    @_f.addMelDocs('orientConstraint', 'createCache')
    def createCache(self, val=True, **kwargs):
        return _f.asEdit(self, animation.orientConstraint, kwargs, 'createCache', val)

    @_f.addMelDocs('orientConstraint', 'deleteCache')
    def deleteCache(self, val=True, **kwargs):
        return _f.asEdit(self, animation.orientConstraint, kwargs, 'deleteCache', val)

    @_f.addMelDocs('orientConstraint', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, animation.orientConstraint, kwargs, 'offset')
        return res

    @_f.addMelDocs('orientConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.orientConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('orientConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.orientConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('orientConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.orientConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('orientConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.orientConstraint, kwargs, 'remove', val)

    @_f.addMelDocs('orientConstraint', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, animation.orientConstraint, kwargs, 'offset', val)

    @_f.addMelDocs('orientConstraint', 'skip')
    def skip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.orientConstraint, kwargs, 'skip', val)


class ParentConstraint(Constraint):
    __melcmd__ = staticmethod(animation.parentConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'parentConstraint'
    __melnode__ = u'parentConstraint'
    __slots__ = ()

    @_f.addMelDocs('parentConstraint', 'createCache')
    def createCache(self, val=True, **kwargs):
        return _f.asEdit(self, animation.parentConstraint, kwargs, 'createCache', val)

    @_f.addMelDocs('parentConstraint', 'deleteCache')
    def deleteCache(self, val=True, **kwargs):
        return _f.asEdit(self, animation.parentConstraint, kwargs, 'deleteCache', val)

    @_f.addMelDocs('parentConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.parentConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('parentConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.parentConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('parentConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.parentConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('parentConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.parentConstraint, kwargs, 'remove', val)


class NormalConstraint(Constraint):
    __melcmd__ = staticmethod(animation.normalConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'normalConstraint'
    __melnode__ = u'normalConstraint'
    __slots__ = ()

    @_f.addMelDocs('normalConstraint', 'aimVector')
    def getAimVector(self, **kwargs):
        res = _f.asQuery(self, animation.normalConstraint, kwargs, 'aimVector')
        return res

    @_f.addMelDocs('normalConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.normalConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('normalConstraint', 'upVector')
    def getUpVector(self, **kwargs):
        res = _f.asQuery(self, animation.normalConstraint, kwargs, 'upVector')
        return res

    @_f.addMelDocs('normalConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.normalConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('normalConstraint', 'worldUpObject')
    def getWorldUpObject(self, **kwargs):
        res = _f.asQuery(self, animation.normalConstraint, kwargs, 'worldUpObject')
        return res

    @_f.addMelDocs('normalConstraint', 'worldUpType')
    def getWorldUpType(self, **kwargs):
        res = _f.asQuery(self, animation.normalConstraint, kwargs, 'worldUpType')
        return res

    @_f.addMelDocs('normalConstraint', 'worldUpVector')
    def getWorldUpVector(self, **kwargs):
        res = _f.asQuery(self, animation.normalConstraint, kwargs, 'worldUpVector')
        return res

    @_f.addMelDocs('normalConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.normalConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('normalConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.normalConstraint, kwargs, 'remove', val)

    @_f.addMelDocs('normalConstraint', 'aimVector')
    def setAimVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.normalConstraint, kwargs, 'aimVector', val)

    @_f.addMelDocs('normalConstraint', 'upVector')
    def setUpVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.normalConstraint, kwargs, 'upVector', val)

    @_f.addMelDocs('normalConstraint', 'worldUpObject')
    def setWorldUpObject(self, val=True, **kwargs):
        return _f.asEdit(self, animation.normalConstraint, kwargs, 'worldUpObject', val)

    @_f.addMelDocs('normalConstraint', 'worldUpType')
    def setWorldUpType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.normalConstraint, kwargs, 'worldUpType', val)

    @_f.addMelDocs('normalConstraint', 'worldUpVector')
    def setWorldUpVector(self, val=True, **kwargs):
        return _f.asEdit(self, animation.normalConstraint, kwargs, 'worldUpVector', val)


class PointOnPolyConstraint(Constraint):
    __melcmd__ = staticmethod(animation.pointOnPolyConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'pointOnPolyConstraint'
    __melnode__ = u'pointOnPolyConstraint'
    __slots__ = ()

    @_f.addMelDocs('pointOnPolyConstraint', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, animation.pointOnPolyConstraint, kwargs, 'offset')
        return res

    @_f.addMelDocs('pointOnPolyConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.pointOnPolyConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('pointOnPolyConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.pointOnPolyConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('pointOnPolyConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.pointOnPolyConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('pointOnPolyConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.pointOnPolyConstraint, kwargs, 'remove', val)

    @_f.addMelDocs('pointOnPolyConstraint', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, animation.pointOnPolyConstraint, kwargs, 'offset', val)

    @_f.addMelDocs('pointOnPolyConstraint', 'skip')
    def skip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.pointOnPolyConstraint, kwargs, 'skip', val)


class ScaleConstraint(Constraint):
    __melcmd__ = staticmethod(animation.scaleConstraint)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'scaleConstraint'
    __melnode__ = u'scaleConstraint'
    __slots__ = ()

    @_f.addMelDocs('scaleConstraint', 'offset')
    def getOffset(self, **kwargs):
        res = _f.asQuery(self, animation.scaleConstraint, kwargs, 'offset')
        return res

    @_f.addMelDocs('scaleConstraint', 'targetList')
    def getTargetList(self, **kwargs):
        res = _f.asQuery(self, animation.scaleConstraint, kwargs, 'targetList')
        return res

    @_f.addMelDocs('scaleConstraint', 'weightAliasList')
    def getWeightAliasList(self, **kwargs):
        res = _f.asQuery(self, animation.scaleConstraint, kwargs, 'weightAliasList')
        return res

    @_f.addMelDocs('scaleConstraint', 'layer')
    def layer(self, val=True, **kwargs):
        return _f.asEdit(self, animation.scaleConstraint, kwargs, 'layer', val)

    @_f.addMelDocs('scaleConstraint', 'remove')
    def remove(self, val=True, **kwargs):
        return _f.asEdit(self, animation.scaleConstraint, kwargs, 'remove', val)

    @_f.addMelDocs('scaleConstraint', 'scaleCompensate')
    def scaleCompensate(self, val=True, **kwargs):
        return _f.asEdit(self, animation.scaleConstraint, kwargs, 'scaleCompensate', val)

    @_f.addMelDocs('scaleConstraint', 'offset')
    def setOffset(self, val=True, **kwargs):
        return _f.asEdit(self, animation.scaleConstraint, kwargs, 'offset', val)

    @_f.addMelDocs('scaleConstraint', 'skip')
    def skip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.scaleConstraint, kwargs, 'skip', val)


class TextureDeformerHandle(Transform):
    __melnode__ = u'textureDeformerHandle'
    __slots__ = ()


class Nucleus(Transform):
    __melnode__ = u'nucleus'
    __slots__ = ()


class ClipGhostShape(Transform):
    __melnode__ = u'clipGhostShape'
    __slots__ = ()


class HikEffector(Transform):
    __apicls__ = _api.MFnHikEffector
    __melnode__ = u'hikEffector'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnHikEffector, 'getAuxiliaryEffectors')
    def getAuxiliaryEffectors(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('effs', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnHikEffector, 'getAuxiliaryEffectors', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnHikEffector, 'getEffColor')
    def getEffColor(self):
        # type: () -> Color
        res = _f.getProxyResult(self, _api.MFnHikEffector, 'getEffColor')
        return _f.ApiArgUtil._castResult(self, res, 'MColor', None)

    @_f.addApiDocs(_api.MFnHikEffector, 'getPivotOffset')
    def getPivotOffset(self):
        # type: () -> Vector
        res = _f.getProxyResult(self, _api.MFnHikEffector, 'getPivotOffset')
        return _f.ApiArgUtil._castResult(self, res, 'MVector', None)

    @_f.addApiDocs(_api.MFnHikEffector, 'setEffColor')
    def setEffColor(self, color):
        # type: (Color) -> None
        do, final_do, outTypes = _f.processApiArgs([color], [('color', 'MColor', 'in', None)], self.getEffColor, self.setEffColor, [])
        res = _f.getProxyResult(self, _api.MFnHikEffector, 'setEffColor', final_do)
        return res

    @_f.addApiDocs(_api.MFnHikEffector, 'setPivotOffset')
    def setPivotOffset(self, vector):
        # type: (Vector) -> None
        do, final_do, outTypes = _f.processApiArgs([vector], [('vector', 'MVector', 'in', None)], self.getPivotOffset, self.setPivotOffset, [])
        res = _f.getProxyResult(self, _api.MFnHikEffector, 'setPivotOffset', final_do)
        return res


class KeyingGroup(ObjectSet):
    __melcmd__ = staticmethod(animation.keyingGroup)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'keyingGroup'
    __melnode__ = u'keyingGroup'
    __slots__ = ()

    @_f.addMelDocs('keyingGroup', 'addElement')
    def addElement(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'addElement', val)

    @_f.addMelDocs('keyingGroup', 'afterFilters')
    def afterFilters(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'afterFilters', val)

    @_f.addMelDocs('keyingGroup', 'flatten')
    def flatten(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'flatten', val)

    @_f.addMelDocs('keyingGroup', 'activator')
    def getActivator(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'activator')
        return res

    @_f.addMelDocs('keyingGroup', 'category')
    def getCategory(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'category')
        return res

    @_f.addMelDocs('keyingGroup', 'color')
    def getColor(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'color')
        return res

    @_f.addMelDocs('keyingGroup', 'edges')
    def getEdges(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'edges')
        return res

    @_f.addMelDocs('keyingGroup', 'editPoints')
    def getEditPoints(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'editPoints')
        return res

    @_f.addMelDocs('keyingGroup', 'facets')
    def getFacets(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'facets')
        return res

    @_f.addMelDocs('keyingGroup', 'minimizeRotation')
    def getMinimizeRotation(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'minimizeRotation')
        return res

    @_f.addMelDocs('keyingGroup', 'nodesOnly')
    def getNodesOnly(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'nodesOnly')
        return res

    @_f.addMelDocs('keyingGroup', 'renderable')
    def getRenderable(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'renderable')
        return res

    @_f.addMelDocs('keyingGroup', 'setActiveFilter')
    def getSetActiveFilter(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'setActiveFilter')
        return res

    @_f.addMelDocs('keyingGroup', 'size')
    def getSize(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'size')
        return res

    @_f.addMelDocs('keyingGroup', 'text')
    def getText(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'text')
        return res

    @_f.addMelDocs('keyingGroup', 'vertices')
    def getVertices(self, **kwargs):
        res = _f.asQuery(self, animation.keyingGroup, kwargs, 'vertices')
        return res

    @_f.addMelDocs('keyingGroup', 'include')
    def include(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'include', val)

    @_f.addMelDocs('keyingGroup', 'removeActivator')
    def removeActivator(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'removeActivator', val)

    @_f.addMelDocs('keyingGroup', 'activator')
    def setActivator(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'activator', val)

    @_f.addMelDocs('keyingGroup', 'category')
    def setCategory(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'category', val)

    @_f.addMelDocs('keyingGroup', 'color')
    def setColor(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'color', val)

    @_f.addMelDocs('keyingGroup', 'minimizeRotation')
    def setMinimizeRotation(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'minimizeRotation', val)

    @_f.addMelDocs('keyingGroup', 'setActiveFilter')
    def setSetActiveFilter(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'setActiveFilter', val)

    @_f.addMelDocs('keyingGroup', 'text')
    def setText(self, val=True, **kwargs):
        return _f.asEdit(self, animation.keyingGroup, kwargs, 'text', val)


class BakeSet(ObjectSet):
    __melnode__ = u'bakeSet'
    __slots__ = ()


class VertexBakeSet(BakeSet):
    __melnode__ = u'vertexBakeSet'
    __slots__ = ()


class TextureBakeSet(BakeSet):
    __melnode__ = u'textureBakeSet'
    __slots__ = ()


class Character(ObjectSet):
    __apicls__ = _api.MFnCharacter
    __melcmd__ = staticmethod(animation.character)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'character'
    __melnode__ = u'character'
    __slots__ = ()

    @_f.addMelDocs('character', 'addElement')
    def addElement(self, val=True, **kwargs):
        return _f.asEdit(self, animation.character, kwargs, 'addElement', val)

    @_f.addApiDocs(_api.MFnCharacter, 'blendExists')
    def blendExists(self, instancedClip1, instancedClip2, blendResult):
        # type: (general.PyNode, general.PyNode, general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([instancedClip1, instancedClip2, blendResult], [('instancedClip1', 'MObject', 'in', None), ('instancedClip2', 'MObject', 'in', None), ('blendResult', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCharacter, 'blendExists', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addMelDocs('character', 'flatten')
    def flatten(self, val=True, **kwargs):
        return _f.asEdit(self, animation.character, kwargs, 'flatten', val)

    @_f.addMelDocs('character', 'addOffsetObject')
    def getAddOffsetObject(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'addOffsetObject')
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getBlend')
    def getBlend(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getBlend', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getBlendClips')
    def getBlendClips(self, index):
        # type: (int) -> Tuple[general.PyNode, general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'int', 'in', None), ('clip1', 'MObject', 'out', None), ('clip2', 'MObject', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getBlendClips', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnCharacter, 'getBlendCount')
    def getBlendCount(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getBlendCount')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('character', 'characterPlug')
    def getCharacterPlug(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'characterPlug')
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getCharacterThatOwnsPlug')
    def getCharacterThatOwnsPlug(self, plug, result):
        # type: (Attribute, general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([plug, result], [('plug', 'MPlug', 'in', None), ('result', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getCharacterThatOwnsPlug', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getClipScheduler')
    def getClipScheduler(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getClipScheduler')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addMelDocs('character', 'isIntersecting')
    def getIsIntersecting(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'isIntersecting')
        return res

    @_f.addMelDocs('character', 'isMember')
    def getIsMember(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'isMember')
        return res

    @_f.addMelDocs('character', 'library')
    def getLibrary(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'library')
        return res

    @_f.addMelDocs('character', 'memberIndex')
    def getMemberIndex(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'memberIndex')
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getMemberPlugs')
    def getMemberPlugs(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('result', 'MPlugArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getMemberPlugs', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('character', 'nodesOnly')
    def getNodesOnly(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'nodesOnly')
        return res

    @_f.addMelDocs('character', 'offsetNode')
    def getOffsetNode(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'offsetNode')
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getScheduledClip')
    def getScheduledClip(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getScheduledClip', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getScheduledClipCount')
    def getScheduledClipCount(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getScheduledClipCount')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('character', 'scheduler')
    def getScheduler(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'scheduler')
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getSourceClip')
    def getSourceClip(self, index):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([index], [('index', 'int', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getSourceClip', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnCharacter, 'getSourceClipCount')
    def getSourceClipCount(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getSourceClipCount')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnCharacter, 'getSubCharacters')
    def getSubCharacters(self):
        # type: () -> SelectionSet
        do, final_do, outTypes = _f.getDoArgs([], [('result', 'MSelectionList', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnCharacter, 'getSubCharacters', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('character', 'subtract')
    def getSubtract(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'subtract')
        return res

    @_f.addMelDocs('character', 'text')
    def getText(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'text')
        return res

    @_f.addMelDocs('character', 'userAlias')
    def getUserAlias(self, **kwargs):
        res = _f.asQuery(self, animation.character, kwargs, 'userAlias')
        return res

    @_f.addMelDocs('character', 'include')
    def include(self, val=True, **kwargs):
        return _f.asEdit(self, animation.character, kwargs, 'include', val)

    @_f.addMelDocs('character', 'removeOffsetObject')
    def removeOffsetObject(self, val=True, **kwargs):
        return _f.asEdit(self, animation.character, kwargs, 'removeOffsetObject', val)

    @_f.addMelDocs('character', 'addOffsetObject')
    def setAddOffsetObject(self, val=True, **kwargs):
        return _f.asEdit(self, animation.character, kwargs, 'addOffsetObject', val)

    @_f.addMelDocs('character', 'text')
    def setText(self, val=True, **kwargs):
        return _f.asEdit(self, animation.character, kwargs, 'text', val)


class THobjectSet(ObjectSet):
    __melnode__ = u'THobjectSet'
    __slots__ = ()


class CreaseSet(ObjectSet):
    __melnode__ = u'creaseSet'
    __slots__ = ()


class Partition(Entity):
    __apicls__ = _api.MFnPartition
    __melcmd__ = staticmethod(general.partition)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'partition'
    __melnode__ = u'partition'
    __slots__ = ()
    if versions.current() >= versions.v2019:
        Restriction = Enum('Restriction', {'none': 0, 'kNone': 0, 'verticesOnly': 1, 'kVerticesOnly': 1, 'kEdgesOnly': 2, 'edgesOnly': 2, 'facetsOnly': 3, 'kFacetsOnly': 3, 'editPointsOnly': 4, 'kEditPointsOnly': 4, 'renderableOnly': 5, 'kRenderableOnly': 5}, multiKeys=True, defaultKeys={0: 'none', 1: 'verticesOnly', 2: 'edgesOnly', 3: 'facetsOnly', 4: 'editPointsOnly', 5: 'renderableOnly'})

    @_f.addApiDocs(_api.MFnPartition, 'addMember')
    def addMember(self, set):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([set], [('set', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnPartition, 'addMember', final_do)
        return res

    @_f.addMelDocs('partition', 'render')
    def getRender(self, **kwargs):
        res = _f.asQuery(self, general.partition, kwargs, 'render')
        return res

    @_f.addApiDocs(_api.MFnPartition, 'isRenderPartition')
    def isRenderPartition(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnPartition, 'isRenderPartition')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnPartition, 'removeMember')
    def removeMember(self, set):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.getDoArgs([set], [('set', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnPartition, 'removeMember', final_do)
        return res


class Container(ContainerBase):
    __melcmd__ = staticmethod(general.container)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'container'
    __melnode__ = u'container'
    __slots__ = ()

    @_f.addMelDocs('container', 'addNode')
    def addNode(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'addNode', val)

    @_f.addMelDocs('container', 'force')
    def force(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'force', val)

    @_f.addMelDocs('container', 'asset')
    def getAsset(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'asset')
        return res

    @_f.addMelDocs('container', 'assetMember')
    def getAssetMember(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'assetMember')
        return res

    @_f.addMelDocs('container', 'bindAttr')
    def getBindAttr(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'bindAttr')
        return res

    @_f.addMelDocs('container', 'connectionList')
    def getConnectionList(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'connectionList')
        return res

    @_f.addMelDocs('container', 'current')
    def getCurrent(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'current')
        return res

    @_f.addMelDocs('container', 'fileName')
    def getFileName(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'fileName')
        return res

    @_f.addMelDocs('container', 'findContainer')
    def getFindContainer(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'findContainer')
        return res

    @_f.addMelDocs('container', 'isContainer')
    def getIsContainer(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'isContainer')
        return res

    @_f.addMelDocs('container', 'nodeList')
    def getNodeList(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'nodeList')
        return res

    @_f.addMelDocs('container', 'publishAsChild')
    def getPublishAsChild(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'publishAsChild')
        return res

    @_f.addMelDocs('container', 'publishAsParent')
    def getPublishAsParent(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'publishAsParent')
        return res

    @_f.addMelDocs('container', 'publishAsRoot')
    def getPublishAsRoot(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'publishAsRoot')
        return res

    @_f.addMelDocs('container', 'publishAttr')
    def getPublishAttr(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'publishAttr')
        return res

    @_f.addMelDocs('container', 'publishName')
    def getPublishName(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'publishName')
        return res

    @_f.addMelDocs('container', 'type')
    def getType(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'type')
        return res

    @_f.addMelDocs('container', 'unbindAttr')
    def getUnbindAttr(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'unbindAttr')
        return res

    @_f.addMelDocs('container', 'unsortedOrder')
    def getUnsortedOrder(self, **kwargs):
        res = _f.asQuery(self, general.container, kwargs, 'unsortedOrder')
        return res

    @_f.addMelDocs('container', 'includeHierarchyAbove')
    def includeHierarchyAbove(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'includeHierarchyAbove', val)

    @_f.addMelDocs('container', 'includeHierarchyBelow')
    def includeHierarchyBelow(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'includeHierarchyBelow', val)

    @_f.addMelDocs('container', 'includeNetwork')
    def includeNetwork(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'includeNetwork', val)

    @_f.addMelDocs('container', 'includeNetworkDetails')
    def includeNetworkDetails(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'includeNetworkDetails', val)

    @_f.addMelDocs('container', 'includeShaders')
    def includeShaders(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'includeShaders', val)

    @_f.addMelDocs('container', 'includeShapes')
    def includeShapes(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'includeShapes', val)

    @_f.addMelDocs('container', 'includeTransform')
    def includeTransform(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'includeTransform', val)

    @_f.addMelDocs('container', 'nodeNamePrefix')
    def nodeNamePrefix(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'nodeNamePrefix', val)

    @_f.addMelDocs('container', 'publishAndBind')
    def publishAndBind(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'publishAndBind', val)

    @_f.addMelDocs('container', 'publishConnections')
    def publishConnections(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'publishConnections', val)

    @_f.addMelDocs('container', 'removeContainer')
    def removeContainer(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'removeContainer', val)

    @_f.addMelDocs('container', 'removeNode')
    def removeNode(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'removeNode', val)

    @_f.addMelDocs('container', 'bindAttr')
    def setBindAttr(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'bindAttr', val)

    @_f.addMelDocs('container', 'current')
    def setCurrent(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'current', val)

    @_f.addMelDocs('container', 'publishAsChild')
    def setPublishAsChild(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'publishAsChild', val)

    @_f.addMelDocs('container', 'publishAsParent')
    def setPublishAsParent(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'publishAsParent', val)

    @_f.addMelDocs('container', 'publishAsRoot')
    def setPublishAsRoot(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'publishAsRoot', val)

    @_f.addMelDocs('container', 'publishName')
    def setPublishName(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'publishName', val)

    @_f.addMelDocs('container', 'unbindAttr')
    def setUnbindAttr(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'unbindAttr', val)

    @_f.addMelDocs('container', 'unbindAndUnpublish')
    def unbindAndUnpublish(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'unbindAndUnpublish', val)

    @_f.addMelDocs('container', 'unbindChild')
    def unbindChild(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'unbindChild', val)

    @_f.addMelDocs('container', 'unbindParent')
    def unbindParent(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'unbindParent', val)

    @_f.addMelDocs('container', 'unpublishChild')
    def unpublishChild(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'unpublishChild', val)

    @_f.addMelDocs('container', 'unpublishName')
    def unpublishName(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'unpublishName', val)

    @_f.addMelDocs('container', 'unpublishParent')
    def unpublishParent(self, val=True, **kwargs):
        return _f.asEdit(self, general.container, kwargs, 'unpublishParent', val)


class HardwareRenderGlobals(DependNode):
    __melnode__ = u'hardwareRenderGlobals'
    __slots__ = ()


class ClipScheduler(DependNode):
    __melnode__ = u'clipScheduler'
    __slots__ = ()


class Bump3d(DependNode):
    __melnode__ = u'bump3d'
    __slots__ = ()


class AboutToSetValueTestNode(DependNode):
    __melnode__ = u'aboutToSetValueTestNode'
    __slots__ = ()


class Flow(DependNode):
    __melcmd__ = staticmethod(animation.flow)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'flow'
    __melnode__ = u'flow'
    __slots__ = ()

    @_f.addMelDocs('flow', 'divisions')
    def getDivisions(self, **kwargs):
        res = _f.asQuery(self, animation.flow, kwargs, 'divisions')
        return res

    @_f.addMelDocs('flow', 'localCompute')
    def getLocalCompute(self, **kwargs):
        res = _f.asQuery(self, animation.flow, kwargs, 'localCompute')
        return res

    @_f.addMelDocs('flow', 'localDivisions')
    def getLocalDivisions(self, **kwargs):
        res = _f.asQuery(self, animation.flow, kwargs, 'localDivisions')
        return res

    @_f.addMelDocs('flow', 'objectCentered')
    def getObjectCentered(self, **kwargs):
        res = _f.asQuery(self, animation.flow, kwargs, 'objectCentered')
        return res


class Snapshot(DependNode):
    __melcmd__ = staticmethod(animation.snapshot)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'snapshot'
    __melnode__ = u'snapshot'
    __slots__ = ()

    @_f.addMelDocs('snapshot', 'constructionHistory')
    def getConstructionHistory(self, **kwargs):
        res = _f.asQuery(self, animation.snapshot, kwargs, 'constructionHistory')
        return res

    @_f.addMelDocs('snapshot', 'endTime')
    def getEndTime(self, **kwargs):
        res = _f.asQuery(self, animation.snapshot, kwargs, 'endTime')
        return res

    @_f.addMelDocs('snapshot', 'increment')
    def getIncrement(self, **kwargs):
        res = _f.asQuery(self, animation.snapshot, kwargs, 'increment')
        return res

    @_f.addMelDocs('snapshot', 'startTime')
    def getStartTime(self, **kwargs):
        res = _f.asQuery(self, animation.snapshot, kwargs, 'startTime')
        return res

    @_f.addMelDocs('snapshot', 'update')
    def getUpdate(self, **kwargs):
        res = _f.asQuery(self, animation.snapshot, kwargs, 'update')
        return res

    @_f.addMelDocs('snapshot', 'endTime')
    def setEndTime(self, val=True, **kwargs):
        return _f.asEdit(self, animation.snapshot, kwargs, 'endTime', val)

    @_f.addMelDocs('snapshot', 'increment')
    def setIncrement(self, val=True, **kwargs):
        return _f.asEdit(self, animation.snapshot, kwargs, 'increment', val)

    @_f.addMelDocs('snapshot', 'startTime')
    def setStartTime(self, val=True, **kwargs):
        return _f.asEdit(self, animation.snapshot, kwargs, 'startTime', val)

    @_f.addMelDocs('snapshot', 'update')
    def setUpdate(self, val=True, **kwargs):
        return _f.asEdit(self, animation.snapshot, kwargs, 'update', val)


class MotionTrail(Snapshot):
    __melnode__ = u'motionTrail'
    __slots__ = ()


class Blend(DependNode):
    __melcmd__ = staticmethod(other.blend)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'blend'
    __melnode__ = u'blend'
    __slots__ = ()


class BlendWeighted(Blend):
    __melnode__ = u'blendWeighted'
    __slots__ = ()


class BlendDevice(Blend):
    __melnode__ = u'blendDevice'
    __slots__ = ()


class BlendTwoAttr(Blend):
    __melcmd__ = staticmethod(animation.blendTwoAttr)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'blendTwoAttr'
    __melnode__ = u'blendTwoAttr'
    __slots__ = ()

    @_f.addMelDocs('blendTwoAttr', 'attribute0')
    def getAttribute0(self, **kwargs):
        res = _f.asQuery(self, animation.blendTwoAttr, kwargs, 'attribute0')
        return res

    @_f.addMelDocs('blendTwoAttr', 'attribute1')
    def getAttribute1(self, **kwargs):
        res = _f.asQuery(self, animation.blendTwoAttr, kwargs, 'attribute1')
        return res

    @_f.addMelDocs('blendTwoAttr', 'blender')
    def getBlender(self, **kwargs):
        res = _f.asQuery(self, animation.blendTwoAttr, kwargs, 'blender')
        return res

    @_f.addMelDocs('blendTwoAttr', 'driver')
    def getDriver(self, **kwargs):
        res = _f.asQuery(self, animation.blendTwoAttr, kwargs, 'driver')
        return res

    @_f.addMelDocs('blendTwoAttr', 'attribute0')
    def setAttribute0(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendTwoAttr, kwargs, 'attribute0', val)

    @_f.addMelDocs('blendTwoAttr', 'attribute1')
    def setAttribute1(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendTwoAttr, kwargs, 'attribute1', val)

    @_f.addMelDocs('blendTwoAttr', 'blender')
    def setBlender(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendTwoAttr, kwargs, 'blender', val)

    @_f.addMelDocs('blendTwoAttr', 'driver')
    def setDriver(self, val=True, **kwargs):
        return _f.asEdit(self, animation.blendTwoAttr, kwargs, 'driver', val)


class Luminance(DependNode):
    __melnode__ = u'luminance'
    __slots__ = ()


class Shot(DependNode):
    __melcmd__ = staticmethod(animation.shot)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'shot'
    __melnode__ = u'shot'
    __slots__ = ()

    @_f.addMelDocs('shot', 'createCustomAnim')
    def createCustomAnim(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'createCustomAnim', val)

    @_f.addMelDocs('shot', 'deleteCustomAnim')
    def deleteCustomAnim(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'deleteCustomAnim', val)

    @_f.addMelDocs('shot', 'audio')
    def getAudio(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'audio')
        return res

    @_f.addMelDocs('shot', 'clip')
    def getClip(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'clip')
        return res

    @_f.addMelDocs('shot', 'clipDuration')
    def getClipDuration(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'clipDuration')
        return res

    @_f.addMelDocs('shot', 'clipOpacity')
    def getClipOpacity(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'clipOpacity')
        return res

    @_f.addMelDocs('shot', 'clipSyncState')
    def getClipSyncState(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'clipSyncState')
        res = bool(res)
        return res

    @_f.addMelDocs('shot', 'clipZeroOffset')
    def getClipZeroOffset(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'clipZeroOffset')
        return res

    @_f.addMelDocs('shot', 'copy')
    def getCopy(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'copy')
        return res

    @_f.addMelDocs('shot', 'currentCamera')
    def getCurrentCamera(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'currentCamera')
        return res

    @_f.addMelDocs('shot', 'customAnim')
    def getCustomAnim(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'customAnim')
        return res

    @_f.addMelDocs('shot', 'determineTrack')
    def getDetermineTrack(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'determineTrack')
        return res

    @_f.addMelDocs('shot', 'endTime')
    def getEndTime(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'endTime')
        return res

    @_f.addMelDocs('shot', 'favorite')
    def getFavorite(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'favorite')
        return res

    @_f.addMelDocs('shot', 'flag1')
    def getFlag1(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag1')
        return res

    @_f.addMelDocs('shot', 'flag10')
    def getFlag10(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag10')
        return res

    @_f.addMelDocs('shot', 'flag11')
    def getFlag11(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag11')
        return res

    @_f.addMelDocs('shot', 'flag12')
    def getFlag12(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag12')
        return res

    @_f.addMelDocs('shot', 'flag2')
    def getFlag2(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag2')
        return res

    @_f.addMelDocs('shot', 'flag3')
    def getFlag3(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag3')
        return res

    @_f.addMelDocs('shot', 'flag4')
    def getFlag4(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag4')
        return res

    @_f.addMelDocs('shot', 'flag5')
    def getFlag5(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag5')
        return res

    @_f.addMelDocs('shot', 'flag6')
    def getFlag6(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag6')
        return res

    @_f.addMelDocs('shot', 'flag7')
    def getFlag7(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag7')
        return res

    @_f.addMelDocs('shot', 'flag8')
    def getFlag8(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag8')
        return res

    @_f.addMelDocs('shot', 'flag9')
    def getFlag9(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'flag9')
        return res

    @_f.addMelDocs('shot', 'hasCameraSet')
    def getHasCameraSet(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'hasCameraSet')
        return res

    @_f.addMelDocs('shot', 'hasStereoCamera')
    def getHasStereoCamera(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'hasStereoCamera')
        return res

    @_f.addMelDocs('shot', 'imagePlaneVisibility')
    def getImagePlaneVisibility(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'imagePlaneVisibility')
        return res

    @_f.addMelDocs('shot', 'linkAudio')
    def getLinkAudio(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'linkAudio')
        return res

    @_f.addMelDocs('shot', 'lock')
    def getLock(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'lock')
        return res

    @_f.addMelDocs('shot', 'mute')
    def getMute(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'mute')
        return res

    @_f.addMelDocs('shot', 'paste')
    def getPaste(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'paste')
        return res

    @_f.addMelDocs('shot', 'pasteInstance')
    def getPasteInstance(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'pasteInstance')
        return res

    @_f.addMelDocs('shot', 'postHoldTime')
    def getPostHoldTime(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'postHoldTime')
        return res

    @_f.addMelDocs('shot', 'preHoldTime')
    def getPreHoldTime(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'preHoldTime')
        return res

    @_f.addMelDocs('shot', 'scale')
    def getScale(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'scale')
        return res

    @_f.addMelDocs('shot', 'selfmute')
    def getSelfmute(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'selfmute')
        return res

    @_f.addMelDocs('shot', 'sequenceDuration')
    def getSequenceDuration(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'sequenceDuration')
        return res

    @_f.addMelDocs('shot', 'sequenceEndTime')
    def getSequenceEndTime(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'sequenceEndTime')
        return res

    @_f.addMelDocs('shot', 'sequenceStartTime')
    def getSequenceStartTime(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'sequenceStartTime')
        return res

    @_f.addMelDocs('shot', 'shotName')
    def getShotName(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'shotName')
        return res

    @_f.addMelDocs('shot', 'sourceDuration')
    def getSourceDuration(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'sourceDuration')
        return res

    @_f.addMelDocs('shot', 'startTime')
    def getStartTime(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'startTime')
        return res

    @_f.addMelDocs('shot', 'track')
    def getTrack(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'track')
        return res

    @_f.addMelDocs('shot', 'transitionInLength')
    def getTransitionInLength(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'transitionInLength')
        return res

    @_f.addMelDocs('shot', 'transitionInType')
    def getTransitionInType(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'transitionInType')
        return res

    @_f.addMelDocs('shot', 'transitionOutLength')
    def getTransitionOutLength(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'transitionOutLength')
        return res

    @_f.addMelDocs('shot', 'transitionOutType')
    def getTransitionOutType(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'transitionOutType')
        return res

    @_f.addMelDocs('shot', 'unlinkAudio')
    def getUnlinkAudio(self, **kwargs):
        res = _f.asQuery(self, animation.shot, kwargs, 'unlinkAudio')
        return res

    @_f.addMelDocs('shot', 'audio')
    def setAudio(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'audio', val)

    @_f.addMelDocs('shot', 'clip')
    def setClip(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'clip', val)

    @_f.addMelDocs('shot', 'clipDuration')
    def setClipDuration(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'clipDuration', val)

    @_f.addMelDocs('shot', 'clipOpacity')
    def setClipOpacity(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'clipOpacity', val)

    @_f.addMelDocs('shot', 'clipSyncState')
    def setClipSyncState(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'clipSyncState', val)

    @_f.addMelDocs('shot', 'clipZeroOffset')
    def setClipZeroOffset(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'clipZeroOffset', val)

    @_f.addMelDocs('shot', 'copy')
    def setCopy(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'copy', val)

    @_f.addMelDocs('shot', 'currentCamera')
    def setCurrentCamera(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'currentCamera', val)

    @_f.addMelDocs('shot', 'determineTrack')
    def setDetermineTrack(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'determineTrack', val)

    @_f.addMelDocs('shot', 'endTime')
    def setEndTime(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'endTime', val)

    @_f.addMelDocs('shot', 'favorite')
    def setFavorite(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'favorite', val)

    @_f.addMelDocs('shot', 'flag1')
    def setFlag1(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag1', val)

    @_f.addMelDocs('shot', 'flag10')
    def setFlag10(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag10', val)

    @_f.addMelDocs('shot', 'flag11')
    def setFlag11(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag11', val)

    @_f.addMelDocs('shot', 'flag12')
    def setFlag12(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag12', val)

    @_f.addMelDocs('shot', 'flag2')
    def setFlag2(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag2', val)

    @_f.addMelDocs('shot', 'flag3')
    def setFlag3(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag3', val)

    @_f.addMelDocs('shot', 'flag4')
    def setFlag4(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag4', val)

    @_f.addMelDocs('shot', 'flag5')
    def setFlag5(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag5', val)

    @_f.addMelDocs('shot', 'flag6')
    def setFlag6(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag6', val)

    @_f.addMelDocs('shot', 'flag7')
    def setFlag7(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag7', val)

    @_f.addMelDocs('shot', 'flag8')
    def setFlag8(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag8', val)

    @_f.addMelDocs('shot', 'flag9')
    def setFlag9(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'flag9', val)

    @_f.addMelDocs('shot', 'hasCameraSet')
    def setHasCameraSet(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'hasCameraSet', val)

    @_f.addMelDocs('shot', 'hasStereoCamera')
    def setHasStereoCamera(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'hasStereoCamera', val)

    @_f.addMelDocs('shot', 'imagePlaneVisibility')
    def setImagePlaneVisibility(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'imagePlaneVisibility', val)

    @_f.addMelDocs('shot', 'linkAudio')
    def setLinkAudio(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'linkAudio', val)

    @_f.addMelDocs('shot', 'lock')
    def setLock(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'lock', val)

    @_f.addMelDocs('shot', 'mute')
    def setMute(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'mute', val)

    @_f.addMelDocs('shot', 'paste')
    def setPaste(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'paste', val)

    @_f.addMelDocs('shot', 'pasteInstance')
    def setPasteInstance(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'pasteInstance', val)

    @_f.addMelDocs('shot', 'postHoldTime')
    def setPostHoldTime(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'postHoldTime', val)

    @_f.addMelDocs('shot', 'preHoldTime')
    def setPreHoldTime(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'preHoldTime', val)

    @_f.addMelDocs('shot', 'scale')
    def setScale(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'scale', val)

    @_f.addMelDocs('shot', 'selfmute')
    def setSelfmute(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'selfmute', val)

    @_f.addMelDocs('shot', 'sequenceDuration')
    def setSequenceDuration(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'sequenceDuration', val)

    @_f.addMelDocs('shot', 'sequenceEndTime')
    def setSequenceEndTime(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'sequenceEndTime', val)

    @_f.addMelDocs('shot', 'sequenceStartTime')
    def setSequenceStartTime(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'sequenceStartTime', val)

    @_f.addMelDocs('shot', 'shotName')
    def setShotName(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'shotName', val)

    @_f.addMelDocs('shot', 'sourceDuration')
    def setSourceDuration(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'sourceDuration', val)

    @_f.addMelDocs('shot', 'startTime')
    def setStartTime(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'startTime', val)

    @_f.addMelDocs('shot', 'track')
    def setTrack(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'track', val)

    @_f.addMelDocs('shot', 'transitionInLength')
    def setTransitionInLength(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'transitionInLength', val)

    @_f.addMelDocs('shot', 'transitionInType')
    def setTransitionInType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'transitionInType', val)

    @_f.addMelDocs('shot', 'transitionOutLength')
    def setTransitionOutLength(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'transitionOutLength', val)

    @_f.addMelDocs('shot', 'transitionOutType')
    def setTransitionOutType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'transitionOutType', val)

    @_f.addMelDocs('shot', 'unlinkAudio')
    def setUnlinkAudio(self, val=True, **kwargs):
        return _f.asEdit(self, animation.shot, kwargs, 'unlinkAudio', val)


class TextureToGeom(DependNode):
    __melnode__ = u'textureToGeom'
    __slots__ = ()


class RemapHsv(DependNode):
    __melnode__ = u'remapHsv'
    __slots__ = ()


class DefaultRenderUtilityList(DependNode):
    __melnode__ = u'defaultRenderUtilityList'
    __slots__ = ()


class TadskAssetInstanceNode_TdependNode(DependNode):
    __melnode__ = u'TadskAssetInstanceNode_TdependNode'
    __slots__ = ()


class AdskMaterial(TadskAssetInstanceNode_TdependNode):
    __melnode__ = u'adskMaterial'
    __slots__ = ()


class SubdivReverseFaces(DependNode):
    __melnode__ = u'subdivReverseFaces'
    __slots__ = ()


class AnimBlend(DependNode):
    __melnode__ = u'animBlend'
    __slots__ = ()


class AnimBlendInOut(AnimBlend):
    __melnode__ = u'animBlendInOut'
    __slots__ = ()


class UvChooser(DependNode):
    __melnode__ = u'uvChooser'
    __slots__ = ()


class DiskCache(DependNode):
    __melcmd__ = staticmethod(system.diskCache)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'diskCache'
    __melnode__ = u'diskCache'
    __slots__ = ()

    @_f.addMelDocs('diskCache', 'append')
    def getAppend(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'append')
        return res

    @_f.addMelDocs('diskCache', 'cacheType')
    def getCacheType(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'cacheType')
        return res

    @_f.addMelDocs('diskCache', 'close')
    def getClose(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'close')
        return res

    @_f.addMelDocs('diskCache', 'closeAll')
    def getCloseAll(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'closeAll')
        return res

    @_f.addMelDocs('diskCache', 'delete')
    def getDelete(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'delete')
        return res

    @_f.addMelDocs('diskCache', 'deleteAll')
    def getDeleteAll(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'deleteAll')
        return res

    @_f.addMelDocs('diskCache', 'empty')
    def getEmpty(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'empty')
        return res

    @_f.addMelDocs('diskCache', 'emptyAll')
    def getEmptyAll(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'emptyAll')
        return res

    @_f.addMelDocs('diskCache', 'enabledCachesOnly')
    def getEnabledCachesOnly(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'enabledCachesOnly')
        return res

    @_f.addMelDocs('diskCache', 'endTime')
    def getEndTime(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'endTime')
        return res

    @_f.addMelDocs('diskCache', 'frameRangeType')
    def getFrameRangeType(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'frameRangeType')
        return res

    @_f.addMelDocs('diskCache', 'overSample')
    def getOverSample(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'overSample')
        return res

    @_f.addMelDocs('diskCache', 'samplingRate')
    def getSamplingRate(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'samplingRate')
        return res

    @_f.addMelDocs('diskCache', 'startTime')
    def getStartTime(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'startTime')
        return res

    @_f.addMelDocs('diskCache', 'tempDir')
    def getTempDir(self, **kwargs):
        res = _f.asQuery(self, system.diskCache, kwargs, 'tempDir')
        return res


class GreasePencilSequence(DependNode):
    __melnode__ = u'greasePencilSequence'
    __slots__ = ()


class OldBlindDataBase(DependNode):
    __melnode__ = u'oldBlindDataBase'
    __slots__ = ()


class LightLinker(DependNode):
    __melnode__ = u'lightLinker'
    __slots__ = ()


class GammaCorrect(DependNode):
    __melnode__ = u'gammaCorrect'
    __slots__ = ()


class PoseInterpolatorManager(DependNode):
    __melnode__ = u'poseInterpolatorManager'
    __slots__ = ()


class ViewColorManager(DependNode):
    __melnode__ = u'viewColorManager'
    __slots__ = ()


class Reference(DependNode):
    __apicls__ = _api.MFnReference
    __melcmd__ = staticmethod(system.reference)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'reference'
    __melnode__ = u'reference'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnReference, 'associatedNamespace')
    def associatedNamespace(self, baseName):
        # type: (bool) -> unicode
        do, final_do, outTypes = _f.getDoArgs([baseName], [('baseName', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnReference, 'associatedNamespace', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.addApiDocs(_api.MFnReference, 'containsNode')
    def containsNode(self, node):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([node], [('node', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnReference, 'containsNode', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnReference, 'containsNodeExactly')
    def containsNodeExactly(self, node):
        # type: (general.PyNode) -> bool
        do, final_do, outTypes = _f.getDoArgs([node], [('node', 'MObject', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnReference, 'containsNodeExactly', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'bool', None)
        return res

    @_f.addApiDocs(_api.MFnReference, 'fileName')
    def fileName(self, resolvedName, includePath, includeCopyNumber):
        # type: (bool, bool, bool) -> unicode
        do, final_do, outTypes = _f.getDoArgs([resolvedName, includePath, includeCopyNumber], [('resolvedName', 'bool', 'in', None), ('includePath', 'bool', 'in', None), ('includeCopyNumber', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnReference, 'fileName', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.addApiDocs(_api.MFnReference, 'isExportEditsFile')
    def isExportEditsFile(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnReference, 'isExportEditsFile')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnReference, 'isLoaded')
    def isLoaded(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnReference, 'isLoaded')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnReference, 'nodes')
    def nodes(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('nodeList', 'MObjectArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnReference, 'nodes', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnReference, 'parentAssembly')
    def parentAssembly(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnReference, 'parentAssembly')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)

    @_f.addApiDocs(_api.MFnReference, 'parentFileName')
    def parentFileName(self, resolveName, includePath, includeCopyNumber):
        # type: (bool, bool, bool) -> unicode
        do, final_do, outTypes = _f.getDoArgs([resolveName, includePath, includeCopyNumber], [('resolveName', 'bool', 'in', None), ('includePath', 'bool', 'in', None), ('includeCopyNumber', 'bool', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnReference, 'parentFileName', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MString', None)
        return res

    @_f.addApiDocs(_api.MFnReference, 'parentReference')
    def parentReference(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnReference, 'parentReference')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)


class MultilisterLight(DependNode):
    __melnode__ = u'multilisterLight'
    __slots__ = ()


class SubdivToPoly(DependNode):
    __melnode__ = u'subdivToPoly'
    __slots__ = ()


class MultMatrix(DependNode):
    __melnode__ = u'multMatrix'
    __slots__ = ()


class Membrane(DependNode):
    __melnode__ = u'membrane'
    __slots__ = ()


class RenderGlobalsList(DependNode):
    __melnode__ = u'renderGlobalsList'
    __slots__ = ()


class SubdBase(DependNode):
    __melnode__ = u'subdBase'
    __slots__ = ()


class SubdModifier(SubdBase):
    __melnode__ = u'subdModifier'
    __slots__ = ()


class SubdCleanTopology(SubdModifier):
    __melcmd__ = staticmethod(modeling.subdCleanTopology)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'subdCleanTopology'
    __melnode__ = u'subdCleanTopology'
    __slots__ = ()


class SubdMapCut(SubdModifier):
    __melcmd__ = staticmethod(modeling.subdMapCut)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'subdMapCut'
    __melnode__ = u'subdMapCut'
    __slots__ = ()

    @_f.addMelDocs('subdMapCut', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.subdMapCut, kwargs, 'caching')
        return res

    @_f.addMelDocs('subdMapCut', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.subdMapCut, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('subdMapCut', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdMapCut, kwargs, 'caching', val)

    @_f.addMelDocs('subdMapCut', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdMapCut, kwargs, 'nodeState', val)


class SubdTweak(SubdModifier):
    __melnode__ = u'subdTweak'
    __slots__ = ()


class SubdModifierWorld(SubdModifier):
    __melnode__ = u'subdModifierWorld'
    __slots__ = ()


class SubdPlanarProj(SubdModifierWorld):
    __melnode__ = u'subdPlanarProj'
    __slots__ = ()


class SubdModifierUV(SubdModifierWorld):
    __melnode__ = u'subdModifierUV'
    __slots__ = ()


class SubdAutoProj(SubdModifierUV):
    __melnode__ = u'subdAutoProj'
    __slots__ = ()


class SubdLayoutUV(SubdModifierUV):
    __melcmd__ = staticmethod(modeling.subdLayoutUV)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'subdLayoutUV'
    __melnode__ = u'subdLayoutUV'
    __slots__ = ()

    @_f.addMelDocs('subdLayoutUV', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'caching')
        return res

    @_f.addMelDocs('subdLayoutUV', 'flipReversed')
    def getFlipReversed(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'flipReversed')
        return res

    @_f.addMelDocs('subdLayoutUV', 'layout')
    def getLayout(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'layout')
        return res

    @_f.addMelDocs('subdLayoutUV', 'layoutMethod')
    def getLayoutMethod(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'layoutMethod')
        return res

    @_f.addMelDocs('subdLayoutUV', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('subdLayoutUV', 'percentageSpace')
    def getPercentageSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'percentageSpace')
        return res

    @_f.addMelDocs('subdLayoutUV', 'rotateForBestFit')
    def getRotateForBestFit(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'rotateForBestFit')
        return res

    @_f.addMelDocs('subdLayoutUV', 'scale')
    def getScale(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'scale')
        return res

    @_f.addMelDocs('subdLayoutUV', 'separate')
    def getSeparate(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'separate')
        return res

    @_f.addMelDocs('subdLayoutUV', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.subdLayoutUV, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('subdLayoutUV', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'caching', val)

    @_f.addMelDocs('subdLayoutUV', 'flipReversed')
    def setFlipReversed(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'flipReversed', val)

    @_f.addMelDocs('subdLayoutUV', 'layout')
    def setLayout(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'layout', val)

    @_f.addMelDocs('subdLayoutUV', 'layoutMethod')
    def setLayoutMethod(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'layoutMethod', val)

    @_f.addMelDocs('subdLayoutUV', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'nodeState', val)

    @_f.addMelDocs('subdLayoutUV', 'percentageSpace')
    def setPercentageSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'percentageSpace', val)

    @_f.addMelDocs('subdLayoutUV', 'rotateForBestFit')
    def setRotateForBestFit(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'rotateForBestFit', val)

    @_f.addMelDocs('subdLayoutUV', 'scale')
    def setScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'scale', val)

    @_f.addMelDocs('subdLayoutUV', 'separate')
    def setSeparate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'separate', val)

    @_f.addMelDocs('subdLayoutUV', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdLayoutUV, kwargs, 'worldSpace', val)


class SubdMapSewMove(SubdModifierUV):
    __melcmd__ = staticmethod(modeling.subdMapSewMove)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'subdMapSewMove'
    __melnode__ = u'subdMapSewMove'
    __slots__ = ()

    @_f.addMelDocs('subdMapSewMove', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.subdMapSewMove, kwargs, 'caching')
        return res

    @_f.addMelDocs('subdMapSewMove', 'limitPieceSize')
    def getLimitPieceSize(self, **kwargs):
        res = _f.asQuery(self, modeling.subdMapSewMove, kwargs, 'limitPieceSize')
        return res

    @_f.addMelDocs('subdMapSewMove', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.subdMapSewMove, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('subdMapSewMove', 'numberFaces')
    def getNumberFaces(self, **kwargs):
        res = _f.asQuery(self, modeling.subdMapSewMove, kwargs, 'numberFaces')
        return res

    @_f.addMelDocs('subdMapSewMove', 'worldSpace')
    def getWorldSpace(self, **kwargs):
        res = _f.asQuery(self, modeling.subdMapSewMove, kwargs, 'worldSpace')
        return res

    @_f.addMelDocs('subdMapSewMove', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdMapSewMove, kwargs, 'caching', val)

    @_f.addMelDocs('subdMapSewMove', 'limitPieceSize')
    def setLimitPieceSize(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdMapSewMove, kwargs, 'limitPieceSize', val)

    @_f.addMelDocs('subdMapSewMove', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdMapSewMove, kwargs, 'nodeState', val)

    @_f.addMelDocs('subdMapSewMove', 'numberFaces')
    def setNumberFaces(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdMapSewMove, kwargs, 'numberFaces', val)

    @_f.addMelDocs('subdMapSewMove', 'worldSpace')
    def setWorldSpace(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.subdMapSewMove, kwargs, 'worldSpace', val)


class SubdAddTopology(SubdModifier):
    __melnode__ = u'subdAddTopology'
    __slots__ = ()


class SubdTweakUV(SubdModifier):
    __melnode__ = u'subdTweakUV'
    __slots__ = ()


class TimeEditorClipEvaluator(DependNode):
    __melnode__ = u'timeEditorClipEvaluator'
    __slots__ = ()


class ToonLineAttributes(DependNode):
    __melnode__ = u'toonLineAttributes'
    __slots__ = ()


class Reverse(DependNode):
    __melnode__ = u'reverse'
    __slots__ = ()


class DataBlockTest(DependNode):
    __melnode__ = u'dataBlockTest'
    __slots__ = ()


class ThreadedDevice(DependNode):
    __melnode__ = u'threadedDevice'
    __slots__ = ()


class ClientDevice(ThreadedDevice):
    __melnode__ = u'clientDevice'
    __slots__ = ()


class Expression(DependNode):
    __apicls__ = _api.MFnExpression
    __melcmd__ = staticmethod(effects.expression)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'expression'
    __melnode__ = u'expression'
    __slots__ = ()
    UnitConversion = Enum('UnitConversion', {'all': 0, 'kAll': 0, 'none': 1, 'kNone': 1, 'angularOnly': 2, 'kAngularOnly': 2}, multiKeys=True, defaultKeys={0: 'all', 1: 'none', 2: 'angularOnly'})

    @_f.addApiDocs(_api.MFnExpression, 'evaluate')
    def evaluate(self):
        # type: () -> List[float]
        do, final_do, outTypes = _f.getDoArgs([], [('result', 'MDoubleArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnExpression, 'evaluate', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addMelDocs('expression', 'alwaysEvaluate')
    def getAlwaysEvaluate(self, **kwargs):
        res = _f.asQuery(self, effects.expression, kwargs, 'alwaysEvaluate')
        return res

    @_f.addMelDocs('expression', 'animated')
    def getAnimated(self, **kwargs):
        res = _f.asQuery(self, effects.expression, kwargs, 'animated')
        return res

    @_f.addMelDocs('expression', 'attribute')
    def getAttribute(self, **kwargs):
        res = _f.asQuery(self, effects.expression, kwargs, 'attribute')
        return res

    @_f.addApiDocs(_api.MFnExpression, 'getDefaultObject')
    def getDefaultObject(self):
        # type: () -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([], [('object', 'MObject', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnExpression, 'getDefaultObject', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnExpression, 'expression')
    def getExpression(self):
        # type: () -> unicode
        res = _f.getProxyResult(self, _api.MFnExpression, 'expression')
        return _f.ApiArgUtil._castResult(self, res, 'MString', None)

    @_f.addMelDocs('expression', 'object')
    def getObject(self, **kwargs):
        res = _f.asQuery(self, effects.expression, kwargs, 'object')
        return res

    @_f.addMelDocs('expression', 'safe')
    def getSafe(self, **kwargs):
        res = _f.asQuery(self, effects.expression, kwargs, 'safe')
        return res

    @_f.addMelDocs('expression', 'shortNames')
    def getShortNames(self, **kwargs):
        res = _f.asQuery(self, effects.expression, kwargs, 'shortNames')
        return res

    @_f.addMelDocs('expression', 'string')
    def getString(self, **kwargs):
        res = _f.asQuery(self, effects.expression, kwargs, 'string')
        return res

    @_f.addMelDocs('expression', 'timeDependent')
    def getTimeDependent(self, **kwargs):
        res = _f.asQuery(self, effects.expression, kwargs, 'timeDependent')
        return res

    @_f.addApiDocs(_api.MFnExpression, 'unitConversion')
    def getUnitConversion(self):
        # type: () -> Expression.UnitConversion
        res = _f.getProxyResult(self, _api.MFnExpression, 'unitConversion')
        return _f.ApiArgUtil._castResult(self, res, ('MFnExpression', 'UnitConversion'), None)

    @_f.addApiDocs(_api.MFnExpression, 'isAnimated')
    def isAnimated(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnExpression, 'isAnimated')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addMelDocs('expression', 'alwaysEvaluate')
    def setAlwaysEvaluate(self, val=True, **kwargs):
        return _f.asEdit(self, effects.expression, kwargs, 'alwaysEvaluate', val)

    @_f.addApiDocs(_api.MFnExpression, 'setAnimated')
    def setAnimated(self, value=False):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([value], [('value', 'bool', 'in', None)], self.isAnimated, self.setAnimated, [])
        res = _f.getProxyResult(self, _api.MFnExpression, 'setAnimated', final_do)
        return res

    @_f.addMelDocs('expression', 'attribute')
    def setAttribute(self, val=True, **kwargs):
        return _f.asEdit(self, effects.expression, kwargs, 'attribute', val)

    @_f.addApiDocs(_api.MFnExpression, 'setDefaultObject')
    def setDefaultObject(self, object):
        # type: (general.PyNode) -> None
        do, final_do, outTypes = _f.processApiArgs([object], [('object', 'MObject', 'in', None)], self.getDefaultObject, self.setDefaultObject, [])
        res = _f.getProxyResult(self, _api.MFnExpression, 'setDefaultObject', final_do)
        return res

    @_f.addApiDocs(_api.MFnExpression, 'setExpression')
    def setExpression(self, expression):
        # type: (unicode) -> None
        do, final_do, outTypes = _f.processApiArgs([expression], [('expression', 'MString', 'in', None)], self.getExpression, self.setExpression, [])
        res = _f.getProxyResult(self, _api.MFnExpression, 'setExpression', final_do)
        return res

    @_f.addMelDocs('expression', 'object')
    def setObject(self, val=True, **kwargs):
        return _f.asEdit(self, effects.expression, kwargs, 'object', val)

    @_f.addMelDocs('expression', 'shortNames')
    def setShortNames(self, val=True, **kwargs):
        return _f.asEdit(self, effects.expression, kwargs, 'shortNames', val)

    @_f.addMelDocs('expression', 'string')
    def setString(self, val=True, **kwargs):
        return _f.asEdit(self, effects.expression, kwargs, 'string', val)

    @_f.addApiDocs(_api.MFnExpression, 'setUnitConversion')
    def setUnitConversion(self, conversion):
        # type: (Expression.UnitConversion) -> None
        do, final_do, outTypes = _f.processApiArgs([conversion], [('conversion', ('MFnExpression', 'UnitConversion'), 'in', None)], self.getUnitConversion, self.setUnitConversion, [])
        res = _f.getProxyResult(self, _api.MFnExpression, 'setUnitConversion', final_do)
        return res


class RgbToHsv(DependNode):
    __melnode__ = u'rgbToHsv'
    __slots__ = ()


class FourByFourMatrix(DependNode):
    __melnode__ = u'fourByFourMatrix'
    __slots__ = ()


class IkSystem(DependNode):
    __melcmd__ = staticmethod(animation.ikSystem)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'ikSystem'
    __melnode__ = u'ikSystem'
    __slots__ = ()

    @_f.addMelDocs('ikSystem', 'autoPriority')
    def autoPriority(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSystem, kwargs, 'autoPriority', val)

    @_f.addMelDocs('ikSystem', 'autoPriorityMC')
    def autoPriorityMC(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSystem, kwargs, 'autoPriorityMC', val)

    @_f.addMelDocs('ikSystem', 'autoPrioritySC')
    def autoPrioritySC(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSystem, kwargs, 'autoPrioritySC', val)

    @_f.addMelDocs('ikSystem', 'allowRotation')
    def getAllowRotation(self, **kwargs):
        res = _f.asQuery(self, animation.ikSystem, kwargs, 'allowRotation')
        return res

    @_f.addMelDocs('ikSystem', 'list')
    def getList(self, **kwargs):
        res = _f.asQuery(self, animation.ikSystem, kwargs, 'list')
        return res

    @_f.addMelDocs('ikSystem', 'snap')
    def getSnap(self, **kwargs):
        res = _f.asQuery(self, animation.ikSystem, kwargs, 'snap')
        return res

    @_f.addMelDocs('ikSystem', 'solve')
    def getSolve(self, **kwargs):
        res = _f.asQuery(self, animation.ikSystem, kwargs, 'solve')
        return res

    @_f.addMelDocs('ikSystem', 'solverTypes')
    def getSolverTypes(self, **kwargs):
        res = _f.asQuery(self, animation.ikSystem, kwargs, 'solverTypes')
        return res

    @_f.addMelDocs('ikSystem', 'allowRotation')
    def setAllowRotation(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSystem, kwargs, 'allowRotation', val)

    @_f.addMelDocs('ikSystem', 'list')
    def setList(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSystem, kwargs, 'list', val)

    @_f.addMelDocs('ikSystem', 'snap')
    def setSnap(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSystem, kwargs, 'snap', val)

    @_f.addMelDocs('ikSystem', 'solve')
    def setSolve(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSystem, kwargs, 'solve', val)


class VolumeShader(DependNode):
    __melnode__ = u'volumeShader'
    __slots__ = ()


class Sequencer(DependNode):
    __melnode__ = u'sequencer'
    __slots__ = ()


class AngleBetween(DependNode):
    __melcmd__ = staticmethod(modeling.angleBetween)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'angleBetween'
    __melnode__ = u'angleBetween'
    __slots__ = ()


class DeleteUVSet(DependNode):
    __melnode__ = u'deleteUVSet'
    __slots__ = ()


class TimeEditorAnimSource(DependNode):
    __melcmd__ = staticmethod(animation.timeEditorAnimSource)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'timeEditorAnimSource'
    __melnode__ = u'timeEditorAnimSource'
    __slots__ = ()

    @_f.addMelDocs('timeEditorAnimSource', 'addSource')
    def addSource(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'addSource', val)

    @_f.addMelDocs('timeEditorAnimSource', 'apply')
    def apply(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'apply', val)

    @_f.addMelDocs('timeEditorAnimSource', 'bakeToAnimSource')
    def bakeToAnimSource(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'bakeToAnimSource', val)

    @_f.addMelDocs('timeEditorAnimSource', 'copyAnimation')
    def copyAnimation(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'copyAnimation', val)

    @_f.addMelDocs('timeEditorAnimSource', 'exclusive')
    def exclusive(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'exclusive', val)

    @_f.addMelDocs('timeEditorAnimSource', 'export')
    def export(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'export', val)

    @_f.addMelDocs('timeEditorAnimSource', 'addObjects')
    def getAddObjects(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'addObjects')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'addRelatedKG')
    def getAddRelatedKG(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'addRelatedKG')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'addSelectedObjects')
    def getAddSelectedObjects(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'addSelectedObjects')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'calculateTiming')
    def getCalculateTiming(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'calculateTiming')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'drivenClips')
    def getDrivenClips(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'drivenClips')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'isUnique')
    def getIsUnique(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'isUnique')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'targetIndex')
    def getTargetIndex(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'targetIndex')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'targets')
    def getTargets(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'targets')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'type')
    def getType(self, **kwargs):
        res = _f.asQuery(self, animation.timeEditorAnimSource, kwargs, 'type')
        return res

    @_f.addMelDocs('timeEditorAnimSource', 'importOption')
    def importOption(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'importOption', val)

    @_f.addMelDocs('timeEditorAnimSource', 'importPopulateOption')
    def importPopulateOption(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'importPopulateOption', val)

    @_f.addMelDocs('timeEditorAnimSource', 'includeRoot')
    def includeRoot(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'includeRoot', val)

    @_f.addMelDocs('timeEditorAnimSource', 'recursively')
    def recursively(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'recursively', val)

    @_f.addMelDocs('timeEditorAnimSource', 'removeSceneAnimation')
    def removeSceneAnimation(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'removeSceneAnimation', val)

    @_f.addMelDocs('timeEditorAnimSource', 'removeSource')
    def removeSource(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'removeSource', val)

    @_f.addMelDocs('timeEditorAnimSource', 'addObjects')
    def setAddObjects(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'addObjects', val)

    @_f.addMelDocs('timeEditorAnimSource', 'addRelatedKG')
    def setAddRelatedKG(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'addRelatedKG', val)

    @_f.addMelDocs('timeEditorAnimSource', 'addSelectedObjects')
    def setAddSelectedObjects(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'addSelectedObjects', val)

    @_f.addMelDocs('timeEditorAnimSource', 'calculateTiming')
    def setCalculateTiming(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'calculateTiming', val)

    @_f.addMelDocs('timeEditorAnimSource', 'type')
    def setType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeEditorAnimSource, kwargs, 'type', val)


class HierarchyTestNode1(DependNode):
    __melnode__ = u'hierarchyTestNode1'
    __slots__ = ()


class HierarchyTestNode2(HierarchyTestNode1):
    __melnode__ = u'hierarchyTestNode2'
    __slots__ = ()


class HierarchyTestNode3(HierarchyTestNode2):
    __melnode__ = u'hierarchyTestNode3'
    __slots__ = ()


class WtAddMatrix(DependNode):
    __melnode__ = u'wtAddMatrix'
    __slots__ = ()


class ProxyManager(DependNode):
    __melnode__ = u'proxyManager'
    __slots__ = ()


class MotionPath(DependNode):
    __apicls__ = _api.MFnMotionPath
    __melnode__ = u'motionPath'
    __slots__ = ()
    Axis = Enum('Axis', {'kXaxis': 0, 'xaxis': 0, 'yaxis': 1, 'kYaxis': 1, 'kZaxis': 2, 'zaxis': 2}, multiKeys=True, defaultKeys={0: 'xaxis', 1: 'yaxis', 2: 'zaxis'})

    @_f.addApiDocs(_api.MFnMotionPath, 'addAnimatedObject')
    def addAnimatedObject(self, objectToAnimate, modifier=None):
        # type: (general.PyNode, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.getDoArgs([objectToAnimate, modifier], [('objectToAnimate', 'MDagPath', 'in', None), ('modifier', 'MDGModifier', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'addAnimatedObject', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'getAnimatedObjects')
    def getAnimatedObjects(self):
        # type: () -> List[general.PyNode]
        do, final_do, outTypes = _f.getDoArgs([], [('array', 'MDagPathArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'getAnimatedObjects', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnMotionPath, 'bank')
    def getBank(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'bank')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'bankScale')
    def getBankScale(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'bankScale')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'bankThreshold')
    def getBankThreshold(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'bankThreshold')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'follow')
    def getFollow(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'follow')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'followAxis')
    def getFollowAxis(self):
        # type: () -> MotionPath.Axis
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'followAxis')
        return _f.ApiArgUtil._castResult(self, res, ('MFnMotionPath', 'Axis'), None)

    @_f.addApiDocs(_api.MFnMotionPath, 'inverseNormal')
    def getInverseNormal(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'inverseNormal')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'getOrientationMarker')
    def getOrientationMarker(self, markerNum):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([markerNum], [('markerNum', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'getOrientationMarker', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'pathObject')
    def getPathObject(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'pathObject')
        return _f.ApiArgUtil._castResult(self, res, 'MDagPath', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'getPositionMarker')
    def getPositionMarker(self, markerNum):
        # type: (int) -> general.PyNode
        do, final_do, outTypes = _f.getDoArgs([markerNum], [('markerNum', 'uint', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'getPositionMarker', final_do)
        res = _f.ApiArgUtil._castResult(self, res, 'MObject', None)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'uEnd')
    def getUEnd(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'uEnd')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'uStart')
    def getUStart(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'uStart')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'uTimeEnd')
    def getUTimeEnd(self):
        # type: () -> Time
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'uTimeEnd')
        return _f.ApiArgUtil._castResult(self, res, 'MTime', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'uTimeStart')
    def getUTimeStart(self):
        # type: () -> Time
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'uTimeStart')
        return _f.ApiArgUtil._castResult(self, res, 'MTime', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'upAxis')
    def getUpAxis(self):
        # type: () -> MotionPath.Axis
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'upAxis')
        return _f.ApiArgUtil._castResult(self, res, ('MFnMotionPath', 'Axis'), None)

    @_f.addApiDocs(_api.MFnMotionPath, 'useNormal')
    def getUseNormal(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'useNormal')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'numOrientationMarkers')
    def numOrientationMarkers(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'numOrientationMarkers')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'numPositionMarkers')
    def numPositionMarkers(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'numPositionMarkers')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addApiDocs(_api.MFnMotionPath, 'setBank')
    def setBank(self, bank):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([bank], [('bank', 'bool', 'in', None)], self.getBank, self.setBank, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setBank', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setBankScale')
    def setBankScale(self, bankScale):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([bankScale], [('bankScale', 'double', 'in', None)], self.getBankScale, self.setBankScale, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setBankScale', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setBankThreshold')
    def setBankThreshold(self, bankThreshold):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([bankThreshold], [('bankThreshold', 'double', 'in', None)], self.getBankThreshold, self.setBankThreshold, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setBankThreshold', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setFollow')
    def setFollow(self, on, modifier=None):
        # type: (bool, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([on, modifier], [('on', 'bool', 'in', None), ('modifier', 'MDGModifier', 'in', None)], self.getFollow, self.setFollow, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setFollow', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setFollowAxis')
    def setFollowAxis(self, axis):
        # type: (MotionPath.Axis) -> None
        do, final_do, outTypes = _f.processApiArgs([axis], [('axis', ('MFnMotionPath', 'Axis'), 'in', None)], self.getFollowAxis, self.setFollowAxis, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setFollowAxis', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setInverseNormal')
    def setInverseNormal(self, invert):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([invert], [('invert', 'bool', 'in', None)], self.getInverseNormal, self.setInverseNormal, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setInverseNormal', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setPathObject')
    def setPathObject(self, pathObject, modifier=None):
        # type: (general.PyNode, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([pathObject, modifier], [('pathObject', 'MDagPath', 'in', None), ('modifier', 'MDGModifier', 'in', None)], self.getPathObject, self.setPathObject, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setPathObject', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setUEnd')
    def setUEnd(self, end):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([end], [('end', 'double', 'in', None)], self.getUEnd, self.setUEnd, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setUEnd', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setUStart')
    def setUStart(self, start):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([start], [('start', 'double', 'in', None)], self.getUStart, self.setUStart, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setUStart', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setUTimeEnd')
    def setUTimeEnd(self, end):
        # type: (Time) -> None
        do, final_do, outTypes = _f.processApiArgs([end], [('end', 'MTime', 'in', None)], self.getUTimeEnd, self.setUTimeEnd, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setUTimeEnd', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setUTimeStart')
    def setUTimeStart(self, start):
        # type: (Time) -> None
        do, final_do, outTypes = _f.processApiArgs([start], [('start', 'MTime', 'in', None)], self.getUTimeStart, self.setUTimeStart, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setUTimeStart', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setUpAxis')
    def setUpAxis(self, axis):
        # type: (MotionPath.Axis) -> None
        do, final_do, outTypes = _f.processApiArgs([axis], [('axis', ('MFnMotionPath', 'Axis'), 'in', None)], self.getUpAxis, self.setUpAxis, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setUpAxis', final_do)
        return res

    @_f.addApiDocs(_api.MFnMotionPath, 'setUseNormal')
    def setUseNormal(self, use):
        # type: (bool) -> None
        do, final_do, outTypes = _f.processApiArgs([use], [('use', 'bool', 'in', None)], self.getUseNormal, self.setUseNormal, [])
        res = _f.getProxyResult(self, _api.MFnMotionPath, 'setUseNormal', final_do)
        return res


class THmotionPath(MotionPath):
    __melnode__ = u'THmotionPath'
    __slots__ = ()


class Controller(DependNode):
    __melcmd__ = staticmethod(animation.controller)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'controller'
    __melnode__ = u'controller'
    __slots__ = ()

    @_f.addMelDocs('controller', 'allControllers')
    def getAllControllers(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'allControllers')
        return res

    @_f.addMelDocs('controller', 'children')
    def getChildren(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'children')
        return res

    @_f.addMelDocs('controller', 'group')
    def getGroup(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'group')
        return res

    @_f.addMelDocs('controller', 'index')
    def getIndex(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'index')
        return res

    @_f.addMelDocs('controller', 'isController')
    def getIsController(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'isController')
        return res

    @_f.addMelDocs('controller', 'parent')
    def getParent(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'parent')
        return res

    @_f.addMelDocs('controller', 'pickWalkDown')
    def getPickWalkDown(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'pickWalkDown')
        return res

    @_f.addMelDocs('controller', 'pickWalkLeft')
    def getPickWalkLeft(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'pickWalkLeft')
        return res

    @_f.addMelDocs('controller', 'pickWalkRight')
    def getPickWalkRight(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'pickWalkRight')
        return res

    @_f.addMelDocs('controller', 'pickWalkUp')
    def getPickWalkUp(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'pickWalkUp')
        return res

    @_f.addMelDocs('controller', 'unparent')
    def getUnparent(self, **kwargs):
        res = _f.asQuery(self, animation.controller, kwargs, 'unparent')
        return res

    @_f.addMelDocs('controller', 'allControllers')
    def setAllControllers(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'allControllers', val)

    @_f.addMelDocs('controller', 'children')
    def setChildren(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'children', val)

    @_f.addMelDocs('controller', 'group')
    def setGroup(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'group', val)

    @_f.addMelDocs('controller', 'index')
    def setIndex(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'index', val)

    @_f.addMelDocs('controller', 'isController')
    def setIsController(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'isController', val)

    @_f.addMelDocs('controller', 'parent')
    def setParent(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'parent', val)

    @_f.addMelDocs('controller', 'pickWalkDown')
    def setPickWalkDown(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'pickWalkDown', val)

    @_f.addMelDocs('controller', 'pickWalkLeft')
    def setPickWalkLeft(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'pickWalkLeft', val)

    @_f.addMelDocs('controller', 'pickWalkRight')
    def setPickWalkRight(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'pickWalkRight', val)

    @_f.addMelDocs('controller', 'pickWalkUp')
    def setPickWalkUp(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'pickWalkUp', val)

    @_f.addMelDocs('controller', 'unparent')
    def setUnparent(self, val=True, **kwargs):
        return _f.asEdit(self, animation.controller, kwargs, 'unparent', val)


class ShapeEditorManager(DependNode):
    __melnode__ = u'shapeEditorManager'
    __slots__ = ()


class Guide(DependNode):
    __melnode__ = u'guide'
    __slots__ = ()


class SurfaceShader(DependNode):
    __melnode__ = u'surfaceShader'
    __slots__ = ()


class DeleteComponent(DependNode):
    __melnode__ = u'deleteComponent'
    __slots__ = ()


class ObjectFilter(DependNode):
    __melnode__ = u'objectFilter'
    __slots__ = ()


class ObjectRenderFilter(ObjectFilter):
    __melnode__ = u'objectRenderFilter'
    __slots__ = ()


class ObjectNameFilter(ObjectFilter):
    __melnode__ = u'objectNameFilter'
    __slots__ = ()


class ObjectBinFilter(ObjectFilter):
    __melnode__ = u'objectBinFilter'
    __slots__ = ()


class ObjectMultiFilter(ObjectFilter):
    __melnode__ = u'objectMultiFilter'
    __slots__ = ()


class ObjectTypeFilter(ObjectFilter):
    __melnode__ = u'objectTypeFilter'
    __slots__ = ()


class ObjectScriptFilter(ObjectFilter):
    __melnode__ = u'objectScriptFilter'
    __slots__ = ()


class ObjectAttrFilter(ObjectFilter):
    __melnode__ = u'objectAttrFilter'
    __slots__ = ()


class HyperGraphInfo(DependNode):
    __melnode__ = u'hyperGraphInfo'
    __slots__ = ()


class SubdivComponentId(DependNode):
    __melnode__ = u'subdivComponentId'
    __slots__ = ()


class ParticleColorMapper(DependNode):
    __melnode__ = u'particleColorMapper'
    __slots__ = ()


class Audio(DependNode):
    __melnode__ = u'audio'
    __slots__ = ()


class HwReflectionMap(DependNode):
    __melcmd__ = staticmethod(rendering.hwReflectionMap)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'hwReflectionMap'
    __melnode__ = u'hwReflectionMap'
    __slots__ = ()

    @_f.addMelDocs('hwReflectionMap', 'backTextureName')
    def getBackTextureName(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'backTextureName')
        return res

    @_f.addMelDocs('hwReflectionMap', 'bottomTextureName')
    def getBottomTextureName(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'bottomTextureName')
        return res

    @_f.addMelDocs('hwReflectionMap', 'cubeMap')
    def getCubeMap(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'cubeMap')
        return res

    @_f.addMelDocs('hwReflectionMap', 'decalMode')
    def getDecalMode(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'decalMode')
        return res

    @_f.addMelDocs('hwReflectionMap', 'enable')
    def getEnable(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'enable')
        return res

    @_f.addMelDocs('hwReflectionMap', 'frontTextureName')
    def getFrontTextureName(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'frontTextureName')
        return res

    @_f.addMelDocs('hwReflectionMap', 'leftTextureName')
    def getLeftTextureName(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'leftTextureName')
        return res

    @_f.addMelDocs('hwReflectionMap', 'rightTextureName')
    def getRightTextureName(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'rightTextureName')
        return res

    @_f.addMelDocs('hwReflectionMap', 'sphereMapTextureName')
    def getSphereMapTextureName(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'sphereMapTextureName')
        return res

    @_f.addMelDocs('hwReflectionMap', 'topTextureName')
    def getTopTextureName(self, **kwargs):
        res = _f.asQuery(self, rendering.hwReflectionMap, kwargs, 'topTextureName')
        return res


class NodeGraphEditorInfo(DependNode):
    __melnode__ = u'nodeGraphEditorInfo'
    __slots__ = ()


class ColorManagementGlobals(DependNode):
    __melnode__ = u'colorManagementGlobals'
    __slots__ = ()


class Sampler(DependNode):
    __melnode__ = u'sampler'
    __slots__ = ()


class PointMatrixMult(DependNode):
    __melnode__ = u'pointMatrixMult'
    __slots__ = ()


class GroupParts(DependNode):
    __melcmd__ = staticmethod(other.groupParts)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'groupParts'
    __melnode__ = u'groupParts'
    __slots__ = ()


class TimeFunction(DependNode):
    __melnode__ = u'timeFunction'
    __slots__ = ()


class SequenceManager(DependNode):
    __melcmd__ = staticmethod(animation.sequenceManager)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'sequenceManager'
    __melnode__ = u'sequenceManager'
    __slots__ = ()

    @_f.addMelDocs('sequenceManager', 'currentShot')
    def getCurrentShot(self, **kwargs):
        res = _f.asQuery(self, animation.sequenceManager, kwargs, 'currentShot')
        return res

    @_f.addMelDocs('sequenceManager', 'currentTime')
    def getCurrentTime(self, **kwargs):
        res = _f.asQuery(self, animation.sequenceManager, kwargs, 'currentTime')
        return res

    @_f.addMelDocs('sequenceManager', 'modelPanel')
    def getModelPanel(self, **kwargs):
        res = _f.asQuery(self, animation.sequenceManager, kwargs, 'modelPanel')
        return res

    @_f.addMelDocs('sequenceManager', 'node')
    def getNode(self, **kwargs):
        res = _f.asQuery(self, animation.sequenceManager, kwargs, 'node')
        return res

    @_f.addMelDocs('sequenceManager', 'writableSequencer')
    def getWritableSequencer(self, **kwargs):
        res = _f.asQuery(self, animation.sequenceManager, kwargs, 'writableSequencer')
        return res


class IkSolver(DependNode):
    __apicls__ = _api.MFnIkSolver
    __melcmd__ = staticmethod(animation.ikSolver)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'ikSolver'
    __melnode__ = u'ikSolver'
    __slots__ = ()

    @_f.addMelDocs('ikSolver', 'epsilon')
    def getEpsilon(self, **kwargs):
        res = _f.asQuery(self, animation.ikSolver, kwargs, 'epsilon')
        return res

    @_f.addApiDocs(_api.MFnIkSolver, 'maxIterations')
    def getMaxIterations(self):
        # type: () -> int
        res = _f.getProxyResult(self, _api.MFnIkSolver, 'maxIterations')
        return _f.ApiArgUtil._castResult(self, res, 'int', None)

    @_f.addMelDocs('ikSolver', 'solverType')
    def getSolverType(self, **kwargs):
        res = _f.asQuery(self, animation.ikSolver, kwargs, 'solverType')
        return res

    @_f.addApiDocs(_api.MFnIkSolver, 'tolerance')
    def getTolerance(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnIkSolver, 'tolerance')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addMelDocs('ikSolver', 'epsilon')
    def setEpsilon(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSolver, kwargs, 'epsilon', val)

    @_f.addApiDocs(_api.MFnIkSolver, 'setMaxIterations')
    def setMaxIterations(self, maxIters):
        # type: (int) -> None
        do, final_do, outTypes = _f.processApiArgs([maxIters], [('maxIters', 'uint', 'in', None)], self.getMaxIterations, self.setMaxIterations, [])
        res = _f.getProxyResult(self, _api.MFnIkSolver, 'setMaxIterations', final_do)
        return res

    @_f.addMelDocs('ikSolver', 'solverType')
    def setSolverType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.ikSolver, kwargs, 'solverType', val)

    @_f.addApiDocs(_api.MFnIkSolver, 'setTolerance')
    def setTolerance(self, tolerance):
        # type: (float) -> None
        do, final_do, outTypes = _f.processApiArgs([tolerance], [('tolerance', 'double', 'in', None)], self.getTolerance, self.setTolerance, [])
        res = _f.getProxyResult(self, _api.MFnIkSolver, 'setTolerance', final_do)
        return res


class THikSolverNode(IkSolver):
    __melnode__ = u'THikSolverNode'
    __slots__ = ()


class IkSCsolver(IkSolver):
    __melnode__ = u'ikSCsolver'
    __slots__ = ()


class IkRPsolver(IkSCsolver):
    __melnode__ = u'ikRPsolver'
    __slots__ = ()


class IkMCsolver(IkSolver):
    __melnode__ = u'ikMCsolver'
    __slots__ = ()


class HikSolver(IkSolver):
    __melnode__ = u'hikSolver'
    __slots__ = ()


class IkSplineSolver(IkSolver):
    __melnode__ = u'ikSplineSolver'
    __slots__ = ()


class IkPASolver(IkSolver):
    __melnode__ = u'ikPASolver'
    __slots__ = ()


class DefaultLightList(DependNode):
    __melnode__ = u'defaultLightList'
    __slots__ = ()


class AnimClip(DependNode):
    __apicls__ = _api.MFnClip
    __melnode__ = u'animClip'
    __slots__ = ()

    @_f.addApiDocs(_api.MFnClip, 'getAbsoluteChannelSettings')
    def getAbsoluteChannelSettings(self):
        # type: () -> List[int]
        do, final_do, outTypes = _f.getDoArgs([], [('absoluteChannels', 'MIntArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnClip, 'getAbsoluteChannelSettings', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnClip, 'getEnabled')
    def getEnabled(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnClip, 'getEnabled')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnClip, 'getMemberAnimCurves')
    def getMemberAnimCurves(self):
        # type: () -> Tuple[List[general.PyNode], List[general.PyNode]]
        do, final_do, outTypes = _f.getDoArgs([], [('curves', 'MObjectArray', 'out', None), ('associatedAttrs', 'MPlugArray', 'out', None)])
        res = _f.getProxyResult(self, _api.MFnClip, 'getMemberAnimCurves', final_do)
        return _f.processApiResult(res, outTypes, do)

    @_f.addApiDocs(_api.MFnClip, 'getPostCycle')
    def getPostCycle(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnClip, 'getPostCycle')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnClip, 'getPreCycle')
    def getPreCycle(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnClip, 'getPreCycle')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnClip, 'getScale')
    def getScale(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnClip, 'getScale')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnClip, 'getSourceDuration')
    def getSourceDuration(self):
        # type: () -> Time
        res = _f.getProxyResult(self, _api.MFnClip, 'getSourceDuration')
        return _f.ApiArgUtil._castResult(self, res, 'MTime', None)

    @_f.addApiDocs(_api.MFnClip, 'getSourceStart')
    def getSourceStart(self):
        # type: () -> Time
        res = _f.getProxyResult(self, _api.MFnClip, 'getSourceStart')
        return _f.ApiArgUtil._castResult(self, res, 'MTime', None)

    @_f.addApiDocs(_api.MFnClip, 'getStartFrame')
    def getStartFrame(self):
        # type: () -> Time
        res = _f.getProxyResult(self, _api.MFnClip, 'getStartFrame')
        return _f.ApiArgUtil._castResult(self, res, 'MTime', None)

    @_f.addApiDocs(_api.MFnClip, 'getWeight')
    def getWeight(self):
        # type: () -> float
        res = _f.getProxyResult(self, _api.MFnClip, 'getWeight')
        return _f.ApiArgUtil._castResult(self, res, 'double', None)

    @_f.addApiDocs(_api.MFnClip, 'isInstancedClip')
    def isInstancedClip(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnClip, 'isInstancedClip')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnClip, 'isPose')
    def isPose(self):
        # type: () -> bool
        res = _f.getProxyResult(self, _api.MFnClip, 'isPose')
        return _f.ApiArgUtil._castResult(self, res, 'bool', None)

    @_f.addApiDocs(_api.MFnClip, 'setAbsoluteChannelSettings')
    def setAbsoluteChannelSettings(self, absoluteChannels, mod=None):
        # type: (List[int], datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([absoluteChannels, mod], [('absoluteChannels', 'MIntArray', 'in', None), ('mod', 'MDGModifier', 'in', None)], self.getAbsoluteChannelSettings, self.setAbsoluteChannelSettings, [])
        res = _f.getProxyResult(self, _api.MFnClip, 'setAbsoluteChannelSettings', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'setEnabled')
    def setEnabled(self, val, mod=None):
        # type: (bool, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([val, mod], [('val', 'bool', 'in', None), ('mod', 'MDGModifier', 'in', None)], self.getEnabled, self.setEnabled, [])
        res = _f.getProxyResult(self, _api.MFnClip, 'setEnabled', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'setPoseClip')
    def setPoseClip(self, state, mod=None):
        # type: (bool, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.getDoArgs([state, mod], [('state', 'bool', 'in', None), ('mod', 'MDGModifier', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnClip, 'setPoseClip', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'setPostCycle')
    def setPostCycle(self, cycle, mod=None):
        # type: (float, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([cycle, mod], [('cycle', 'double', 'in', None), ('mod', 'MDGModifier', 'in', None)], self.getPostCycle, self.setPostCycle, [])
        res = _f.getProxyResult(self, _api.MFnClip, 'setPostCycle', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'setPreCycle')
    def setPreCycle(self, cycle, mod=None):
        # type: (float, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([cycle, mod], [('cycle', 'double', 'in', None), ('mod', 'MDGModifier', 'in', None)], self.getPreCycle, self.setPreCycle, [])
        res = _f.getProxyResult(self, _api.MFnClip, 'setPreCycle', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'setScale')
    def setScale(self, scale, mod=None):
        # type: (float, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([scale, mod], [('scale', 'double', 'in', None), ('mod', 'MDGModifier', 'in', None)], self.getScale, self.setScale, [])
        res = _f.getProxyResult(self, _api.MFnClip, 'setScale', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'setSourceData')
    def setSourceData(self, start, duration, mod=None):
        # type: (Time, Time, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.getDoArgs([start, duration, mod], [('start', 'MTime', 'in', None), ('duration', 'MTime', 'in', None), ('mod', 'MDGModifier', 'in', None)])
        res = _f.getProxyResult(self, _api.MFnClip, 'setSourceData', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'setStartFrame')
    def setStartFrame(self, start, mod=None):
        # type: (Time, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([start, mod], [('start', 'MTime', 'in', None), ('mod', 'MDGModifier', 'in', None)], self.getStartFrame, self.setStartFrame, [])
        res = _f.getProxyResult(self, _api.MFnClip, 'setStartFrame', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'setWeight')
    def setWeight(self, wt, mod=None):
        # type: (float, datatypes.DGModifier) -> None
        do, final_do, outTypes = _f.processApiArgs([wt, mod], [('wt', 'double', 'in', None), ('mod', 'MDGModifier', 'in', None)], self.getWeight, self.setWeight, [])
        res = _f.getProxyResult(self, _api.MFnClip, 'setWeight', final_do)
        return res

    @_f.addApiDocs(_api.MFnClip, 'sourceClip')
    def sourceClip(self):
        # type: () -> general.PyNode
        res = _f.getProxyResult(self, _api.MFnClip, 'sourceClip')
        return _f.ApiArgUtil._castResult(self, res, 'MObject', None)


class AnimBlendNodeBase(DependNode):
    __melnode__ = u'animBlendNodeBase'
    __slots__ = ()


class AnimBlendNodeAdditiveDL(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveDL'
    __slots__ = ()


class AnimBlendNodeAdditiveDA(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveDA'
    __slots__ = ()


class AnimBlendNodeBoolean(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeBoolean'
    __slots__ = ()


class AnimBlendNodeEnum(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeEnum'
    __slots__ = ()


class AnimBlendNodeAdditiveScale(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveScale'
    __slots__ = ()


class AnimBlendNodeAdditiveI16(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveI16'
    __slots__ = ()


class AnimBlendNodeAdditiveRotation(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveRotation'
    __slots__ = ()


class AnimBlendNodeTime(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeTime'
    __slots__ = ()


class AnimBlendNodeAdditiveFA(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveFA'
    __slots__ = ()


class AnimBlendNodeAdditiveFL(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveFL'
    __slots__ = ()


class AnimBlendNodeAdditiveI32(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveI32'
    __slots__ = ()


class AnimBlendNodeAdditiveF(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditiveF'
    __slots__ = ()


class AnimBlendNodeAdditive(AnimBlendNodeBase):
    __melnode__ = u'animBlendNodeAdditive'
    __slots__ = ()


class HwRenderGlobals(DependNode):
    __melnode__ = u'hwRenderGlobals'
    __slots__ = ()


class CameraView(DependNode):
    __melcmd__ = staticmethod(rendering.cameraView)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'cameraView'
    __melnode__ = u'cameraView'
    __slots__ = ()

    @_f.addMelDocs('cameraView', 'addBookmark')
    def addBookmark(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraView, kwargs, 'addBookmark', val)

    @_f.addMelDocs('cameraView', 'animate')
    def animate(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraView, kwargs, 'animate', val)

    @_f.addMelDocs('cameraView', 'camera')
    def camera(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraView, kwargs, 'camera', val)

    @_f.addMelDocs('cameraView', 'removeBookmark')
    def removeBookmark(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraView, kwargs, 'removeBookmark', val)

    @_f.addMelDocs('cameraView', 'setCamera')
    def setCamera(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraView, kwargs, 'setCamera', val)

    @_f.addMelDocs('cameraView', 'setView')
    def setView(self, val=True, **kwargs):
        return _f.asEdit(self, rendering.cameraView, kwargs, 'setView', val)


class MaterialInfo(DependNode):
    __melnode__ = u'materialInfo'
    __slots__ = ()


class DynGlobals(DependNode):
    __melcmd__ = staticmethod(effects.dynGlobals)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'dynGlobals'
    __melnode__ = u'dynGlobals'
    __slots__ = ()

    @_f.addMelDocs('dynGlobals', 'active')
    def getActive(self, **kwargs):
        res = _f.asQuery(self, effects.dynGlobals, kwargs, 'active')
        return res

    @_f.addMelDocs('dynGlobals', 'listAll')
    def getListAll(self, **kwargs):
        res = _f.asQuery(self, effects.dynGlobals, kwargs, 'listAll')
        return res

    @_f.addMelDocs('dynGlobals', 'overSampling')
    def getOverSampling(self, **kwargs):
        res = _f.asQuery(self, effects.dynGlobals, kwargs, 'overSampling')
        return res

    @_f.addMelDocs('dynGlobals', 'overSampling')
    def setOverSampling(self, val=True, **kwargs):
        return _f.asEdit(self, effects.dynGlobals, kwargs, 'overSampling', val)


class PostProcessList(DependNode):
    __melnode__ = u'postProcessList'
    __slots__ = ()


class OpticalFX(DependNode):
    __melnode__ = u'opticalFX'
    __slots__ = ()


class ParticleAgeMapper(DependNode):
    __melnode__ = u'particleAgeMapper'
    __slots__ = ()


class Brush(DependNode):
    __melnode__ = u'brush'
    __slots__ = ()


class GlobalCacheControl(DependNode):
    __melnode__ = u'globalCacheControl'
    __slots__ = ()


class SimpleTestNode(DependNode):
    __melnode__ = u'simpleTestNode'
    __slots__ = ()


class AddMatrix(DependNode):
    __melnode__ = u'addMatrix'
    __slots__ = ()


class RemapValue(DependNode):
    __melnode__ = u'remapValue'
    __slots__ = ()


class EditsManager(DependNode):
    __melnode__ = u'editsManager'
    __slots__ = ()


class CombinationShape(DependNode):
    __melcmd__ = staticmethod(animation.combinationShape)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'combinationShape'
    __melnode__ = u'combinationShape'
    __slots__ = ()

    @_f.addMelDocs('combinationShape', 'allDrivers')
    def getAllDrivers(self, **kwargs):
        res = _f.asQuery(self, animation.combinationShape, kwargs, 'allDrivers')
        return res

    @_f.addMelDocs('combinationShape', 'combineMethod')
    def getCombineMethod(self, **kwargs):
        res = _f.asQuery(self, animation.combinationShape, kwargs, 'combineMethod')
        return res

    @_f.addMelDocs('combinationShape', 'exist')
    def getExist(self, **kwargs):
        res = _f.asQuery(self, animation.combinationShape, kwargs, 'exist')
        return res

    @_f.addMelDocs('combinationShape', 'combineMethod')
    def setCombineMethod(self, val=True, **kwargs):
        return _f.asEdit(self, animation.combinationShape, kwargs, 'combineMethod', val)


class DefaultRenderingList(DependNode):
    __melnode__ = u'defaultRenderingList'
    __slots__ = ()


class ParticleIncandMapper(DependNode):
    __melnode__ = u'particleIncandMapper'
    __slots__ = ()


class ArrayMapper(DependNode):
    __melcmd__ = staticmethod(effects.arrayMapper)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'arrayMapper'
    __melnode__ = u'arrayMapper'
    __slots__ = ()


class THarrayMapper(ArrayMapper):
    __melnode__ = u'THarrayMapper'
    __slots__ = ()


class RenderLayerManager(DependNode):
    __melnode__ = u'renderLayerManager'
    __slots__ = ()


class LightList(DependNode):
    __melcmd__ = staticmethod(rendering.lightList)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'lightList'
    __melnode__ = u'lightList'
    __slots__ = ()


class BlindDataTemplate(DependNode):
    __melnode__ = u'blindDataTemplate'
    __slots__ = ()


class SubdHierBlind(BlindDataTemplate):
    __melnode__ = u'subdHierBlind'
    __slots__ = ()


class DagPose(DependNode):
    __melcmd__ = staticmethod(animation.dagPose)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'dagPose'
    __melnode__ = u'dagPose'
    __slots__ = ()

    @_f.addMelDocs('dagPose', 'atPose')
    def getAtPose(self, **kwargs):
        res = _f.asQuery(self, animation.dagPose, kwargs, 'atPose')
        return res

    @_f.addMelDocs('dagPose', 'bindPose')
    def getBindPose(self, **kwargs):
        res = _f.asQuery(self, animation.dagPose, kwargs, 'bindPose')
        return res

    @_f.addMelDocs('dagPose', 'members')
    def getMembers(self, **kwargs):
        res = _f.asQuery(self, animation.dagPose, kwargs, 'members')
        return res

    @_f.addMelDocs('dagPose', 'selection')
    def getSelection(self, **kwargs):
        res = _f.asQuery(self, animation.dagPose, kwargs, 'selection')
        return res


class Record(DependNode):
    __melnode__ = u'record'
    __slots__ = ()


class TimeWarp(DependNode):
    __melcmd__ = staticmethod(animation.timeWarp)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'timeWarp'
    __melnode__ = u'timeWarp'
    __slots__ = ()

    @_f.addMelDocs('timeWarp', 'deleteFrame')
    def deleteFrame(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeWarp, kwargs, 'deleteFrame', val)

    @_f.addMelDocs('timeWarp', 'frame')
    def getFrame(self, **kwargs):
        res = _f.asQuery(self, animation.timeWarp, kwargs, 'frame')
        return res

    @_f.addMelDocs('timeWarp', 'g')
    def getG(self, **kwargs):
        res = _f.asQuery(self, animation.timeWarp, kwargs, 'g')
        return res

    @_f.addMelDocs('timeWarp', 'interpType')
    def getInterpType(self, **kwargs):
        res = _f.asQuery(self, animation.timeWarp, kwargs, 'interpType')
        return res

    @_f.addMelDocs('timeWarp', 'moveFrame')
    def getMoveFrame(self, **kwargs):
        res = _f.asQuery(self, animation.timeWarp, kwargs, 'moveFrame')
        return res

    @_f.addMelDocs('timeWarp', 'frame')
    def setFrame(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeWarp, kwargs, 'frame', val)

    @_f.addMelDocs('timeWarp', 'g')
    def setG(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeWarp, kwargs, 'g', val)

    @_f.addMelDocs('timeWarp', 'interpType')
    def setInterpType(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeWarp, kwargs, 'interpType', val)

    @_f.addMelDocs('timeWarp', 'moveFrame')
    def setMoveFrame(self, val=True, **kwargs):
        return _f.asEdit(self, animation.timeWarp, kwargs, 'moveFrame', val)


class Dof(DependNode):
    __melnode__ = u'dof'
    __slots__ = ()


class RigidSolver(DependNode):
    __melcmd__ = staticmethod(effects.rigidSolver)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'rigidSolver'
    __melnode__ = u'rigidSolver'
    __slots__ = ()

    @_f.addMelDocs('rigidSolver', 'autoTolerances')
    def getAutoTolerances(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'autoTolerances')
        return res

    @_f.addMelDocs('rigidSolver', 'bounciness')
    def getBounciness(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'bounciness')
        return res

    @_f.addMelDocs('rigidSolver', 'cacheData')
    def getCacheData(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'cacheData')
        return res

    @_f.addMelDocs('rigidSolver', 'collide')
    def getCollide(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'collide')
        return res

    @_f.addMelDocs('rigidSolver', 'collisionTolerance')
    def getCollisionTolerance(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'collisionTolerance')
        return res

    @_f.addMelDocs('rigidSolver', 'contactData')
    def getContactData(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'contactData')
        return res

    @_f.addMelDocs('rigidSolver', 'deleteCache')
    def getDeleteCache(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'deleteCache')
        return res

    @_f.addMelDocs('rigidSolver', 'displayCenterOfMass')
    def getDisplayCenterOfMass(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'displayCenterOfMass')
        return res

    @_f.addMelDocs('rigidSolver', 'displayConstraint')
    def getDisplayConstraint(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'displayConstraint')
        return res

    @_f.addMelDocs('rigidSolver', 'displayVelocity')
    def getDisplayVelocity(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'displayVelocity')
        return res

    @_f.addMelDocs('rigidSolver', 'dynamics')
    def getDynamics(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'dynamics')
        return res

    @_f.addMelDocs('rigidSolver', 'friction')
    def getFriction(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'friction')
        return res

    @_f.addMelDocs('rigidSolver', 'interpenetrate')
    def getInterpenetrate(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'interpenetrate')
        return res

    @_f.addMelDocs('rigidSolver', 'rigidBodies')
    def getRigidBodies(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'rigidBodies')
        return res

    @_f.addMelDocs('rigidSolver', 'rigidBodyCount')
    def getRigidBodyCount(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'rigidBodyCount')
        return res

    @_f.addMelDocs('rigidSolver', 'showCollision')
    def getShowCollision(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'showCollision')
        return res

    @_f.addMelDocs('rigidSolver', 'showInterpenetration')
    def getShowInterpenetration(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'showInterpenetration')
        return res

    @_f.addMelDocs('rigidSolver', 'solverMethod')
    def getSolverMethod(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'solverMethod')
        return res

    @_f.addMelDocs('rigidSolver', 'startTime')
    def getStartTime(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'startTime')
        return res

    @_f.addMelDocs('rigidSolver', 'state')
    def getState(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'state')
        return res

    @_f.addMelDocs('rigidSolver', 'statistics')
    def getStatistics(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'statistics')
        return res

    @_f.addMelDocs('rigidSolver', 'stepSize')
    def getStepSize(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'stepSize')
        return res

    @_f.addMelDocs('rigidSolver', 'velocityVectorScale')
    def getVelocityVectorScale(self, **kwargs):
        res = _f.asQuery(self, effects.rigidSolver, kwargs, 'velocityVectorScale')
        return res

    @_f.addMelDocs('rigidSolver', 'interpenetrationCheck')
    def interpenetrationCheck(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'interpenetrationCheck', val)

    @_f.addMelDocs('rigidSolver', 'autoTolerances')
    def setAutoTolerances(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'autoTolerances', val)

    @_f.addMelDocs('rigidSolver', 'bounciness')
    def setBounciness(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'bounciness', val)

    @_f.addMelDocs('rigidSolver', 'cacheData')
    def setCacheData(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'cacheData', val)

    @_f.addMelDocs('rigidSolver', 'collide')
    def setCollide(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'collide', val)

    @_f.addMelDocs('rigidSolver', 'collisionTolerance')
    def setCollisionTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'collisionTolerance', val)

    @_f.addMelDocs('rigidSolver', 'contactData')
    def setContactData(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'contactData', val)

    @_f.addMelDocs('rigidSolver', 'deleteCache')
    def setDeleteCache(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'deleteCache', val)

    @_f.addMelDocs('rigidSolver', 'displayCenterOfMass')
    def setDisplayCenterOfMass(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'displayCenterOfMass', val)

    @_f.addMelDocs('rigidSolver', 'displayConstraint')
    def setDisplayConstraint(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'displayConstraint', val)

    @_f.addMelDocs('rigidSolver', 'displayVelocity')
    def setDisplayVelocity(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'displayVelocity', val)

    @_f.addMelDocs('rigidSolver', 'dynamics')
    def setDynamics(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'dynamics', val)

    @_f.addMelDocs('rigidSolver', 'friction')
    def setFriction(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'friction', val)

    @_f.addMelDocs('rigidSolver', 'interpenetrate')
    def setInterpenetrate(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'interpenetrate', val)

    @_f.addMelDocs('rigidSolver', 'showCollision')
    def setShowCollision(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'showCollision', val)

    @_f.addMelDocs('rigidSolver', 'showInterpenetration')
    def setShowInterpenetration(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'showInterpenetration', val)

    @_f.addMelDocs('rigidSolver', 'solverMethod')
    def setSolverMethod(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'solverMethod', val)

    @_f.addMelDocs('rigidSolver', 'startTime')
    def setStartTime(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'startTime', val)

    @_f.addMelDocs('rigidSolver', 'state')
    def setState(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'state', val)

    @_f.addMelDocs('rigidSolver', 'statistics')
    def setStatistics(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'statistics', val)

    @_f.addMelDocs('rigidSolver', 'stepSize')
    def setStepSize(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'stepSize', val)

    @_f.addMelDocs('rigidSolver', 'velocityVectorScale')
    def setVelocityVectorScale(self, val=True, **kwargs):
        return _f.asEdit(self, effects.rigidSolver, kwargs, 'velocityVectorScale', val)


class DynController(DependNode):
    __melnode__ = u'dynController'
    __slots__ = ()


class HyperView(DependNode):
    __melnode__ = u'hyperView'
    __slots__ = ()


class AnimCurveTL(AnimCurve):
    __melnode__ = u'animCurveTL'
    __slots__ = ()


class AnimCurveTA(AnimCurve):
    __melnode__ = u'animCurveTA'
    __slots__ = ()


class AnimCurveTU(AnimCurve):
    __melnode__ = u'animCurveTU'
    __slots__ = ()


class AnimCurveTT(AnimCurve):
    __melnode__ = u'animCurveTT'
    __slots__ = ()


class AnimCurveUA(AnimCurve):
    __melnode__ = u'animCurveUA'
    __slots__ = ()


class AnimCurveUT(AnimCurve):
    __melnode__ = u'animCurveUT'
    __slots__ = ()


class AnimCurveUU(AnimCurve):
    __melnode__ = u'animCurveUU'
    __slots__ = ()


class ResultCurve(AnimCurve):
    __melnode__ = u'resultCurve'
    __slots__ = ()


class ResultCurveTimeToTime(ResultCurve):
    __melnode__ = u'resultCurveTimeToTime'
    __slots__ = ()


class ResultCurveTimeToUnitless(ResultCurve):
    __melnode__ = u'resultCurveTimeToUnitless'
    __slots__ = ()


class ResultCurveTimeToLinear(ResultCurve):
    __melnode__ = u'resultCurveTimeToLinear'
    __slots__ = ()


class ResultCurveTimeToAngular(ResultCurve):
    __melnode__ = u'resultCurveTimeToAngular'
    __slots__ = ()


class AnimCurveUL(AnimCurve):
    __melnode__ = u'animCurveUL'
    __slots__ = ()


class AbstractBaseCreate(DependNode):
    __melnode__ = u'abstractBaseCreate'
    __slots__ = ()


class FfFilletSrf(AbstractBaseCreate):
    __melnode__ = u'ffFilletSrf'
    __slots__ = ()


class DetachCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.detachCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'detachCurve'
    __melnode__ = u'detachCurve'
    __slots__ = ()

    @_f.addMelDocs('detachCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.detachCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('detachCurve', 'keep')
    def getKeep(self, **kwargs):
        res = _f.asQuery(self, modeling.detachCurve, kwargs, 'keep')
        return res

    @_f.addMelDocs('detachCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.detachCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('detachCurve', 'parameter')
    def getParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.detachCurve, kwargs, 'parameter')
        return res

    @_f.addMelDocs('detachCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachCurve, kwargs, 'caching', val)

    @_f.addMelDocs('detachCurve', 'keep')
    def setKeep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachCurve, kwargs, 'keep', val)

    @_f.addMelDocs('detachCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('detachCurve', 'parameter')
    def setParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachCurve, kwargs, 'parameter', val)


class SubSurface(AbstractBaseCreate):
    __melnode__ = u'subSurface'
    __slots__ = ()


class StyleCurve(AbstractBaseCreate):
    __melnode__ = u'styleCurve'
    __slots__ = ()


class CurveRange(AbstractBaseCreate):
    __melnode__ = u'curveRange'
    __slots__ = ()


class CurveFromSubdiv(CurveRange):
    __melnode__ = u'curveFromSubdiv'
    __slots__ = ()


class CurveFromSubdivFace(CurveFromSubdiv):
    __melnode__ = u'curveFromSubdivFace'
    __slots__ = ()


class CurveFromSubdivEdge(CurveFromSubdiv):
    __melnode__ = u'curveFromSubdivEdge'
    __slots__ = ()


class CurveFromSurface(CurveRange):
    __melnode__ = u'curveFromSurface'
    __slots__ = ()


class CurveFromSurfaceIso(CurveFromSurface):
    __melnode__ = u'curveFromSurfaceIso'
    __slots__ = ()


class CurveFromSurfaceCoS(CurveFromSurface):
    __melnode__ = u'curveFromSurfaceCoS'
    __slots__ = ()


class CurveFromSurfaceBnd(CurveFromSurface):
    __melnode__ = u'curveFromSurfaceBnd'
    __slots__ = ()


class SubCurve(CurveRange):
    __melnode__ = u'subCurve'
    __slots__ = ()


class GlobalStitch(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.globalStitch)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'globalStitch'
    __melnode__ = u'globalStitch'
    __slots__ = ()

    @_f.addMelDocs('globalStitch', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'caching')
        return res

    @_f.addMelDocs('globalStitch', 'lockSurface')
    def getLockSurface(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'lockSurface')
        return res

    @_f.addMelDocs('globalStitch', 'maxSeparation')
    def getMaxSeparation(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'maxSeparation')
        return res

    @_f.addMelDocs('globalStitch', 'modificationResistance')
    def getModificationResistance(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'modificationResistance')
        return res

    @_f.addMelDocs('globalStitch', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('globalStitch', 'sampling')
    def getSampling(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'sampling')
        return res

    @_f.addMelDocs('globalStitch', 'stitchCorners')
    def getStitchCorners(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'stitchCorners')
        return res

    @_f.addMelDocs('globalStitch', 'stitchEdges')
    def getStitchEdges(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'stitchEdges')
        return res

    @_f.addMelDocs('globalStitch', 'stitchPartialEdges')
    def getStitchPartialEdges(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'stitchPartialEdges')
        return res

    @_f.addMelDocs('globalStitch', 'stitchSmoothness')
    def getStitchSmoothness(self, **kwargs):
        res = _f.asQuery(self, modeling.globalStitch, kwargs, 'stitchSmoothness')
        return res

    @_f.addMelDocs('globalStitch', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'caching', val)

    @_f.addMelDocs('globalStitch', 'lockSurface')
    def setLockSurface(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'lockSurface', val)

    @_f.addMelDocs('globalStitch', 'maxSeparation')
    def setMaxSeparation(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'maxSeparation', val)

    @_f.addMelDocs('globalStitch', 'modificationResistance')
    def setModificationResistance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'modificationResistance', val)

    @_f.addMelDocs('globalStitch', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'nodeState', val)

    @_f.addMelDocs('globalStitch', 'sampling')
    def setSampling(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'sampling', val)

    @_f.addMelDocs('globalStitch', 'stitchCorners')
    def setStitchCorners(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'stitchCorners', val)

    @_f.addMelDocs('globalStitch', 'stitchEdges')
    def setStitchEdges(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'stitchEdges', val)

    @_f.addMelDocs('globalStitch', 'stitchPartialEdges')
    def setStitchPartialEdges(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'stitchPartialEdges', val)

    @_f.addMelDocs('globalStitch', 'stitchSmoothness')
    def setStitchSmoothness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.globalStitch, kwargs, 'stitchSmoothness', val)


class BevelPlus(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.bevelPlus)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'bevelPlus'
    __melnode__ = u'bevelPlus'
    __slots__ = ()

    @_f.addMelDocs('bevelPlus', 'bevelInside')
    def getBevelInside(self, **kwargs):
        res = _f.asQuery(self, modeling.bevelPlus, kwargs, 'bevelInside')
        return res

    @_f.addMelDocs('bevelPlus', 'capSides')
    def getCapSides(self, **kwargs):
        res = _f.asQuery(self, modeling.bevelPlus, kwargs, 'capSides')
        return res

    @_f.addMelDocs('bevelPlus', 'innerStyle')
    def getInnerStyle(self, **kwargs):
        res = _f.asQuery(self, modeling.bevelPlus, kwargs, 'innerStyle')
        return res

    @_f.addMelDocs('bevelPlus', 'joinSurfaces')
    def getJoinSurfaces(self, **kwargs):
        res = _f.asQuery(self, modeling.bevelPlus, kwargs, 'joinSurfaces')
        return res

    @_f.addMelDocs('bevelPlus', 'normalsOutwards')
    def getNormalsOutwards(self, **kwargs):
        res = _f.asQuery(self, modeling.bevelPlus, kwargs, 'normalsOutwards')
        return res

    @_f.addMelDocs('bevelPlus', 'numberOfSides')
    def getNumberOfSides(self, **kwargs):
        res = _f.asQuery(self, modeling.bevelPlus, kwargs, 'numberOfSides')
        return res

    @_f.addMelDocs('bevelPlus', 'outerStyle')
    def getOuterStyle(self, **kwargs):
        res = _f.asQuery(self, modeling.bevelPlus, kwargs, 'outerStyle')
        return res

    @_f.addMelDocs('bevelPlus', 'bevelInside')
    def setBevelInside(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevelPlus, kwargs, 'bevelInside', val)

    @_f.addMelDocs('bevelPlus', 'innerStyle')
    def setInnerStyle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevelPlus, kwargs, 'innerStyle', val)

    @_f.addMelDocs('bevelPlus', 'joinSurfaces')
    def setJoinSurfaces(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevelPlus, kwargs, 'joinSurfaces', val)

    @_f.addMelDocs('bevelPlus', 'normalsOutwards')
    def setNormalsOutwards(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevelPlus, kwargs, 'normalsOutwards', val)

    @_f.addMelDocs('bevelPlus', 'numberOfSides')
    def setNumberOfSides(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevelPlus, kwargs, 'numberOfSides', val)

    @_f.addMelDocs('bevelPlus', 'outerStyle')
    def setOuterStyle(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevelPlus, kwargs, 'outerStyle', val)


class FfBlendSrfObsolete(AbstractBaseCreate):
    __melnode__ = u'ffBlendSrfObsolete'
    __slots__ = ()


class Boolean(AbstractBaseCreate):
    __melnode__ = u'boolean'
    __slots__ = ()


class CurveIntersect(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.curveIntersect)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'curveIntersect'
    __melnode__ = u'curveIntersect'
    __slots__ = ()

    @_f.addMelDocs('curveIntersect', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.curveIntersect, kwargs, 'caching')
        return res

    @_f.addMelDocs('curveIntersect', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.curveIntersect, kwargs, 'direction')
        return res

    @_f.addMelDocs('curveIntersect', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, modeling.curveIntersect, kwargs, 'directionX')
        return res

    @_f.addMelDocs('curveIntersect', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, modeling.curveIntersect, kwargs, 'directionY')
        return res

    @_f.addMelDocs('curveIntersect', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, modeling.curveIntersect, kwargs, 'directionZ')
        return res

    @_f.addMelDocs('curveIntersect', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.curveIntersect, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('curveIntersect', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.curveIntersect, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('curveIntersect', 'useDirection')
    def getUseDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.curveIntersect, kwargs, 'useDirection')
        return res

    @_f.addMelDocs('curveIntersect', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.curveIntersect, kwargs, 'caching', val)

    @_f.addMelDocs('curveIntersect', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.curveIntersect, kwargs, 'direction', val)

    @_f.addMelDocs('curveIntersect', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.curveIntersect, kwargs, 'directionX', val)

    @_f.addMelDocs('curveIntersect', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.curveIntersect, kwargs, 'directionY', val)

    @_f.addMelDocs('curveIntersect', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.curveIntersect, kwargs, 'directionZ', val)

    @_f.addMelDocs('curveIntersect', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.curveIntersect, kwargs, 'nodeState', val)

    @_f.addMelDocs('curveIntersect', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.curveIntersect, kwargs, 'tolerance', val)

    @_f.addMelDocs('curveIntersect', 'useDirection')
    def setUseDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.curveIntersect, kwargs, 'useDirection', val)


class ReverseCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.reverseCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'reverseCurve'
    __melnode__ = u'reverseCurve'
    __slots__ = ()

    @_f.addMelDocs('reverseCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.reverseCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('reverseCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.reverseCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('reverseCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.reverseCurve, kwargs, 'caching', val)

    @_f.addMelDocs('reverseCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.reverseCurve, kwargs, 'nodeState', val)


class ArubaTessellate(AbstractBaseCreate):
    __melnode__ = u'arubaTessellate'
    __slots__ = ()


class AttachSurface(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.attachSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'attachSurface'
    __melnode__ = u'attachSurface'
    __slots__ = ()

    @_f.addMelDocs('attachSurface', 'blendBias')
    def getBlendBias(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'blendBias')
        return res

    @_f.addMelDocs('attachSurface', 'blendKnotInsertion')
    def getBlendKnotInsertion(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'blendKnotInsertion')
        return res

    @_f.addMelDocs('attachSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('attachSurface', 'directionU')
    def getDirectionU(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'directionU')
        return res

    @_f.addMelDocs('attachSurface', 'keepMultipleKnots')
    def getKeepMultipleKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'keepMultipleKnots')
        return res

    @_f.addMelDocs('attachSurface', 'method')
    def getMethod(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'method')
        return res

    @_f.addMelDocs('attachSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('attachSurface', 'parameter')
    def getParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'parameter')
        return res

    @_f.addMelDocs('attachSurface', 'reverse1')
    def getReverse1(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'reverse1')
        return res

    @_f.addMelDocs('attachSurface', 'reverse2')
    def getReverse2(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'reverse2')
        return res

    @_f.addMelDocs('attachSurface', 'swap1')
    def getSwap1(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'swap1')
        return res

    @_f.addMelDocs('attachSurface', 'swap2')
    def getSwap2(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'swap2')
        return res

    @_f.addMelDocs('attachSurface', 'twist')
    def getTwist(self, **kwargs):
        res = _f.asQuery(self, modeling.attachSurface, kwargs, 'twist')
        return res

    @_f.addMelDocs('attachSurface', 'blendBias')
    def setBlendBias(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'blendBias', val)

    @_f.addMelDocs('attachSurface', 'blendKnotInsertion')
    def setBlendKnotInsertion(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'blendKnotInsertion', val)

    @_f.addMelDocs('attachSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'caching', val)

    @_f.addMelDocs('attachSurface', 'directionU')
    def setDirectionU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'directionU', val)

    @_f.addMelDocs('attachSurface', 'keepMultipleKnots')
    def setKeepMultipleKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'keepMultipleKnots', val)

    @_f.addMelDocs('attachSurface', 'method')
    def setMethod(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'method', val)

    @_f.addMelDocs('attachSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'nodeState', val)

    @_f.addMelDocs('attachSurface', 'parameter')
    def setParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'parameter', val)

    @_f.addMelDocs('attachSurface', 'reverse1')
    def setReverse1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'reverse1', val)

    @_f.addMelDocs('attachSurface', 'reverse2')
    def setReverse2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'reverse2', val)

    @_f.addMelDocs('attachSurface', 'swap1')
    def setSwap1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'swap1', val)

    @_f.addMelDocs('attachSurface', 'swap2')
    def setSwap2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'swap2', val)

    @_f.addMelDocs('attachSurface', 'twist')
    def setTwist(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachSurface, kwargs, 'twist', val)


class RebuildCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.rebuildCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'rebuildCurve'
    __melnode__ = u'rebuildCurve'
    __slots__ = ()

    @_f.addMelDocs('rebuildCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('rebuildCurve', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'degree')
        return res

    @_f.addMelDocs('rebuildCurve', 'endKnots')
    def getEndKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'endKnots')
        return res

    @_f.addMelDocs('rebuildCurve', 'fitRebuild')
    def getFitRebuild(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'fitRebuild')
        return res

    @_f.addMelDocs('rebuildCurve', 'keepControlPoints')
    def getKeepControlPoints(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'keepControlPoints')
        return res

    @_f.addMelDocs('rebuildCurve', 'keepEndPoints')
    def getKeepEndPoints(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'keepEndPoints')
        return res

    @_f.addMelDocs('rebuildCurve', 'keepRange')
    def getKeepRange(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'keepRange')
        return res

    @_f.addMelDocs('rebuildCurve', 'keepTangents')
    def getKeepTangents(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'keepTangents')
        return res

    @_f.addMelDocs('rebuildCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('rebuildCurve', 'rebuildType')
    def getRebuildType(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'rebuildType')
        return res

    @_f.addMelDocs('rebuildCurve', 'smartSurfaceCurveRebuild')
    def getSmartSurfaceCurveRebuild(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'smartSurfaceCurveRebuild')
        return res

    @_f.addMelDocs('rebuildCurve', 'spans')
    def getSpans(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'spans')
        return res

    @_f.addMelDocs('rebuildCurve', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildCurve, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('rebuildCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'caching', val)

    @_f.addMelDocs('rebuildCurve', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'degree', val)

    @_f.addMelDocs('rebuildCurve', 'endKnots')
    def setEndKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'endKnots', val)

    @_f.addMelDocs('rebuildCurve', 'fitRebuild')
    def setFitRebuild(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'fitRebuild', val)

    @_f.addMelDocs('rebuildCurve', 'keepControlPoints')
    def setKeepControlPoints(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'keepControlPoints', val)

    @_f.addMelDocs('rebuildCurve', 'keepEndPoints')
    def setKeepEndPoints(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'keepEndPoints', val)

    @_f.addMelDocs('rebuildCurve', 'keepRange')
    def setKeepRange(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'keepRange', val)

    @_f.addMelDocs('rebuildCurve', 'keepTangents')
    def setKeepTangents(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'keepTangents', val)

    @_f.addMelDocs('rebuildCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('rebuildCurve', 'rebuildType')
    def setRebuildType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'rebuildType', val)

    @_f.addMelDocs('rebuildCurve', 'smartSurfaceCurveRebuild')
    def setSmartSurfaceCurveRebuild(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'smartSurfaceCurveRebuild', val)

    @_f.addMelDocs('rebuildCurve', 'spans')
    def setSpans(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'spans', val)

    @_f.addMelDocs('rebuildCurve', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildCurve, kwargs, 'tolerance', val)


class ExtendSurface(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.extendSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'extendSurface'
    __melnode__ = u'extendSurface'
    __slots__ = ()

    @_f.addMelDocs('extendSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.extendSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('extendSurface', 'distance')
    def getDistance(self, **kwargs):
        res = _f.asQuery(self, modeling.extendSurface, kwargs, 'distance')
        return res

    @_f.addMelDocs('extendSurface', 'extendDirection')
    def getExtendDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.extendSurface, kwargs, 'extendDirection')
        return res

    @_f.addMelDocs('extendSurface', 'extendMethod')
    def getExtendMethod(self, **kwargs):
        res = _f.asQuery(self, modeling.extendSurface, kwargs, 'extendMethod')
        return res

    @_f.addMelDocs('extendSurface', 'extendSide')
    def getExtendSide(self, **kwargs):
        res = _f.asQuery(self, modeling.extendSurface, kwargs, 'extendSide')
        return res

    @_f.addMelDocs('extendSurface', 'extensionType')
    def getExtensionType(self, **kwargs):
        res = _f.asQuery(self, modeling.extendSurface, kwargs, 'extensionType')
        return res

    @_f.addMelDocs('extendSurface', 'join')
    def getJoin(self, **kwargs):
        res = _f.asQuery(self, modeling.extendSurface, kwargs, 'join')
        return res

    @_f.addMelDocs('extendSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.extendSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('extendSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendSurface, kwargs, 'caching', val)

    @_f.addMelDocs('extendSurface', 'distance')
    def setDistance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendSurface, kwargs, 'distance', val)

    @_f.addMelDocs('extendSurface', 'extendDirection')
    def setExtendDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendSurface, kwargs, 'extendDirection', val)

    @_f.addMelDocs('extendSurface', 'extendMethod')
    def setExtendMethod(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendSurface, kwargs, 'extendMethod', val)

    @_f.addMelDocs('extendSurface', 'extendSide')
    def setExtendSide(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendSurface, kwargs, 'extendSide', val)

    @_f.addMelDocs('extendSurface', 'extensionType')
    def setExtensionType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendSurface, kwargs, 'extensionType', val)

    @_f.addMelDocs('extendSurface', 'join')
    def setJoin(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendSurface, kwargs, 'join', val)

    @_f.addMelDocs('extendSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendSurface, kwargs, 'nodeState', val)


class FfBlendSrf(AbstractBaseCreate):
    __melnode__ = u'ffBlendSrf'
    __slots__ = ()


class MakeNurbsSquare(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.nurbsSquare)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'nurbsSquare'
    __melnode__ = u'makeNurbsSquare'
    __slots__ = ()

    @_f.addMelDocs('nurbsSquare', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('nurbsSquare', 'center')
    def getCenter(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'center')
        return res

    @_f.addMelDocs('nurbsSquare', 'centerX')
    def getCenterX(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'centerX')
        return res

    @_f.addMelDocs('nurbsSquare', 'centerY')
    def getCenterY(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'centerY')
        return res

    @_f.addMelDocs('nurbsSquare', 'centerZ')
    def getCenterZ(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'centerZ')
        return res

    @_f.addMelDocs('nurbsSquare', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'degree')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsSquare', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'frozen')
        return res

    @_f.addMelDocs('nurbsSquare', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsSquare', 'normal')
    def getNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'normal')
        return res

    @_f.addMelDocs('nurbsSquare', 'normalX')
    def getNormalX(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'normalX')
        return res

    @_f.addMelDocs('nurbsSquare', 'normalY')
    def getNormalY(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'normalY')
        return res

    @_f.addMelDocs('nurbsSquare', 'normalZ')
    def getNormalZ(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'normalZ')
        return res

    @_f.addMelDocs('nurbsSquare', 'sideLength1')
    def getSideLength1(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'sideLength1')
        return res

    @_f.addMelDocs('nurbsSquare', 'sideLength2')
    def getSideLength2(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'sideLength2')
        return res

    @_f.addMelDocs('nurbsSquare', 'spansPerSide')
    def getSpansPerSide(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsSquare, kwargs, 'spansPerSide')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsSquare', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'caching', val)

    @_f.addMelDocs('nurbsSquare', 'center')
    def setCenter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'center', val)

    @_f.addMelDocs('nurbsSquare', 'centerX')
    def setCenterX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'centerX', val)

    @_f.addMelDocs('nurbsSquare', 'centerY')
    def setCenterY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'centerY', val)

    @_f.addMelDocs('nurbsSquare', 'centerZ')
    def setCenterZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'centerZ', val)

    @_f.addMelDocs('nurbsSquare', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'degree', val)

    @_f.addMelDocs('nurbsSquare', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'frozen', val)

    @_f.addMelDocs('nurbsSquare', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'nodeState', val)

    @_f.addMelDocs('nurbsSquare', 'normal')
    def setNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'normal', val)

    @_f.addMelDocs('nurbsSquare', 'normalX')
    def setNormalX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'normalX', val)

    @_f.addMelDocs('nurbsSquare', 'normalY')
    def setNormalY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'normalY', val)

    @_f.addMelDocs('nurbsSquare', 'normalZ')
    def setNormalZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'normalZ', val)

    @_f.addMelDocs('nurbsSquare', 'sideLength1')
    def setSideLength1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'sideLength1', val)

    @_f.addMelDocs('nurbsSquare', 'sideLength2')
    def setSideLength2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'sideLength2', val)

    @_f.addMelDocs('nurbsSquare', 'spansPerSide')
    def setSpansPerSide(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsSquare, kwargs, 'spansPerSide', val)


class ProjectCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.projectCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'projectCurve'
    __melnode__ = u'projectCurve'
    __slots__ = ()

    @_f.addMelDocs('projectCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.projectCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('projectCurve', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.projectCurve, kwargs, 'direction')
        return res

    @_f.addMelDocs('projectCurve', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, modeling.projectCurve, kwargs, 'directionX')
        return res

    @_f.addMelDocs('projectCurve', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, modeling.projectCurve, kwargs, 'directionY')
        return res

    @_f.addMelDocs('projectCurve', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, modeling.projectCurve, kwargs, 'directionZ')
        return res

    @_f.addMelDocs('projectCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.projectCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('projectCurve', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.projectCurve, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('projectCurve', 'useNormal')
    def getUseNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.projectCurve, kwargs, 'useNormal')
        return res

    @_f.addMelDocs('projectCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectCurve, kwargs, 'caching', val)

    @_f.addMelDocs('projectCurve', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectCurve, kwargs, 'direction', val)

    @_f.addMelDocs('projectCurve', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectCurve, kwargs, 'directionX', val)

    @_f.addMelDocs('projectCurve', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectCurve, kwargs, 'directionY', val)

    @_f.addMelDocs('projectCurve', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectCurve, kwargs, 'directionZ', val)

    @_f.addMelDocs('projectCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('projectCurve', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectCurve, kwargs, 'tolerance', val)

    @_f.addMelDocs('projectCurve', 'useNormal')
    def setUseNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectCurve, kwargs, 'useNormal', val)


class NearestPointOnCurve(AbstractBaseCreate):
    __melnode__ = u'nearestPointOnCurve'
    __slots__ = ()


class InsertKnotCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.insertKnotCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'insertKnotCurve'
    __melnode__ = u'insertKnotCurve'
    __slots__ = ()

    @_f.addMelDocs('insertKnotCurve', 'addKnots')
    def getAddKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotCurve, kwargs, 'addKnots')
        return res

    @_f.addMelDocs('insertKnotCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('insertKnotCurve', 'insertBetween')
    def getInsertBetween(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotCurve, kwargs, 'insertBetween')
        return res

    @_f.addMelDocs('insertKnotCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('insertKnotCurve', 'numberOfKnots')
    def getNumberOfKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotCurve, kwargs, 'numberOfKnots')
        return res

    @_f.addMelDocs('insertKnotCurve', 'parameter')
    def getParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotCurve, kwargs, 'parameter')
        return res

    @_f.addMelDocs('insertKnotCurve', 'addKnots')
    def setAddKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotCurve, kwargs, 'addKnots', val)

    @_f.addMelDocs('insertKnotCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotCurve, kwargs, 'caching', val)

    @_f.addMelDocs('insertKnotCurve', 'insertBetween')
    def setInsertBetween(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotCurve, kwargs, 'insertBetween', val)

    @_f.addMelDocs('insertKnotCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('insertKnotCurve', 'numberOfKnots')
    def setNumberOfKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotCurve, kwargs, 'numberOfKnots', val)

    @_f.addMelDocs('insertKnotCurve', 'parameter')
    def setParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotCurve, kwargs, 'parameter', val)


class NurbsCurveToBezier(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.nurbsCurveToBezier)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'nurbsCurveToBezier'
    __melnode__ = u'nurbsCurveToBezier'
    __slots__ = ()


class ClosestPointOnSurface(AbstractBaseCreate):
    __melnode__ = u'closestPointOnSurface'
    __slots__ = ()


class AlignSurface(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.alignSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'alignSurface'
    __melnode__ = u'alignSurface'
    __slots__ = ()

    @_f.addMelDocs('alignSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('alignSurface', 'curvatureContinuity')
    def getCurvatureContinuity(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'curvatureContinuity')
        return res

    @_f.addMelDocs('alignSurface', 'curvatureScale1')
    def getCurvatureScale1(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'curvatureScale1')
        return res

    @_f.addMelDocs('alignSurface', 'curvatureScale2')
    def getCurvatureScale2(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'curvatureScale2')
        return res

    @_f.addMelDocs('alignSurface', 'directionU')
    def getDirectionU(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'directionU')
        return res

    @_f.addMelDocs('alignSurface', 'joinParameter')
    def getJoinParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'joinParameter')
        return res

    @_f.addMelDocs('alignSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('alignSurface', 'positionalContinuity')
    def getPositionalContinuity(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'positionalContinuity')
        return res

    @_f.addMelDocs('alignSurface', 'positionalContinuityType')
    def getPositionalContinuityType(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'positionalContinuityType')
        return res

    @_f.addMelDocs('alignSurface', 'reverse1')
    def getReverse1(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'reverse1')
        return res

    @_f.addMelDocs('alignSurface', 'reverse2')
    def getReverse2(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'reverse2')
        return res

    @_f.addMelDocs('alignSurface', 'swap1')
    def getSwap1(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'swap1')
        return res

    @_f.addMelDocs('alignSurface', 'swap2')
    def getSwap2(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'swap2')
        return res

    @_f.addMelDocs('alignSurface', 'tangentContinuity')
    def getTangentContinuity(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'tangentContinuity')
        return res

    @_f.addMelDocs('alignSurface', 'tangentContinuityType')
    def getTangentContinuityType(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'tangentContinuityType')
        return res

    @_f.addMelDocs('alignSurface', 'tangentScale1')
    def getTangentScale1(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'tangentScale1')
        return res

    @_f.addMelDocs('alignSurface', 'tangentScale2')
    def getTangentScale2(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'tangentScale2')
        return res

    @_f.addMelDocs('alignSurface', 'twist')
    def getTwist(self, **kwargs):
        res = _f.asQuery(self, modeling.alignSurface, kwargs, 'twist')
        return res

    @_f.addMelDocs('alignSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'caching', val)

    @_f.addMelDocs('alignSurface', 'curvatureContinuity')
    def setCurvatureContinuity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'curvatureContinuity', val)

    @_f.addMelDocs('alignSurface', 'curvatureScale1')
    def setCurvatureScale1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'curvatureScale1', val)

    @_f.addMelDocs('alignSurface', 'curvatureScale2')
    def setCurvatureScale2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'curvatureScale2', val)

    @_f.addMelDocs('alignSurface', 'directionU')
    def setDirectionU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'directionU', val)

    @_f.addMelDocs('alignSurface', 'joinParameter')
    def setJoinParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'joinParameter', val)

    @_f.addMelDocs('alignSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'nodeState', val)

    @_f.addMelDocs('alignSurface', 'positionalContinuity')
    def setPositionalContinuity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'positionalContinuity', val)

    @_f.addMelDocs('alignSurface', 'positionalContinuityType')
    def setPositionalContinuityType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'positionalContinuityType', val)

    @_f.addMelDocs('alignSurface', 'reverse1')
    def setReverse1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'reverse1', val)

    @_f.addMelDocs('alignSurface', 'reverse2')
    def setReverse2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'reverse2', val)

    @_f.addMelDocs('alignSurface', 'swap1')
    def setSwap1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'swap1', val)

    @_f.addMelDocs('alignSurface', 'swap2')
    def setSwap2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'swap2', val)

    @_f.addMelDocs('alignSurface', 'tangentContinuity')
    def setTangentContinuity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'tangentContinuity', val)

    @_f.addMelDocs('alignSurface', 'tangentContinuityType')
    def setTangentContinuityType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'tangentContinuityType', val)

    @_f.addMelDocs('alignSurface', 'tangentScale1')
    def setTangentScale1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'tangentScale1', val)

    @_f.addMelDocs('alignSurface', 'tangentScale2')
    def setTangentScale2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'tangentScale2', val)

    @_f.addMelDocs('alignSurface', 'twist')
    def setTwist(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignSurface, kwargs, 'twist', val)


class HardenPoint(AbstractBaseCreate):
    __melnode__ = u'hardenPoint'
    __slots__ = ()


class Extrude(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.extrude)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'extrude'
    __melnode__ = u'extrude'
    __slots__ = ()

    @_f.addMelDocs('extrude', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'caching')
        return res

    @_f.addMelDocs('extrude', 'degreeAlongLength')
    def getDegreeAlongLength(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'degreeAlongLength')
        return res

    @_f.addMelDocs('extrude', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'direction')
        return res

    @_f.addMelDocs('extrude', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'directionX')
        return res

    @_f.addMelDocs('extrude', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'directionY')
        return res

    @_f.addMelDocs('extrude', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'directionZ')
        return res

    @_f.addMelDocs('extrude', 'extrudeType')
    def getExtrudeType(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'extrudeType')
        return res

    @_f.addMelDocs('extrude', 'fixedPath')
    def getFixedPath(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'fixedPath')
        return res

    @_f.addMelDocs('extrude', 'length')
    def getLength(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'length')
        return res

    @_f.addMelDocs('extrude', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('extrude', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'pivot')
        return res

    @_f.addMelDocs('extrude', 'reverseSurfaceIfPathReversed')
    def getReverseSurfaceIfPathReversed(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'reverseSurfaceIfPathReversed')
        return res

    @_f.addMelDocs('extrude', 'rotation')
    def getRotation(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'rotation')
        return res

    @_f.addMelDocs('extrude', 'scale')
    def getScale(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'scale')
        return res

    @_f.addMelDocs('extrude', 'subCurveSubSurface')
    def getSubCurveSubSurface(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'subCurveSubSurface')
        return res

    @_f.addMelDocs('extrude', 'useComponentPivot')
    def getUseComponentPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'useComponentPivot')
        return res

    @_f.addMelDocs('extrude', 'useProfileNormal')
    def getUseProfileNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.extrude, kwargs, 'useProfileNormal')
        return res

    @_f.addMelDocs('extrude', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'caching', val)

    @_f.addMelDocs('extrude', 'degreeAlongLength')
    def setDegreeAlongLength(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'degreeAlongLength', val)

    @_f.addMelDocs('extrude', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'direction', val)

    @_f.addMelDocs('extrude', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'directionX', val)

    @_f.addMelDocs('extrude', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'directionY', val)

    @_f.addMelDocs('extrude', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'directionZ', val)

    @_f.addMelDocs('extrude', 'extrudeType')
    def setExtrudeType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'extrudeType', val)

    @_f.addMelDocs('extrude', 'fixedPath')
    def setFixedPath(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'fixedPath', val)

    @_f.addMelDocs('extrude', 'length')
    def setLength(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'length', val)

    @_f.addMelDocs('extrude', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'nodeState', val)

    @_f.addMelDocs('extrude', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'pivot', val)

    @_f.addMelDocs('extrude', 'reverseSurfaceIfPathReversed')
    def setReverseSurfaceIfPathReversed(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'reverseSurfaceIfPathReversed', val)

    @_f.addMelDocs('extrude', 'rotation')
    def setRotation(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'rotation', val)

    @_f.addMelDocs('extrude', 'scale')
    def setScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'scale', val)

    @_f.addMelDocs('extrude', 'subCurveSubSurface')
    def setSubCurveSubSurface(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'subCurveSubSurface', val)

    @_f.addMelDocs('extrude', 'useComponentPivot')
    def setUseComponentPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'useComponentPivot', val)

    @_f.addMelDocs('extrude', 'useProfileNormal')
    def setUseProfileNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extrude, kwargs, 'useProfileNormal', val)


class RoundConstantRadius(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.roundConstantRadius)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'roundConstantRadius'
    __melnode__ = u'roundConstantRadius'
    __slots__ = ()


class SubdivToNurbs(AbstractBaseCreate):
    __melnode__ = u'subdivToNurbs'
    __slots__ = ()


class CloseSurface(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.closeSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'closeSurface'
    __melnode__ = u'closeSurface'
    __slots__ = ()

    @_f.addMelDocs('closeSurface', 'blendBias')
    def getBlendBias(self, **kwargs):
        res = _f.asQuery(self, modeling.closeSurface, kwargs, 'blendBias')
        return res

    @_f.addMelDocs('closeSurface', 'blendKnotInsertion')
    def getBlendKnotInsertion(self, **kwargs):
        res = _f.asQuery(self, modeling.closeSurface, kwargs, 'blendKnotInsertion')
        return res

    @_f.addMelDocs('closeSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.closeSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('closeSurface', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.closeSurface, kwargs, 'direction')
        return res

    @_f.addMelDocs('closeSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.closeSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('closeSurface', 'parameter')
    def getParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.closeSurface, kwargs, 'parameter')
        return res

    @_f.addMelDocs('closeSurface', 'preserveShape')
    def getPreserveShape(self, **kwargs):
        res = _f.asQuery(self, modeling.closeSurface, kwargs, 'preserveShape')
        return res

    @_f.addMelDocs('closeSurface', 'blendBias')
    def setBlendBias(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeSurface, kwargs, 'blendBias', val)

    @_f.addMelDocs('closeSurface', 'blendKnotInsertion')
    def setBlendKnotInsertion(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeSurface, kwargs, 'blendKnotInsertion', val)

    @_f.addMelDocs('closeSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeSurface, kwargs, 'caching', val)

    @_f.addMelDocs('closeSurface', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeSurface, kwargs, 'direction', val)

    @_f.addMelDocs('closeSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeSurface, kwargs, 'nodeState', val)

    @_f.addMelDocs('closeSurface', 'parameter')
    def setParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeSurface, kwargs, 'parameter', val)

    @_f.addMelDocs('closeSurface', 'preserveShape')
    def setPreserveShape(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeSurface, kwargs, 'preserveShape', val)


class TrimWithBoundaries(AbstractBaseCreate):
    __melnode__ = u'trimWithBoundaries'
    __slots__ = ()


class OffsetCos(AbstractBaseCreate):
    __melnode__ = u'offsetCos'
    __slots__ = ()


class SmoothTangentSrf(AbstractBaseCreate):
    __melnode__ = u'smoothTangentSrf'
    __slots__ = ()


class PointOnCurveInfo(AbstractBaseCreate):
    __melnode__ = u'pointOnCurveInfo'
    __slots__ = ()


class SurfaceInfo(AbstractBaseCreate):
    __melnode__ = u'surfaceInfo'
    __slots__ = ()


class PlanarTrimSurface(AbstractBaseCreate):
    __melnode__ = u'planarTrimSurface'
    __slots__ = ()


class ExtendCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.extendCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'extendCurve'
    __melnode__ = u'extendCurve'
    __slots__ = ()

    @_f.addMelDocs('extendCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('extendCurve', 'distance')
    def getDistance(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'distance')
        return res

    @_f.addMelDocs('extendCurve', 'extendMethod')
    def getExtendMethod(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'extendMethod')
        return res

    @_f.addMelDocs('extendCurve', 'extensionType')
    def getExtensionType(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'extensionType')
        return res

    @_f.addMelDocs('extendCurve', 'inputPoint')
    def getInputPoint(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'inputPoint')
        return res

    @_f.addMelDocs('extendCurve', 'join')
    def getJoin(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'join')
        return res

    @_f.addMelDocs('extendCurve', 'noChanges')
    def getNoChanges(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'noChanges')
        return res

    @_f.addMelDocs('extendCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('extendCurve', 'pointX')
    def getPointX(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'pointX')
        return res

    @_f.addMelDocs('extendCurve', 'pointY')
    def getPointY(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'pointY')
        return res

    @_f.addMelDocs('extendCurve', 'pointZ')
    def getPointZ(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'pointZ')
        return res

    @_f.addMelDocs('extendCurve', 'removeMultipleKnots')
    def getRemoveMultipleKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'removeMultipleKnots')
        return res

    @_f.addMelDocs('extendCurve', 'start')
    def getStart(self, **kwargs):
        res = _f.asQuery(self, modeling.extendCurve, kwargs, 'start')
        return res

    @_f.addMelDocs('extendCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'caching', val)

    @_f.addMelDocs('extendCurve', 'distance')
    def setDistance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'distance', val)

    @_f.addMelDocs('extendCurve', 'extendMethod')
    def setExtendMethod(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'extendMethod', val)

    @_f.addMelDocs('extendCurve', 'extensionType')
    def setExtensionType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'extensionType', val)

    @_f.addMelDocs('extendCurve', 'inputPoint')
    def setInputPoint(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'inputPoint', val)

    @_f.addMelDocs('extendCurve', 'join')
    def setJoin(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'join', val)

    @_f.addMelDocs('extendCurve', 'noChanges')
    def setNoChanges(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'noChanges', val)

    @_f.addMelDocs('extendCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('extendCurve', 'pointX')
    def setPointX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'pointX', val)

    @_f.addMelDocs('extendCurve', 'pointY')
    def setPointY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'pointY', val)

    @_f.addMelDocs('extendCurve', 'pointZ')
    def setPointZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'pointZ', val)

    @_f.addMelDocs('extendCurve', 'removeMultipleKnots')
    def setRemoveMultipleKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'removeMultipleKnots', val)

    @_f.addMelDocs('extendCurve', 'start')
    def setStart(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.extendCurve, kwargs, 'start', val)


class PolyEdgeToCurve(AbstractBaseCreate):
    __melnode__ = u'polyEdgeToCurve'
    __slots__ = ()


class StitchSrf(AbstractBaseCreate):
    __melnode__ = u'stitchSrf'
    __slots__ = ()


class FilletCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.filletCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'filletCurve'
    __melnode__ = u'filletCurve'
    __slots__ = ()

    @_f.addMelDocs('filletCurve', 'bias')
    def getBias(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'bias')
        return res

    @_f.addMelDocs('filletCurve', 'blendControl')
    def getBlendControl(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'blendControl')
        return res

    @_f.addMelDocs('filletCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('filletCurve', 'circular')
    def getCircular(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'circular')
        return res

    @_f.addMelDocs('filletCurve', 'curveParameter1')
    def getCurveParameter1(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'curveParameter1')
        return res

    @_f.addMelDocs('filletCurve', 'curveParameter2')
    def getCurveParameter2(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'curveParameter2')
        return res

    @_f.addMelDocs('filletCurve', 'depth')
    def getDepth(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'depth')
        return res

    @_f.addMelDocs('filletCurve', 'freeformBlend')
    def getFreeformBlend(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'freeformBlend')
        return res

    @_f.addMelDocs('filletCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('filletCurve', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.filletCurve, kwargs, 'radius')
        return res

    @_f.addMelDocs('filletCurve', 'bias')
    def setBias(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'bias', val)

    @_f.addMelDocs('filletCurve', 'blendControl')
    def setBlendControl(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'blendControl', val)

    @_f.addMelDocs('filletCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'caching', val)

    @_f.addMelDocs('filletCurve', 'circular')
    def setCircular(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'circular', val)

    @_f.addMelDocs('filletCurve', 'curveParameter1')
    def setCurveParameter1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'curveParameter1', val)

    @_f.addMelDocs('filletCurve', 'curveParameter2')
    def setCurveParameter2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'curveParameter2', val)

    @_f.addMelDocs('filletCurve', 'depth')
    def setDepth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'depth', val)

    @_f.addMelDocs('filletCurve', 'freeformBlend')
    def setFreeformBlend(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'freeformBlend', val)

    @_f.addMelDocs('filletCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('filletCurve', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.filletCurve, kwargs, 'radius', val)


class CurveInfo(AbstractBaseCreate):
    __melnode__ = u'curveInfo'
    __slots__ = ()


class IntersectSurface(AbstractBaseCreate):
    __melnode__ = u'intersectSurface'
    __slots__ = ()


class Untrim(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.untrim)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'untrim'
    __melnode__ = u'untrim'
    __slots__ = ()

    @_f.addMelDocs('untrim', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.untrim, kwargs, 'caching')
        return res

    @_f.addMelDocs('untrim', 'noChanges')
    def getNoChanges(self, **kwargs):
        res = _f.asQuery(self, modeling.untrim, kwargs, 'noChanges')
        return res

    @_f.addMelDocs('untrim', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.untrim, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('untrim', 'untrimAll')
    def getUntrimAll(self, **kwargs):
        res = _f.asQuery(self, modeling.untrim, kwargs, 'untrimAll')
        return res

    @_f.addMelDocs('untrim', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.untrim, kwargs, 'caching', val)

    @_f.addMelDocs('untrim', 'noChanges')
    def setNoChanges(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.untrim, kwargs, 'noChanges', val)

    @_f.addMelDocs('untrim', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.untrim, kwargs, 'nodeState', val)

    @_f.addMelDocs('untrim', 'untrimAll')
    def setUntrimAll(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.untrim, kwargs, 'untrimAll', val)


class AvgNurbsSurfacePoints(AbstractBaseCreate):
    __melnode__ = u'avgNurbsSurfacePoints'
    __slots__ = ()


class AttachCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.attachCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'attachCurve'
    __melnode__ = u'attachCurve'
    __slots__ = ()

    @_f.addMelDocs('attachCurve', 'blendBias')
    def getBlendBias(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'blendBias')
        return res

    @_f.addMelDocs('attachCurve', 'blendKnotInsertion')
    def getBlendKnotInsertion(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'blendKnotInsertion')
        return res

    @_f.addMelDocs('attachCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('attachCurve', 'keepMultipleKnots')
    def getKeepMultipleKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'keepMultipleKnots')
        return res

    @_f.addMelDocs('attachCurve', 'method')
    def getMethod(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'method')
        return res

    @_f.addMelDocs('attachCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('attachCurve', 'parameter')
    def getParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'parameter')
        return res

    @_f.addMelDocs('attachCurve', 'reverse1')
    def getReverse1(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'reverse1')
        return res

    @_f.addMelDocs('attachCurve', 'reverse2')
    def getReverse2(self, **kwargs):
        res = _f.asQuery(self, modeling.attachCurve, kwargs, 'reverse2')
        return res

    @_f.addMelDocs('attachCurve', 'blendBias')
    def setBlendBias(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'blendBias', val)

    @_f.addMelDocs('attachCurve', 'blendKnotInsertion')
    def setBlendKnotInsertion(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'blendKnotInsertion', val)

    @_f.addMelDocs('attachCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'caching', val)

    @_f.addMelDocs('attachCurve', 'keepMultipleKnots')
    def setKeepMultipleKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'keepMultipleKnots', val)

    @_f.addMelDocs('attachCurve', 'method')
    def setMethod(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'method', val)

    @_f.addMelDocs('attachCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('attachCurve', 'parameter')
    def setParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'parameter', val)

    @_f.addMelDocs('attachCurve', 'reverse1')
    def setReverse1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'reverse1', val)

    @_f.addMelDocs('attachCurve', 'reverse2')
    def setReverse2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.attachCurve, kwargs, 'reverse2', val)


class MakeCircularArc(AbstractBaseCreate):
    __melnode__ = u'makeCircularArc'
    __slots__ = ()


class MakeTwoPointCircularArc(MakeCircularArc):
    __melnode__ = u'makeTwoPointCircularArc'
    __slots__ = ()


class MakeThreePointCircularArc(MakeCircularArc):
    __melnode__ = u'makeThreePointCircularArc'
    __slots__ = ()


class Loft(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.loft)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'loft'
    __melnode__ = u'loft'
    __slots__ = ()

    @_f.addMelDocs('loft', 'autoReverse')
    def getAutoReverse(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'autoReverse')
        return res

    @_f.addMelDocs('loft', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'caching')
        return res

    @_f.addMelDocs('loft', 'close')
    def getClose(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'close')
        return res

    @_f.addMelDocs('loft', 'createCusp')
    def getCreateCusp(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'createCusp')
        return res

    @_f.addMelDocs('loft', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'degree')
        return res

    @_f.addMelDocs('loft', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('loft', 'reverse')
    def getReverse(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'reverse')
        return res

    @_f.addMelDocs('loft', 'reverseSurfaceNormals')
    def getReverseSurfaceNormals(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'reverseSurfaceNormals')
        return res

    @_f.addMelDocs('loft', 'sectionSpans')
    def getSectionSpans(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'sectionSpans')
        return res

    @_f.addMelDocs('loft', 'uniform')
    def getUniform(self, **kwargs):
        res = _f.asQuery(self, modeling.loft, kwargs, 'uniform')
        return res

    @_f.addMelDocs('loft', 'autoReverse')
    def setAutoReverse(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'autoReverse', val)

    @_f.addMelDocs('loft', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'caching', val)

    @_f.addMelDocs('loft', 'close')
    def setClose(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'close', val)

    @_f.addMelDocs('loft', 'createCusp')
    def setCreateCusp(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'createCusp', val)

    @_f.addMelDocs('loft', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'degree', val)

    @_f.addMelDocs('loft', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'nodeState', val)

    @_f.addMelDocs('loft', 'reverse')
    def setReverse(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'reverse', val)

    @_f.addMelDocs('loft', 'reverseSurfaceNormals')
    def setReverseSurfaceNormals(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'reverseSurfaceNormals', val)

    @_f.addMelDocs('loft', 'sectionSpans')
    def setSectionSpans(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'sectionSpans', val)

    @_f.addMelDocs('loft', 'uniform')
    def setUniform(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.loft, kwargs, 'uniform', val)


class SmoothCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.smoothCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'smoothCurve'
    __melnode__ = u'smoothCurve'
    __slots__ = ()

    @_f.addMelDocs('smoothCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.smoothCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('smoothCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.smoothCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('smoothCurve', 'smoothness')
    def getSmoothness(self, **kwargs):
        res = _f.asQuery(self, modeling.smoothCurve, kwargs, 'smoothness')
        return res

    @_f.addMelDocs('smoothCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.smoothCurve, kwargs, 'caching', val)

    @_f.addMelDocs('smoothCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.smoothCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('smoothCurve', 'smoothness')
    def setSmoothness(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.smoothCurve, kwargs, 'smoothness', val)


class LeastSquaresModifier(AbstractBaseCreate):
    __melnode__ = u'leastSquaresModifier'
    __slots__ = ()


class MakeTextCurves(AbstractBaseCreate):
    __melnode__ = u'makeTextCurves'
    __slots__ = ()


class ProjectTangent(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.projectTangent)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'projectTangent'
    __melnode__ = u'projectTangent'
    __slots__ = ()

    @_f.addMelDocs('projectTangent', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'caching')
        return res

    @_f.addMelDocs('projectTangent', 'curvature')
    def getCurvature(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'curvature')
        return res

    @_f.addMelDocs('projectTangent', 'curvatureScale')
    def getCurvatureScale(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'curvatureScale')
        return res

    @_f.addMelDocs('projectTangent', 'ignoreEdges')
    def getIgnoreEdges(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'ignoreEdges')
        return res

    @_f.addMelDocs('projectTangent', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('projectTangent', 'reverseTangent')
    def getReverseTangent(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'reverseTangent')
        return res

    @_f.addMelDocs('projectTangent', 'rotate')
    def getRotate(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'rotate')
        return res

    @_f.addMelDocs('projectTangent', 'tangentDirection')
    def getTangentDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'tangentDirection')
        return res

    @_f.addMelDocs('projectTangent', 'tangentScale')
    def getTangentScale(self, **kwargs):
        res = _f.asQuery(self, modeling.projectTangent, kwargs, 'tangentScale')
        return res

    @_f.addMelDocs('projectTangent', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'caching', val)

    @_f.addMelDocs('projectTangent', 'curvature')
    def setCurvature(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'curvature', val)

    @_f.addMelDocs('projectTangent', 'curvatureScale')
    def setCurvatureScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'curvatureScale', val)

    @_f.addMelDocs('projectTangent', 'ignoreEdges')
    def setIgnoreEdges(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'ignoreEdges', val)

    @_f.addMelDocs('projectTangent', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'nodeState', val)

    @_f.addMelDocs('projectTangent', 'reverseTangent')
    def setReverseTangent(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'reverseTangent', val)

    @_f.addMelDocs('projectTangent', 'rotate')
    def setRotate(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'rotate', val)

    @_f.addMelDocs('projectTangent', 'tangentDirection')
    def setTangentDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'tangentDirection', val)

    @_f.addMelDocs('projectTangent', 'tangentScale')
    def setTangentScale(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.projectTangent, kwargs, 'tangentScale', val)


class MakeNurbCircle(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.circle)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'circle'
    __melnode__ = u'makeNurbCircle'
    __slots__ = ()

    @_f.addMelDocs('circle', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('circle', 'center')
    def getCenter(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'center')
        return res

    @_f.addMelDocs('circle', 'centerX')
    def getCenterX(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'centerX')
        return res

    @_f.addMelDocs('circle', 'centerY')
    def getCenterY(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'centerY')
        return res

    @_f.addMelDocs('circle', 'centerZ')
    def getCenterZ(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'centerZ')
        return res

    @_f.addMelDocs('circle', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'degree')
        res = int(res)
        return res

    @_f.addMelDocs('circle', 'first')
    def getFirst(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'first')
        return res

    @_f.addMelDocs('circle', 'firstPointX')
    def getFirstPointX(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'firstPointX')
        return res

    @_f.addMelDocs('circle', 'firstPointY')
    def getFirstPointY(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'firstPointY')
        return res

    @_f.addMelDocs('circle', 'firstPointZ')
    def getFirstPointZ(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'firstPointZ')
        return res

    @_f.addMelDocs('circle', 'fixCenter')
    def getFixCenter(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'fixCenter')
        res = bool(res)
        return res

    @_f.addMelDocs('circle', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'frozen')
        return res

    @_f.addMelDocs('circle', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('circle', 'normal')
    def getNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'normal')
        return res

    @_f.addMelDocs('circle', 'normalX')
    def getNormalX(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'normalX')
        return res

    @_f.addMelDocs('circle', 'normalY')
    def getNormalY(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'normalY')
        return res

    @_f.addMelDocs('circle', 'normalZ')
    def getNormalZ(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'normalZ')
        return res

    @_f.addMelDocs('circle', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'radius')
        return res

    @_f.addMelDocs('circle', 'sections')
    def getSections(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'sections')
        res = int(res)
        return res

    @_f.addMelDocs('circle', 'sweep')
    def getSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'sweep')
        return res

    @_f.addMelDocs('circle', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('circle', 'useTolerance')
    def getUseTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.circle, kwargs, 'useTolerance')
        res = bool(res)
        return res

    @_f.addMelDocs('circle', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'caching', val)

    @_f.addMelDocs('circle', 'center')
    def setCenter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'center', val)

    @_f.addMelDocs('circle', 'centerX')
    def setCenterX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'centerX', val)

    @_f.addMelDocs('circle', 'centerY')
    def setCenterY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'centerY', val)

    @_f.addMelDocs('circle', 'centerZ')
    def setCenterZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'centerZ', val)

    @_f.addMelDocs('circle', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'degree', val)

    @_f.addMelDocs('circle', 'first')
    def setFirst(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'first', val)

    @_f.addMelDocs('circle', 'firstPointX')
    def setFirstPointX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'firstPointX', val)

    @_f.addMelDocs('circle', 'firstPointY')
    def setFirstPointY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'firstPointY', val)

    @_f.addMelDocs('circle', 'firstPointZ')
    def setFirstPointZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'firstPointZ', val)

    @_f.addMelDocs('circle', 'fixCenter')
    def setFixCenter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'fixCenter', val)

    @_f.addMelDocs('circle', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'frozen', val)

    @_f.addMelDocs('circle', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'nodeState', val)

    @_f.addMelDocs('circle', 'normal')
    def setNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'normal', val)

    @_f.addMelDocs('circle', 'normalX')
    def setNormalX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'normalX', val)

    @_f.addMelDocs('circle', 'normalY')
    def setNormalY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'normalY', val)

    @_f.addMelDocs('circle', 'normalZ')
    def setNormalZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'normalZ', val)

    @_f.addMelDocs('circle', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'radius', val)

    @_f.addMelDocs('circle', 'sections')
    def setSections(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'sections', val)

    @_f.addMelDocs('circle', 'sweep')
    def setSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'sweep', val)

    @_f.addMelDocs('circle', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'tolerance', val)

    @_f.addMelDocs('circle', 'useTolerance')
    def setUseTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.circle, kwargs, 'useTolerance', val)


class OffsetCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.offsetCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'offsetCurve'
    __melnode__ = u'offsetCurve'
    __slots__ = ()

    @_f.addMelDocs('offsetCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('offsetCurve', 'connectBreaks')
    def getConnectBreaks(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'connectBreaks')
        return res

    @_f.addMelDocs('offsetCurve', 'cutLoop')
    def getCutLoop(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'cutLoop')
        return res

    @_f.addMelDocs('offsetCurve', 'cutRadius')
    def getCutRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'cutRadius')
        return res

    @_f.addMelDocs('offsetCurve', 'distance')
    def getDistance(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'distance')
        return res

    @_f.addMelDocs('offsetCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('offsetCurve', 'normal')
    def getNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'normal')
        return res

    @_f.addMelDocs('offsetCurve', 'reparameterize')
    def getReparameterize(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'reparameterize')
        return res

    @_f.addMelDocs('offsetCurve', 'stitch')
    def getStitch(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'stitch')
        return res

    @_f.addMelDocs('offsetCurve', 'subdivisionDensity')
    def getSubdivisionDensity(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'subdivisionDensity')
        return res

    @_f.addMelDocs('offsetCurve', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('offsetCurve', 'useGivenNormal')
    def getUseGivenNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetCurve, kwargs, 'useGivenNormal')
        return res

    @_f.addMelDocs('offsetCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'caching', val)

    @_f.addMelDocs('offsetCurve', 'connectBreaks')
    def setConnectBreaks(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'connectBreaks', val)

    @_f.addMelDocs('offsetCurve', 'cutLoop')
    def setCutLoop(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'cutLoop', val)

    @_f.addMelDocs('offsetCurve', 'cutRadius')
    def setCutRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'cutRadius', val)

    @_f.addMelDocs('offsetCurve', 'distance')
    def setDistance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'distance', val)

    @_f.addMelDocs('offsetCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('offsetCurve', 'normal')
    def setNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'normal', val)

    @_f.addMelDocs('offsetCurve', 'reparameterize')
    def setReparameterize(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'reparameterize', val)

    @_f.addMelDocs('offsetCurve', 'stitch')
    def setStitch(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'stitch', val)

    @_f.addMelDocs('offsetCurve', 'subdivisionDensity')
    def setSubdivisionDensity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'subdivisionDensity', val)

    @_f.addMelDocs('offsetCurve', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'tolerance', val)

    @_f.addMelDocs('offsetCurve', 'useGivenNormal')
    def setUseGivenNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetCurve, kwargs, 'useGivenNormal', val)


class AbstractBaseNurbsConversion(AbstractBaseCreate):
    __melnode__ = u'abstractBaseNurbsConversion'
    __slots__ = ()


class ParentTessellate(AbstractBaseNurbsConversion):
    __melnode__ = u'parentTessellate'
    __slots__ = ()


class ShellTessellate(ParentTessellate):
    __melnode__ = u'shellTessellate'
    __slots__ = ()


class NurbsTessellate(ParentTessellate):
    __melnode__ = u'nurbsTessellate'
    __slots__ = ()


class RebuildSurface(AbstractBaseNurbsConversion):
    __melcmd__ = staticmethod(modeling.rebuildSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'rebuildSurface'
    __melnode__ = u'rebuildSurface'
    __slots__ = ()

    @_f.addMelDocs('rebuildSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('rebuildSurface', 'degreeU')
    def getDegreeU(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'degreeU')
        return res

    @_f.addMelDocs('rebuildSurface', 'degreeV')
    def getDegreeV(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'degreeV')
        return res

    @_f.addMelDocs('rebuildSurface', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'direction')
        return res

    @_f.addMelDocs('rebuildSurface', 'endKnots')
    def getEndKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'endKnots')
        return res

    @_f.addMelDocs('rebuildSurface', 'fitRebuild')
    def getFitRebuild(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'fitRebuild')
        return res

    @_f.addMelDocs('rebuildSurface', 'keepControlPoints')
    def getKeepControlPoints(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'keepControlPoints')
        return res

    @_f.addMelDocs('rebuildSurface', 'keepCorners')
    def getKeepCorners(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'keepCorners')
        return res

    @_f.addMelDocs('rebuildSurface', 'keepRange')
    def getKeepRange(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'keepRange')
        return res

    @_f.addMelDocs('rebuildSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('rebuildSurface', 'rebuildType')
    def getRebuildType(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'rebuildType')
        return res

    @_f.addMelDocs('rebuildSurface', 'spansU')
    def getSpansU(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'spansU')
        return res

    @_f.addMelDocs('rebuildSurface', 'spansV')
    def getSpansV(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'spansV')
        return res

    @_f.addMelDocs('rebuildSurface', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.rebuildSurface, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('rebuildSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'caching', val)

    @_f.addMelDocs('rebuildSurface', 'degreeU')
    def setDegreeU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'degreeU', val)

    @_f.addMelDocs('rebuildSurface', 'degreeV')
    def setDegreeV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'degreeV', val)

    @_f.addMelDocs('rebuildSurface', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'direction', val)

    @_f.addMelDocs('rebuildSurface', 'endKnots')
    def setEndKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'endKnots', val)

    @_f.addMelDocs('rebuildSurface', 'fitRebuild')
    def setFitRebuild(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'fitRebuild', val)

    @_f.addMelDocs('rebuildSurface', 'keepControlPoints')
    def setKeepControlPoints(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'keepControlPoints', val)

    @_f.addMelDocs('rebuildSurface', 'keepCorners')
    def setKeepCorners(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'keepCorners', val)

    @_f.addMelDocs('rebuildSurface', 'keepRange')
    def setKeepRange(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'keepRange', val)

    @_f.addMelDocs('rebuildSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'nodeState', val)

    @_f.addMelDocs('rebuildSurface', 'rebuildType')
    def setRebuildType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'rebuildType', val)

    @_f.addMelDocs('rebuildSurface', 'spansU')
    def setSpansU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'spansU', val)

    @_f.addMelDocs('rebuildSurface', 'spansV')
    def setSpansV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'spansV', val)

    @_f.addMelDocs('rebuildSurface', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.rebuildSurface, kwargs, 'tolerance', val)


class NurbsToSubdiv(AbstractBaseNurbsConversion):
    __melcmd__ = staticmethod(modeling.nurbsToSubdiv)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'nurbsToSubdiv'
    __melnode__ = u'nurbsToSubdiv'
    __slots__ = ()

    @_f.addMelDocs('nurbsToSubdiv', 'addUnderTransform')
    def getAddUnderTransform(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsToSubdiv, kwargs, 'addUnderTransform')
        return res

    @_f.addMelDocs('nurbsToSubdiv', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsToSubdiv, kwargs, 'caching')
        return res

    @_f.addMelDocs('nurbsToSubdiv', 'collapsePoles')
    def getCollapsePoles(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsToSubdiv, kwargs, 'collapsePoles')
        return res

    @_f.addMelDocs('nurbsToSubdiv', 'matchPeriodic')
    def getMatchPeriodic(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsToSubdiv, kwargs, 'matchPeriodic')
        return res

    @_f.addMelDocs('nurbsToSubdiv', 'maxPolyCount')
    def getMaxPolyCount(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsToSubdiv, kwargs, 'maxPolyCount')
        return res

    @_f.addMelDocs('nurbsToSubdiv', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsToSubdiv, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('nurbsToSubdiv', 'reverseNormal')
    def getReverseNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsToSubdiv, kwargs, 'reverseNormal')
        return res

    @_f.addMelDocs('nurbsToSubdiv', 'addUnderTransform')
    def setAddUnderTransform(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsToSubdiv, kwargs, 'addUnderTransform', val)

    @_f.addMelDocs('nurbsToSubdiv', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsToSubdiv, kwargs, 'caching', val)

    @_f.addMelDocs('nurbsToSubdiv', 'collapsePoles')
    def setCollapsePoles(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsToSubdiv, kwargs, 'collapsePoles', val)

    @_f.addMelDocs('nurbsToSubdiv', 'matchPeriodic')
    def setMatchPeriodic(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsToSubdiv, kwargs, 'matchPeriodic', val)

    @_f.addMelDocs('nurbsToSubdiv', 'maxPolyCount')
    def setMaxPolyCount(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsToSubdiv, kwargs, 'maxPolyCount', val)

    @_f.addMelDocs('nurbsToSubdiv', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsToSubdiv, kwargs, 'nodeState', val)

    @_f.addMelDocs('nurbsToSubdiv', 'reverseNormal')
    def setReverseNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsToSubdiv, kwargs, 'reverseNormal', val)


class NurbsToSubdivProc(NurbsToSubdiv):
    __melnode__ = u'nurbsToSubdivProc'
    __slots__ = ()


class ReverseSurface(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.reverseSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'reverseSurface'
    __melnode__ = u'reverseSurface'
    __slots__ = ()

    @_f.addMelDocs('reverseSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.reverseSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('reverseSurface', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.reverseSurface, kwargs, 'direction')
        return res

    @_f.addMelDocs('reverseSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.reverseSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('reverseSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.reverseSurface, kwargs, 'caching', val)

    @_f.addMelDocs('reverseSurface', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.reverseSurface, kwargs, 'direction', val)

    @_f.addMelDocs('reverseSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.reverseSurface, kwargs, 'nodeState', val)


class ExplodeNurbsShell(AbstractBaseCreate):
    __melnode__ = u'explodeNurbsShell'
    __slots__ = ()


class RbfSrf(AbstractBaseCreate):
    __melnode__ = u'rbfSrf'
    __slots__ = ()


class PolyProjectCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.polyProjectCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'polyProjectCurve'
    __melnode__ = u'polyProjectCurve'
    __slots__ = ()

    @_f.addMelDocs('polyProjectCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.polyProjectCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('polyProjectCurve', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.polyProjectCurve, kwargs, 'direction')
        return res

    @_f.addMelDocs('polyProjectCurve', 'directionX')
    def getDirectionX(self, **kwargs):
        res = _f.asQuery(self, modeling.polyProjectCurve, kwargs, 'directionX')
        return res

    @_f.addMelDocs('polyProjectCurve', 'directionY')
    def getDirectionY(self, **kwargs):
        res = _f.asQuery(self, modeling.polyProjectCurve, kwargs, 'directionY')
        return res

    @_f.addMelDocs('polyProjectCurve', 'directionZ')
    def getDirectionZ(self, **kwargs):
        res = _f.asQuery(self, modeling.polyProjectCurve, kwargs, 'directionZ')
        return res

    @_f.addMelDocs('polyProjectCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.polyProjectCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('polyProjectCurve', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.polyProjectCurve, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('polyProjectCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyProjectCurve, kwargs, 'caching', val)

    @_f.addMelDocs('polyProjectCurve', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyProjectCurve, kwargs, 'direction', val)

    @_f.addMelDocs('polyProjectCurve', 'directionX')
    def setDirectionX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyProjectCurve, kwargs, 'directionX', val)

    @_f.addMelDocs('polyProjectCurve', 'directionY')
    def setDirectionY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyProjectCurve, kwargs, 'directionY', val)

    @_f.addMelDocs('polyProjectCurve', 'directionZ')
    def setDirectionZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyProjectCurve, kwargs, 'directionZ', val)

    @_f.addMelDocs('polyProjectCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyProjectCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('polyProjectCurve', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.polyProjectCurve, kwargs, 'tolerance', val)


class MakeIllustratorCurves(AbstractBaseCreate):
    __melnode__ = u'makeIllustratorCurves'
    __slots__ = ()


class AvgCurves(AbstractBaseCreate):
    __melnode__ = u'avgCurves'
    __slots__ = ()


class BirailSrf(AbstractBaseCreate):
    __melnode__ = u'birailSrf'
    __slots__ = ()


class DpBirailSrf(BirailSrf):
    __melnode__ = u'dpBirailSrf'
    __slots__ = ()


class SpBirailSrf(BirailSrf):
    __melnode__ = u'spBirailSrf'
    __slots__ = ()


class MpBirailSrf(BirailSrf):
    __melnode__ = u'mpBirailSrf'
    __slots__ = ()


class AvgSurfacePoints(AbstractBaseCreate):
    __melnode__ = u'avgSurfacePoints'
    __slots__ = ()


class Primitive(AbstractBaseCreate):
    __melnode__ = u'primitive'
    __slots__ = ()


class MakeNurbPlane(Primitive):
    __melcmd__ = staticmethod(modeling.nurbsPlane)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'nurbsPlane'
    __melnode__ = u'makeNurbPlane'
    __slots__ = ()

    @_f.addMelDocs('nurbsPlane', 'axis')
    def getAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'axis')
        return res

    @_f.addMelDocs('nurbsPlane', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('nurbsPlane', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'degree')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsPlane', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'frozen')
        return res

    @_f.addMelDocs('nurbsPlane', 'lengthRatio')
    def getLengthRatio(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'lengthRatio')
        return res

    @_f.addMelDocs('nurbsPlane', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsPlane', 'patchesU')
    def getPatchesU(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'patchesU')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsPlane', 'patchesV')
    def getPatchesV(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'patchesV')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsPlane', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'pivot')
        return res

    @_f.addMelDocs('nurbsPlane', 'width')
    def getWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsPlane, kwargs, 'width')
        return res

    @_f.addMelDocs('nurbsPlane', 'axis')
    def setAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'axis', val)

    @_f.addMelDocs('nurbsPlane', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'caching', val)

    @_f.addMelDocs('nurbsPlane', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'degree', val)

    @_f.addMelDocs('nurbsPlane', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'frozen', val)

    @_f.addMelDocs('nurbsPlane', 'lengthRatio')
    def setLengthRatio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'lengthRatio', val)

    @_f.addMelDocs('nurbsPlane', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'nodeState', val)

    @_f.addMelDocs('nurbsPlane', 'patchesU')
    def setPatchesU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'patchesU', val)

    @_f.addMelDocs('nurbsPlane', 'patchesV')
    def setPatchesV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'patchesV', val)

    @_f.addMelDocs('nurbsPlane', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'pivot', val)

    @_f.addMelDocs('nurbsPlane', 'width')
    def setWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsPlane, kwargs, 'width', val)


class MakeNurbCube(Primitive):
    __melcmd__ = staticmethod(modeling.nurbsCube)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'nurbsCube'
    __melnode__ = u'makeNurbCube'
    __slots__ = ()

    @_f.addMelDocs('nurbsCube', 'axis')
    def getAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'axis')
        return res

    @_f.addMelDocs('nurbsCube', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('nurbsCube', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'degree')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsCube', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'frozen')
        return res

    @_f.addMelDocs('nurbsCube', 'heightRatio')
    def getHeightRatio(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'heightRatio')
        return res

    @_f.addMelDocs('nurbsCube', 'lengthRatio')
    def getLengthRatio(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'lengthRatio')
        return res

    @_f.addMelDocs('nurbsCube', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsCube', 'patchesU')
    def getPatchesU(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'patchesU')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsCube', 'patchesV')
    def getPatchesV(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'patchesV')
        res = int(res)
        return res

    @_f.addMelDocs('nurbsCube', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'pivot')
        return res

    @_f.addMelDocs('nurbsCube', 'width')
    def getWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.nurbsCube, kwargs, 'width')
        return res

    @_f.addMelDocs('nurbsCube', 'axis')
    def setAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'axis', val)

    @_f.addMelDocs('nurbsCube', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'caching', val)

    @_f.addMelDocs('nurbsCube', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'degree', val)

    @_f.addMelDocs('nurbsCube', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'frozen', val)

    @_f.addMelDocs('nurbsCube', 'heightRatio')
    def setHeightRatio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'heightRatio', val)

    @_f.addMelDocs('nurbsCube', 'lengthRatio')
    def setLengthRatio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'lengthRatio', val)

    @_f.addMelDocs('nurbsCube', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'nodeState', val)

    @_f.addMelDocs('nurbsCube', 'patchesU')
    def setPatchesU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'patchesU', val)

    @_f.addMelDocs('nurbsCube', 'patchesV')
    def setPatchesV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'patchesV', val)

    @_f.addMelDocs('nurbsCube', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'pivot', val)

    @_f.addMelDocs('nurbsCube', 'width')
    def setWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.nurbsCube, kwargs, 'width', val)


class RevolvedPrimitive(Primitive):
    __melnode__ = u'revolvedPrimitive'
    __slots__ = ()


class MakeNurbCylinder(RevolvedPrimitive):
    __melcmd__ = staticmethod(modeling.cylinder)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'cylinder'
    __melnode__ = u'makeNurbCylinder'
    __slots__ = ()

    @_f.addMelDocs('cylinder', 'axis')
    def getAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'axis')
        return res

    @_f.addMelDocs('cylinder', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('cylinder', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'degree')
        res = int(res)
        return res

    @_f.addMelDocs('cylinder', 'endSweep')
    def getEndSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'endSweep')
        return res

    @_f.addMelDocs('cylinder', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'frozen')
        return res

    @_f.addMelDocs('cylinder', 'heightRatio')
    def getHeightRatio(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'heightRatio')
        return res

    @_f.addMelDocs('cylinder', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('cylinder', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'pivot')
        return res

    @_f.addMelDocs('cylinder', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'radius')
        return res

    @_f.addMelDocs('cylinder', 'sections')
    def getSections(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'sections')
        res = int(res)
        return res

    @_f.addMelDocs('cylinder', 'spans')
    def getSpans(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'spans')
        res = int(res)
        return res

    @_f.addMelDocs('cylinder', 'startSweep')
    def getStartSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'startSweep')
        return res

    @_f.addMelDocs('cylinder', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('cylinder', 'useTolerance')
    def getUseTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.cylinder, kwargs, 'useTolerance')
        res = bool(res)
        return res

    @_f.addMelDocs('cylinder', 'axis')
    def setAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'axis', val)

    @_f.addMelDocs('cylinder', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'caching', val)

    @_f.addMelDocs('cylinder', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'degree', val)

    @_f.addMelDocs('cylinder', 'endSweep')
    def setEndSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'endSweep', val)

    @_f.addMelDocs('cylinder', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'frozen', val)

    @_f.addMelDocs('cylinder', 'heightRatio')
    def setHeightRatio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'heightRatio', val)

    @_f.addMelDocs('cylinder', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'nodeState', val)

    @_f.addMelDocs('cylinder', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'pivot', val)

    @_f.addMelDocs('cylinder', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'radius', val)

    @_f.addMelDocs('cylinder', 'sections')
    def setSections(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'sections', val)

    @_f.addMelDocs('cylinder', 'spans')
    def setSpans(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'spans', val)

    @_f.addMelDocs('cylinder', 'startSweep')
    def setStartSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'startSweep', val)

    @_f.addMelDocs('cylinder', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'tolerance', val)

    @_f.addMelDocs('cylinder', 'useTolerance')
    def setUseTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cylinder, kwargs, 'useTolerance', val)


class MakeNurbSphere(RevolvedPrimitive):
    __melcmd__ = staticmethod(modeling.sphere)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'sphere'
    __melnode__ = u'makeNurbSphere'
    __slots__ = ()

    @_f.addMelDocs('sphere', 'axis')
    def getAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'axis')
        return res

    @_f.addMelDocs('sphere', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('sphere', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'degree')
        res = int(res)
        return res

    @_f.addMelDocs('sphere', 'endSweep')
    def getEndSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'endSweep')
        return res

    @_f.addMelDocs('sphere', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'frozen')
        return res

    @_f.addMelDocs('sphere', 'heightRatio')
    def getHeightRatio(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'heightRatio')
        return res

    @_f.addMelDocs('sphere', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('sphere', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'pivot')
        return res

    @_f.addMelDocs('sphere', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'radius')
        return res

    @_f.addMelDocs('sphere', 'sections')
    def getSections(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'sections')
        res = int(res)
        return res

    @_f.addMelDocs('sphere', 'spans')
    def getSpans(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'spans')
        res = int(res)
        return res

    @_f.addMelDocs('sphere', 'startSweep')
    def getStartSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'startSweep')
        return res

    @_f.addMelDocs('sphere', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('sphere', 'useTolerance')
    def getUseTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.sphere, kwargs, 'useTolerance')
        res = bool(res)
        return res

    @_f.addMelDocs('sphere', 'axis')
    def setAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'axis', val)

    @_f.addMelDocs('sphere', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'caching', val)

    @_f.addMelDocs('sphere', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'degree', val)

    @_f.addMelDocs('sphere', 'endSweep')
    def setEndSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'endSweep', val)

    @_f.addMelDocs('sphere', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'frozen', val)

    @_f.addMelDocs('sphere', 'heightRatio')
    def setHeightRatio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'heightRatio', val)

    @_f.addMelDocs('sphere', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'nodeState', val)

    @_f.addMelDocs('sphere', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'pivot', val)

    @_f.addMelDocs('sphere', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'radius', val)

    @_f.addMelDocs('sphere', 'sections')
    def setSections(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'sections', val)

    @_f.addMelDocs('sphere', 'spans')
    def setSpans(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'spans', val)

    @_f.addMelDocs('sphere', 'startSweep')
    def setStartSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'startSweep', val)

    @_f.addMelDocs('sphere', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'tolerance', val)

    @_f.addMelDocs('sphere', 'useTolerance')
    def setUseTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.sphere, kwargs, 'useTolerance', val)


class MakeNurbCone(RevolvedPrimitive):
    __melcmd__ = staticmethod(modeling.cone)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'cone'
    __melnode__ = u'makeNurbCone'
    __slots__ = ()

    @_f.addMelDocs('cone', 'axis')
    def getAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'axis')
        return res

    @_f.addMelDocs('cone', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('cone', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'degree')
        res = int(res)
        return res

    @_f.addMelDocs('cone', 'endSweep')
    def getEndSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'endSweep')
        return res

    @_f.addMelDocs('cone', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'frozen')
        return res

    @_f.addMelDocs('cone', 'heightRatio')
    def getHeightRatio(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'heightRatio')
        return res

    @_f.addMelDocs('cone', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('cone', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'pivot')
        return res

    @_f.addMelDocs('cone', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'radius')
        return res

    @_f.addMelDocs('cone', 'sections')
    def getSections(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'sections')
        res = int(res)
        return res

    @_f.addMelDocs('cone', 'spans')
    def getSpans(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'spans')
        res = int(res)
        return res

    @_f.addMelDocs('cone', 'startSweep')
    def getStartSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'startSweep')
        return res

    @_f.addMelDocs('cone', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('cone', 'useOldInitBehaviour')
    def getUseOldInitBehaviour(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'useOldInitBehaviour')
        res = bool(res)
        return res

    @_f.addMelDocs('cone', 'useTolerance')
    def getUseTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.cone, kwargs, 'useTolerance')
        res = bool(res)
        return res

    @_f.addMelDocs('cone', 'axis')
    def setAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'axis', val)

    @_f.addMelDocs('cone', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'caching', val)

    @_f.addMelDocs('cone', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'degree', val)

    @_f.addMelDocs('cone', 'endSweep')
    def setEndSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'endSweep', val)

    @_f.addMelDocs('cone', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'frozen', val)

    @_f.addMelDocs('cone', 'heightRatio')
    def setHeightRatio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'heightRatio', val)

    @_f.addMelDocs('cone', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'nodeState', val)

    @_f.addMelDocs('cone', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'pivot', val)

    @_f.addMelDocs('cone', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'radius', val)

    @_f.addMelDocs('cone', 'sections')
    def setSections(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'sections', val)

    @_f.addMelDocs('cone', 'spans')
    def setSpans(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'spans', val)

    @_f.addMelDocs('cone', 'startSweep')
    def setStartSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'startSweep', val)

    @_f.addMelDocs('cone', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'tolerance', val)

    @_f.addMelDocs('cone', 'useOldInitBehaviour')
    def setUseOldInitBehaviour(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'useOldInitBehaviour', val)

    @_f.addMelDocs('cone', 'useTolerance')
    def setUseTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.cone, kwargs, 'useTolerance', val)


class MakeNurbTorus(RevolvedPrimitive):
    __melcmd__ = staticmethod(modeling.torus)
    __melcmd_isinfo__ = False
    __melcmdname__ = 'torus'
    __melnode__ = u'makeNurbTorus'
    __slots__ = ()

    @_f.addMelDocs('torus', 'axis')
    def getAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'axis')
        return res

    @_f.addMelDocs('torus', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'caching')
        res = bool(res)
        return res

    @_f.addMelDocs('torus', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'degree')
        res = int(res)
        return res

    @_f.addMelDocs('torus', 'endSweep')
    def getEndSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'endSweep')
        return res

    @_f.addMelDocs('torus', 'frozen')
    def getFrozen(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'frozen')
        return res

    @_f.addMelDocs('torus', 'heightRatio')
    def getHeightRatio(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'heightRatio')
        return res

    @_f.addMelDocs('torus', 'minorSweep')
    def getMinorSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'minorSweep')
        return res

    @_f.addMelDocs('torus', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'nodeState')
        res = int(res)
        return res

    @_f.addMelDocs('torus', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'pivot')
        return res

    @_f.addMelDocs('torus', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'radius')
        return res

    @_f.addMelDocs('torus', 'sections')
    def getSections(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'sections')
        res = int(res)
        return res

    @_f.addMelDocs('torus', 'spans')
    def getSpans(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'spans')
        res = int(res)
        return res

    @_f.addMelDocs('torus', 'startSweep')
    def getStartSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'startSweep')
        return res

    @_f.addMelDocs('torus', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('torus', 'useTolerance')
    def getUseTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.torus, kwargs, 'useTolerance')
        res = bool(res)
        return res

    @_f.addMelDocs('torus', 'axis')
    def setAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'axis', val)

    @_f.addMelDocs('torus', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'caching', val)

    @_f.addMelDocs('torus', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'degree', val)

    @_f.addMelDocs('torus', 'endSweep')
    def setEndSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'endSweep', val)

    @_f.addMelDocs('torus', 'frozen')
    def setFrozen(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'frozen', val)

    @_f.addMelDocs('torus', 'heightRatio')
    def setHeightRatio(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'heightRatio', val)

    @_f.addMelDocs('torus', 'minorSweep')
    def setMinorSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'minorSweep', val)

    @_f.addMelDocs('torus', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'nodeState', val)

    @_f.addMelDocs('torus', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'pivot', val)

    @_f.addMelDocs('torus', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'radius', val)

    @_f.addMelDocs('torus', 'sections')
    def setSections(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'sections', val)

    @_f.addMelDocs('torus', 'spans')
    def setSpans(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'spans', val)

    @_f.addMelDocs('torus', 'startSweep')
    def setStartSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'startSweep', val)

    @_f.addMelDocs('torus', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'tolerance', val)

    @_f.addMelDocs('torus', 'useTolerance')
    def setUseTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.torus, kwargs, 'useTolerance', val)


class StitchAsNurbsShell(AbstractBaseCreate):
    __melnode__ = u'stitchAsNurbsShell'
    __slots__ = ()


class OffsetSurface(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.offsetSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'offsetSurface'
    __melnode__ = u'offsetSurface'
    __slots__ = ()

    @_f.addMelDocs('offsetSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('offsetSurface', 'distance')
    def getDistance(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetSurface, kwargs, 'distance')
        return res

    @_f.addMelDocs('offsetSurface', 'method')
    def getMethod(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetSurface, kwargs, 'method')
        return res

    @_f.addMelDocs('offsetSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.offsetSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('offsetSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetSurface, kwargs, 'caching', val)

    @_f.addMelDocs('offsetSurface', 'distance')
    def setDistance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetSurface, kwargs, 'distance', val)

    @_f.addMelDocs('offsetSurface', 'method')
    def setMethod(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetSurface, kwargs, 'method', val)

    @_f.addMelDocs('offsetSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.offsetSurface, kwargs, 'nodeState', val)


class AlignCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.alignCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'alignCurve'
    __melnode__ = u'alignCurve'
    __slots__ = ()

    @_f.addMelDocs('alignCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('alignCurve', 'curvatureContinuity')
    def getCurvatureContinuity(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'curvatureContinuity')
        return res

    @_f.addMelDocs('alignCurve', 'curvatureScale1')
    def getCurvatureScale1(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'curvatureScale1')
        return res

    @_f.addMelDocs('alignCurve', 'curvatureScale2')
    def getCurvatureScale2(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'curvatureScale2')
        return res

    @_f.addMelDocs('alignCurve', 'joinParameter')
    def getJoinParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'joinParameter')
        return res

    @_f.addMelDocs('alignCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('alignCurve', 'positionalContinuity')
    def getPositionalContinuity(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'positionalContinuity')
        return res

    @_f.addMelDocs('alignCurve', 'positionalContinuityType')
    def getPositionalContinuityType(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'positionalContinuityType')
        return res

    @_f.addMelDocs('alignCurve', 'reverse1')
    def getReverse1(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'reverse1')
        return res

    @_f.addMelDocs('alignCurve', 'reverse2')
    def getReverse2(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'reverse2')
        return res

    @_f.addMelDocs('alignCurve', 'tangentContinuity')
    def getTangentContinuity(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'tangentContinuity')
        return res

    @_f.addMelDocs('alignCurve', 'tangentContinuityType')
    def getTangentContinuityType(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'tangentContinuityType')
        return res

    @_f.addMelDocs('alignCurve', 'tangentScale1')
    def getTangentScale1(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'tangentScale1')
        return res

    @_f.addMelDocs('alignCurve', 'tangentScale2')
    def getTangentScale2(self, **kwargs):
        res = _f.asQuery(self, modeling.alignCurve, kwargs, 'tangentScale2')
        return res

    @_f.addMelDocs('alignCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'caching', val)

    @_f.addMelDocs('alignCurve', 'curvatureContinuity')
    def setCurvatureContinuity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'curvatureContinuity', val)

    @_f.addMelDocs('alignCurve', 'curvatureScale1')
    def setCurvatureScale1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'curvatureScale1', val)

    @_f.addMelDocs('alignCurve', 'curvatureScale2')
    def setCurvatureScale2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'curvatureScale2', val)

    @_f.addMelDocs('alignCurve', 'joinParameter')
    def setJoinParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'joinParameter', val)

    @_f.addMelDocs('alignCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('alignCurve', 'positionalContinuity')
    def setPositionalContinuity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'positionalContinuity', val)

    @_f.addMelDocs('alignCurve', 'positionalContinuityType')
    def setPositionalContinuityType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'positionalContinuityType', val)

    @_f.addMelDocs('alignCurve', 'reverse1')
    def setReverse1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'reverse1', val)

    @_f.addMelDocs('alignCurve', 'reverse2')
    def setReverse2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'reverse2', val)

    @_f.addMelDocs('alignCurve', 'tangentContinuity')
    def setTangentContinuity(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'tangentContinuity', val)

    @_f.addMelDocs('alignCurve', 'tangentContinuityType')
    def setTangentContinuityType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'tangentContinuityType', val)

    @_f.addMelDocs('alignCurve', 'tangentScale1')
    def setTangentScale1(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'tangentScale1', val)

    @_f.addMelDocs('alignCurve', 'tangentScale2')
    def setTangentScale2(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.alignCurve, kwargs, 'tangentScale2', val)


class CloseCurve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.closeCurve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'closeCurve'
    __melnode__ = u'closeCurve'
    __slots__ = ()

    @_f.addMelDocs('closeCurve', 'blendBias')
    def getBlendBias(self, **kwargs):
        res = _f.asQuery(self, modeling.closeCurve, kwargs, 'blendBias')
        return res

    @_f.addMelDocs('closeCurve', 'blendKnotInsertion')
    def getBlendKnotInsertion(self, **kwargs):
        res = _f.asQuery(self, modeling.closeCurve, kwargs, 'blendKnotInsertion')
        return res

    @_f.addMelDocs('closeCurve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.closeCurve, kwargs, 'caching')
        return res

    @_f.addMelDocs('closeCurve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.closeCurve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('closeCurve', 'parameter')
    def getParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.closeCurve, kwargs, 'parameter')
        return res

    @_f.addMelDocs('closeCurve', 'preserveShape')
    def getPreserveShape(self, **kwargs):
        res = _f.asQuery(self, modeling.closeCurve, kwargs, 'preserveShape')
        return res

    @_f.addMelDocs('closeCurve', 'blendBias')
    def setBlendBias(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeCurve, kwargs, 'blendBias', val)

    @_f.addMelDocs('closeCurve', 'blendKnotInsertion')
    def setBlendKnotInsertion(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeCurve, kwargs, 'blendKnotInsertion', val)

    @_f.addMelDocs('closeCurve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeCurve, kwargs, 'caching', val)

    @_f.addMelDocs('closeCurve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeCurve, kwargs, 'nodeState', val)

    @_f.addMelDocs('closeCurve', 'parameter')
    def setParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeCurve, kwargs, 'parameter', val)

    @_f.addMelDocs('closeCurve', 'preserveShape')
    def setPreserveShape(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.closeCurve, kwargs, 'preserveShape', val)


class Bevel(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.bevel)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'bevel'
    __melnode__ = u'bevel'
    __slots__ = ()

    @_f.addMelDocs('bevel', 'bevelShapeType')
    def getBevelShapeType(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'bevelShapeType')
        return res

    @_f.addMelDocs('bevel', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'caching')
        return res

    @_f.addMelDocs('bevel', 'cornerType')
    def getCornerType(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'cornerType')
        return res

    @_f.addMelDocs('bevel', 'depth')
    def getDepth(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'depth')
        return res

    @_f.addMelDocs('bevel', 'extrudeDepth')
    def getExtrudeDepth(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'extrudeDepth')
        return res

    @_f.addMelDocs('bevel', 'joinSurfaces')
    def getJoinSurfaces(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'joinSurfaces')
        return res

    @_f.addMelDocs('bevel', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('bevel', 'numberOfSides')
    def getNumberOfSides(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'numberOfSides')
        return res

    @_f.addMelDocs('bevel', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('bevel', 'width')
    def getWidth(self, **kwargs):
        res = _f.asQuery(self, modeling.bevel, kwargs, 'width')
        return res

    @_f.addMelDocs('bevel', 'bevelShapeType')
    def setBevelShapeType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'bevelShapeType', val)

    @_f.addMelDocs('bevel', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'caching', val)

    @_f.addMelDocs('bevel', 'cornerType')
    def setCornerType(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'cornerType', val)

    @_f.addMelDocs('bevel', 'depth')
    def setDepth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'depth', val)

    @_f.addMelDocs('bevel', 'extrudeDepth')
    def setExtrudeDepth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'extrudeDepth', val)

    @_f.addMelDocs('bevel', 'joinSurfaces')
    def setJoinSurfaces(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'joinSurfaces', val)

    @_f.addMelDocs('bevel', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'nodeState', val)

    @_f.addMelDocs('bevel', 'numberOfSides')
    def setNumberOfSides(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'numberOfSides', val)

    @_f.addMelDocs('bevel', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'tolerance', val)

    @_f.addMelDocs('bevel', 'width')
    def setWidth(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.bevel, kwargs, 'width', val)


class Trim(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.trim)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'trim'
    __melnode__ = u'trim'
    __slots__ = ()

    @_f.addMelDocs('trim', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.trim, kwargs, 'caching')
        return res

    @_f.addMelDocs('trim', 'locatorU')
    def getLocatorU(self, **kwargs):
        res = _f.asQuery(self, modeling.trim, kwargs, 'locatorU')
        return res

    @_f.addMelDocs('trim', 'locatorV')
    def getLocatorV(self, **kwargs):
        res = _f.asQuery(self, modeling.trim, kwargs, 'locatorV')
        return res

    @_f.addMelDocs('trim', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.trim, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('trim', 'selected')
    def getSelected(self, **kwargs):
        res = _f.asQuery(self, modeling.trim, kwargs, 'selected')
        return res

    @_f.addMelDocs('trim', 'shrink')
    def getShrink(self, **kwargs):
        res = _f.asQuery(self, modeling.trim, kwargs, 'shrink')
        return res

    @_f.addMelDocs('trim', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.trim, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('trim', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.trim, kwargs, 'caching', val)

    @_f.addMelDocs('trim', 'locatorU')
    def setLocatorU(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.trim, kwargs, 'locatorU', val)

    @_f.addMelDocs('trim', 'locatorV')
    def setLocatorV(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.trim, kwargs, 'locatorV', val)

    @_f.addMelDocs('trim', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.trim, kwargs, 'nodeState', val)

    @_f.addMelDocs('trim', 'selected')
    def setSelected(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.trim, kwargs, 'selected', val)

    @_f.addMelDocs('trim', 'shrink')
    def setShrink(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.trim, kwargs, 'shrink', val)

    @_f.addMelDocs('trim', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.trim, kwargs, 'tolerance', val)


class TransformGeometry(AbstractBaseCreate):
    __melnode__ = u'transformGeometry'
    __slots__ = ()


class DetachSurface(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.detachSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'detachSurface'
    __melnode__ = u'detachSurface'
    __slots__ = ()

    @_f.addMelDocs('detachSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.detachSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('detachSurface', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.detachSurface, kwargs, 'direction')
        return res

    @_f.addMelDocs('detachSurface', 'keep')
    def getKeep(self, **kwargs):
        res = _f.asQuery(self, modeling.detachSurface, kwargs, 'keep')
        return res

    @_f.addMelDocs('detachSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.detachSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('detachSurface', 'parameter')
    def getParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.detachSurface, kwargs, 'parameter')
        return res

    @_f.addMelDocs('detachSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachSurface, kwargs, 'caching', val)

    @_f.addMelDocs('detachSurface', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachSurface, kwargs, 'direction', val)

    @_f.addMelDocs('detachSurface', 'keep')
    def setKeep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachSurface, kwargs, 'keep', val)

    @_f.addMelDocs('detachSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachSurface, kwargs, 'nodeState', val)

    @_f.addMelDocs('detachSurface', 'parameter')
    def setParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.detachSurface, kwargs, 'parameter', val)


class FitBspline(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.fitBspline)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'fitBspline'
    __melnode__ = u'fitBspline'
    __slots__ = ()

    @_f.addMelDocs('fitBspline', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.fitBspline, kwargs, 'caching')
        return res

    @_f.addMelDocs('fitBspline', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.fitBspline, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('fitBspline', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.fitBspline, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('fitBspline', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.fitBspline, kwargs, 'caching', val)

    @_f.addMelDocs('fitBspline', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.fitBspline, kwargs, 'nodeState', val)

    @_f.addMelDocs('fitBspline', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.fitBspline, kwargs, 'tolerance', val)


class BoundaryBase(AbstractBaseCreate):
    __melnode__ = u'boundaryBase'
    __slots__ = ()


class SquareSrf(BoundaryBase):
    __melnode__ = u'squareSrf'
    __slots__ = ()


class Boundary(BoundaryBase):
    __melcmd__ = staticmethod(modeling.boundary)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'boundary'
    __melnode__ = u'boundary'
    __slots__ = ()

    @_f.addMelDocs('boundary', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.boundary, kwargs, 'caching')
        return res

    @_f.addMelDocs('boundary', 'endPoint')
    def getEndPoint(self, **kwargs):
        res = _f.asQuery(self, modeling.boundary, kwargs, 'endPoint')
        return res

    @_f.addMelDocs('boundary', 'endPointTolerance')
    def getEndPointTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.boundary, kwargs, 'endPointTolerance')
        return res

    @_f.addMelDocs('boundary', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.boundary, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('boundary', 'order')
    def getOrder(self, **kwargs):
        res = _f.asQuery(self, modeling.boundary, kwargs, 'order')
        return res

    @_f.addMelDocs('boundary', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.boundary, kwargs, 'caching', val)

    @_f.addMelDocs('boundary', 'endPoint')
    def setEndPoint(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.boundary, kwargs, 'endPoint', val)

    @_f.addMelDocs('boundary', 'endPointTolerance')
    def setEndPointTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.boundary, kwargs, 'endPointTolerance', val)

    @_f.addMelDocs('boundary', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.boundary, kwargs, 'nodeState', val)

    @_f.addMelDocs('boundary', 'order')
    def setOrder(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.boundary, kwargs, 'order', val)


class Revolve(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.revolve)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'revolve'
    __melnode__ = u'revolve'
    __slots__ = ()

    @_f.addMelDocs('revolve', 'autoCorrectNormal')
    def getAutoCorrectNormal(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'autoCorrectNormal')
        return res

    @_f.addMelDocs('revolve', 'axis')
    def getAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'axis')
        return res

    @_f.addMelDocs('revolve', 'axisChoice')
    def getAxisChoice(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'axisChoice')
        return res

    @_f.addMelDocs('revolve', 'axisX')
    def getAxisX(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'axisX')
        return res

    @_f.addMelDocs('revolve', 'axisY')
    def getAxisY(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'axisY')
        return res

    @_f.addMelDocs('revolve', 'axisZ')
    def getAxisZ(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'axisZ')
        return res

    @_f.addMelDocs('revolve', 'bridge')
    def getBridge(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'bridge')
        return res

    @_f.addMelDocs('revolve', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'caching')
        return res

    @_f.addMelDocs('revolve', 'computePivotAndAxis')
    def getComputePivotAndAxis(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'computePivotAndAxis')
        return res

    @_f.addMelDocs('revolve', 'degree')
    def getDegree(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'degree')
        return res

    @_f.addMelDocs('revolve', 'endSweep')
    def getEndSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'endSweep')
        return res

    @_f.addMelDocs('revolve', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('revolve', 'pivot')
    def getPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'pivot')
        return res

    @_f.addMelDocs('revolve', 'pivotX')
    def getPivotX(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'pivotX')
        return res

    @_f.addMelDocs('revolve', 'pivotY')
    def getPivotY(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'pivotY')
        return res

    @_f.addMelDocs('revolve', 'pivotZ')
    def getPivotZ(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'pivotZ')
        return res

    @_f.addMelDocs('revolve', 'radius')
    def getRadius(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'radius')
        return res

    @_f.addMelDocs('revolve', 'radiusAnchor')
    def getRadiusAnchor(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'radiusAnchor')
        return res

    @_f.addMelDocs('revolve', 'sections')
    def getSections(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'sections')
        return res

    @_f.addMelDocs('revolve', 'startSweep')
    def getStartSweep(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'startSweep')
        return res

    @_f.addMelDocs('revolve', 'tolerance')
    def getTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'tolerance')
        return res

    @_f.addMelDocs('revolve', 'useLocalPivot')
    def getUseLocalPivot(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'useLocalPivot')
        return res

    @_f.addMelDocs('revolve', 'useTolerance')
    def getUseTolerance(self, **kwargs):
        res = _f.asQuery(self, modeling.revolve, kwargs, 'useTolerance')
        return res

    @_f.addMelDocs('revolve', 'autoCorrectNormal')
    def setAutoCorrectNormal(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'autoCorrectNormal', val)

    @_f.addMelDocs('revolve', 'axis')
    def setAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'axis', val)

    @_f.addMelDocs('revolve', 'axisChoice')
    def setAxisChoice(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'axisChoice', val)

    @_f.addMelDocs('revolve', 'axisX')
    def setAxisX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'axisX', val)

    @_f.addMelDocs('revolve', 'axisY')
    def setAxisY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'axisY', val)

    @_f.addMelDocs('revolve', 'axisZ')
    def setAxisZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'axisZ', val)

    @_f.addMelDocs('revolve', 'bridge')
    def setBridge(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'bridge', val)

    @_f.addMelDocs('revolve', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'caching', val)

    @_f.addMelDocs('revolve', 'computePivotAndAxis')
    def setComputePivotAndAxis(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'computePivotAndAxis', val)

    @_f.addMelDocs('revolve', 'degree')
    def setDegree(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'degree', val)

    @_f.addMelDocs('revolve', 'endSweep')
    def setEndSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'endSweep', val)

    @_f.addMelDocs('revolve', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'nodeState', val)

    @_f.addMelDocs('revolve', 'pivot')
    def setPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'pivot', val)

    @_f.addMelDocs('revolve', 'pivotX')
    def setPivotX(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'pivotX', val)

    @_f.addMelDocs('revolve', 'pivotY')
    def setPivotY(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'pivotY', val)

    @_f.addMelDocs('revolve', 'pivotZ')
    def setPivotZ(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'pivotZ', val)

    @_f.addMelDocs('revolve', 'radius')
    def setRadius(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'radius', val)

    @_f.addMelDocs('revolve', 'radiusAnchor')
    def setRadiusAnchor(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'radiusAnchor', val)

    @_f.addMelDocs('revolve', 'sections')
    def setSections(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'sections', val)

    @_f.addMelDocs('revolve', 'startSweep')
    def setStartSweep(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'startSweep', val)

    @_f.addMelDocs('revolve', 'tolerance')
    def setTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'tolerance', val)

    @_f.addMelDocs('revolve', 'useLocalPivot')
    def setUseLocalPivot(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'useLocalPivot', val)

    @_f.addMelDocs('revolve', 'useTolerance')
    def setUseTolerance(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.revolve, kwargs, 'useTolerance', val)


class InsertKnotSurface(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.insertKnotSurface)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'insertKnotSurface'
    __melnode__ = u'insertKnotSurface'
    __slots__ = ()

    @_f.addMelDocs('insertKnotSurface', 'addKnots')
    def getAddKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotSurface, kwargs, 'addKnots')
        return res

    @_f.addMelDocs('insertKnotSurface', 'caching')
    def getCaching(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotSurface, kwargs, 'caching')
        return res

    @_f.addMelDocs('insertKnotSurface', 'direction')
    def getDirection(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotSurface, kwargs, 'direction')
        return res

    @_f.addMelDocs('insertKnotSurface', 'insertBetween')
    def getInsertBetween(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotSurface, kwargs, 'insertBetween')
        return res

    @_f.addMelDocs('insertKnotSurface', 'nodeState')
    def getNodeState(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotSurface, kwargs, 'nodeState')
        return res

    @_f.addMelDocs('insertKnotSurface', 'numberOfKnots')
    def getNumberOfKnots(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotSurface, kwargs, 'numberOfKnots')
        return res

    @_f.addMelDocs('insertKnotSurface', 'parameter')
    def getParameter(self, **kwargs):
        res = _f.asQuery(self, modeling.insertKnotSurface, kwargs, 'parameter')
        return res

    @_f.addMelDocs('insertKnotSurface', 'addKnots')
    def setAddKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotSurface, kwargs, 'addKnots', val)

    @_f.addMelDocs('insertKnotSurface', 'caching')
    def setCaching(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotSurface, kwargs, 'caching', val)

    @_f.addMelDocs('insertKnotSurface', 'direction')
    def setDirection(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotSurface, kwargs, 'direction', val)

    @_f.addMelDocs('insertKnotSurface', 'insertBetween')
    def setInsertBetween(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotSurface, kwargs, 'insertBetween', val)

    @_f.addMelDocs('insertKnotSurface', 'nodeState')
    def setNodeState(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotSurface, kwargs, 'nodeState', val)

    @_f.addMelDocs('insertKnotSurface', 'numberOfKnots')
    def setNumberOfKnots(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotSurface, kwargs, 'numberOfKnots', val)

    @_f.addMelDocs('insertKnotSurface', 'parameter')
    def setParameter(self, val=True, **kwargs):
        return _f.asEdit(self, modeling.insertKnotSurface, kwargs, 'parameter', val)

class BezierCurveToNurbs(AbstractBaseCreate):
    __melcmd__ = staticmethod(modeling.bezierCurveToNurbs)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'bezierCurveToNurbs'
    __melnode__ = u'bezierCurveToNurbs'
    __slots__ = ()

class PointOnSurfaceInfo(AbstractBaseCreate):
    __melnode__ = u'pointOnSurfaceInfo'
    __slots__ = ()


class OldGeometryConstraint(DependNode):
    __melnode__ = u'oldGeometryConstraint'
    __slots__ = ()


class PrecompExport(DependNode):
    __melnode__ = u'precompExport'
    __slots__ = ()


class PairBlend(DependNode):
    __melcmd__ = staticmethod(animation.pairBlend)
    __melcmd_isinfo__ = False
    __melcmdname__ = u'pairBlend'
    __melnode__ = u'pairBlend'
    __slots__ = ()

    @_f.addMelDocs('pairBlend', 'input1')
    def getInput1(self, **kwargs):
        res = _f.asQuery(self, animation.pairBlend, kwargs, 'input1')
        return res

    @_f.addMelDocs('pairBlend', 'input2')
    def getInput2(self, **kwargs):
        res = _f.asQuery(self, animation.pairBlend, kwargs, 'input2')
        return res


class Time(DependNode):
    __melnode__ = u'time'
    __slots__ = ()


class HsvToRgb(DependNode):
    __melnode__ = u'hsvToRgb'
    __slots__ = ()


class CompactPlugArrayTest(DependNode):
    __melnode__ = u'compactPlugArrayTest'
    __slots__ = ()


class Resolution(DependNode):
    __melnode__ = u'resolution'
    __slots__ = ()


_addTypeNames()
