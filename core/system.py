
"""
Functions and classes relating to files, references, and system calls.

In particular, the system module contains the functionality of maya.cmds.file. The file command should not be imported into
the default namespace because it conflicts with python's builtin file class. Since the file command has so many flags, 
we decided to kill two birds with one stone: by breaking the file command down into multiple functions -- one for each 
primary flag -- the resulting functions are more readable and allow the file command's functionality to be used directly
within the pymel namespace.   

for example, instead of this:
    
    >>> expFile = cmds.file( exportAll=1, preserveReferences=1 )
    
you can do this:

    >>> expFile = exportAll( preserveReferences=1)
    
some of the new commands were changed slightly from their flag name to avoid name clashes and to add to readability:

    >>> importFile( expFile )  # flag was called import, but that's a python keyword
    >>> createReference( expFile )

Also, note that the 'type' flag is set automatically for you when your path includes a '.mb' or '.ma' extension.

"""


import pmcmds as cmds
#import maya.cmds as cmds
import maya.OpenMaya as OpenMaya

from pymel.util.decoration import decorator
import pymel.util as util
import factories as _factories
from factories import createflag, addMelDocs
import pymel.util as util
from pymel.mayahook import Version 
from pymel.util.scanf import fscanf
import logging
_logger = logging.getLogger(__name__)

import sys
try:
    from luma.filepath import filepath as Filepath
    pathClass = Filepath
except:
    pathClass = util.path


def _getTypeFromExtension( path ):
    return {
        '.ma' : 'mayaAscii',
        '.mb' :    'mayaBinary'
    }[Path(path).ext]


def feof( fileid ):
    """Reproduces the behavior of the mel command of the same name. if writing pymel scripts from scratch, 
    you should use a more pythonic construct for looping through files:
    
    >>> f = open('myfile.txt')
    >>> for line in f:
    >>>     print line
    
    This command is provided for python scripts generated by py2mel"""
    
    pos = fileid.tell()
    fileid.seek(0,2) # goto end of file
    end = fileid.tell() #get final position
    fileid.seek(pos)
    return pos == end


@addMelDocs( 'file', 'sceneName')
def sceneName():
    return Path( OpenMaya.MFileIO.currentFile() )    

def listNamespaces():
    """Returns a list of the namespaces of referenced files.
    REMOVE In Favor of listReferences('dict') ?""" 
    try:
        return [ cmds.file( x, q=1, namespace=1) for x in cmds.file( q=1, reference=1)  ]
    except:
        return []



#-----------------------------------------------
#  Workspace Class
#-----------------------------------------------

class WorkspaceEntryDict(object):
    def __init__(self, entryType):
        self.entryType = entryType
    def __getitem__(self, item):
        res = cmds.workspace( item, **{'q' : 1, self.entryType + 'Entry' : 1 } )
        if not res:
            raise KeyError, item
        return res
    def __setitem__(self, item, value):
        return cmds.workspace( **{self.entryType: [item, value] } )
    def __contains__(self, key):
        return key in self.keys()
    def items(self):    
        entries = util.listForNone( cmds.workspace( **{'q' : 1, self.entryType : 1 } ) )
        res = []
        for i in range( 0, len(entries), 2):
            res.append( (entries[i], entries[i+1] ) )
        return res
    def keys(self):    
        return cmds.workspace( **{'q' : 1, self.entryType + 'List': 1 } )
    def values(self):    
        entries = util.listForNone( cmds.workspace( **{'q' : 1, self.entryType : 1 } ) )
        res = []
        for i in range( 0, len(entries), 2):
            res.append( entries[i+1] )
        return res
    def get(self, item, default=None):
        try:
            return self.__getitem__(item)
        except KeyError:
            return default
    has_key = __contains__
        
    
class Workspace(object):
    """
    This class is designed to lend more readability to the often confusing workspace command.
    The four types of workspace entries (objectType, fileRule, renderType, and variable) each
    have a corresponding dictiony for setting and accessing these mappings.
    
        >>> from pymel import *
        >>> workspace.renderTypes['audio']
        sound
        >>> workspace.renderTypes.keys()
        [u'3dPaintTextures', u'audio', u'clips', u'depth', u'images', u'iprImages', u'lights', u'mentalRay', u'particles', u'renderScenes', u'sourceImages', u'textures']
        >>> 'DXF' in workspace.fileRules
        True
        >>> workspace.fileRules['DXF']
        data
        >>> workspace.fileRules['super'] = 'data'
        >>> workspace.fileRules.get( 'foo', 'data' )
        data
        
    the workspace dir can be confusing because it works by maintaining a current working directory that is persistent
    between calls to the command.  In other words, it works much like the unix 'cd' command, or python's 'os.chdir'.
    In order to clarify this distinction, the names of these flags have been changed in their class method counterparts
    to resemble similar commands from the os module.
    
    old way (still exists for backward compatibility)
        >>> workspace(edit=1, dir='mydir')
        >>> workspace(query=1, dir=1)
        >>> workspace(create='mydir')
    
    new way    
        >>> workspace.chdir('mydir')
        >>> workspace.getcwd()    
        >>> workspace.mkdir('mydir')
    
    All paths are returned as an pymel.core.system.Path class, which makes it easy to alter or join them on the fly.    
        >>> workspace.path / workspace.fileRules['DXF']
        /Users/chad/Documents/maya/projects/default/path
        
    """
    __metaclass__ = util.Singleton
    
    objectTypes = WorkspaceEntryDict( 'objectType' )
    fileRules     = WorkspaceEntryDict( 'fileRule' )
    renderTypes = WorkspaceEntryDict( 'renderType' )
    variables     = WorkspaceEntryDict( 'variable' )
    
    def __init__(self):
        self.objectTypes = WorkspaceEntryDict( 'objectType' )
        self.fileRules     = WorkspaceEntryDict( 'fileRule' )
        self.renderTypes = WorkspaceEntryDict( 'renderType' )
        self.variables     = WorkspaceEntryDict( 'variable' )
    
    @classmethod
    def open(self, workspace):
        return cmds.workspace( workspace, openWorkspace=1 )
    @classmethod
    def save(self):
        return cmds.workspace( saveWorkspace=1 )
    @classmethod
    def update(self):
        return cmds.workspace( update=1 )
    @classmethod
    def new(self, workspace):
        return cmds.workspace( workspace, newWorkspace=1 )        
    @classmethod
    def getName(self):
        return cmds.workspace( q=1, act=1 )

    @classmethod
    def getPath(self):
        return Path(cmds.workspace( q=1, fullpath=1 ))
    
    @classmethod
    def chdir(self, newdir):
        return cmds.workspace( dir=newdir )
    @classmethod
    def getcwd(self):
        return Path(cmds.workspace( q=1, dir=1 ))
    @classmethod
    def mkdir(self, newdir):
        return cmds.workspace( cr=newdir )

    name = property( lambda x: cmds.workspace( q=1, act=1 ) )        
    path = property( lambda x: Path(cmds.workspace( q=1, fullpath=1 ) ) )
            
    def __call__(self, *args, **kwargs):
        """provides backward compatibility with cmds.workspace by allowing an instance
        of this class to be called as if it were a function"""
        return cmds.workspace( *args, **kwargs )

workspace = Workspace()

#-----------------------------------------------
#  FileInfo Class
#-----------------------------------------------

class FileInfo( object ):
    """
    store and get custom data specific to this file:
    
        >>> fileInfo['lastUser'] = env.user()
        
    if the python structures have valid __repr__ functions, you can
    store them and reuse them later:
    
        >>> fileInfo['cameras'] = str( ls( cameras=1) )
        >>> camList = eval(fileInfo['cameras'])
        >>> camList[0]
        # Result: frontShape #
        >>> camList[0].getFocalLength()  # it's still a valid pymel class
        # Result: 35.0 #
    
    for backward compatibility it retains it's original syntax as well:
        
        >>> fileInfo( 'myKey', 'myData' )
        
    """
    __metaclass__ = util.Singleton
    
    def __contains__(self, item):
        return item in self.keys()
        
    def __getitem__(self, item):
        return dict(self.items())[item]
        
    def __setitem__(self, item, value):
        cmds.fileInfo( item, value )
    
    def __call__(self, *args, **kwargs):
        if kwargs.get('query', kwargs.get('q', False) ):
            return self.items()
        else:
            cmds.fileInfo( *args, **kwargs )
            
    def items(self):
        res = cmds.fileInfo( query=1)
        newRes = []
        for i in range( 0, len(res), 2):
            newRes.append( (res[i], res[i+1]) )
        return newRes
        
    def keys(self):
        res = cmds.fileInfo( query=1)
        newRes = []
        for i in range( 0, len(res), 2):
            newRes.append(  res[i] )
        return newRes
            
    def values(self):
        res = cmds.fileInfo( query=1)
        newRes = []
        for i in range( 0, len(res), 2):
            newRes.append( res[i+1] )
        return newRes
    
    def pop(self, *args):
        if len(args) > 2:
            raise TypeError, 'pop expected at most 2 arguments, got %d' % len(args)
        elif len(args) < 1:
            raise TypeError, 'pop expected at least 1 arguments, got %d' % len(args)
        
        if args[0] not in self.keys():
            try:
                return args[1]
            except IndexError:
                raise KeyError, args[0]
                    
        cmds.fileInfo( rm=args[0])
    
    has_key = __contains__    
fileInfo = FileInfo()



#-----------------------------------------------
#  File Classes
#-----------------------------------------------
    
class Path(pathClass):
    """A basic Maya file class. it gets most of its power from the path class written by Jason Orendorff.
    see path.py for more documentation."""
    def __repr__(self):
        return "%s('%s')" % (self.__class__.__name__, self)
    
    getTypeName = _factories.makeQueryFlagMethod( cmds.file, 'type' )
    setSubType = _factories.makeQueryFlagMethod( cmds.file, 'subType', 'setSubType')
   
class CurrentFile(Path):
    getRenameToSave = classmethod( _factories.makeQueryFlagMethod( cmds.file, 'renameToSave', 'getRenameToSave'))
    setRenameToSave = classmethod( _factories.makeCreateFlagMethod( cmds.file, 'renameToSave', 'setRenameToSave'))
    anyModified = classmethod( _factories.makeQueryFlagMethod( cmds.file, 'anyModified'))
    @classmethod
    @addMelDocs( 'file', 'lockFile')
    def lock(self):
        return cmds.file( lockFile=True)
    
    @classmethod
    @addMelDocs( 'file', 'lockFile')
    def unlock(self):
        return cmds.file( lockFile=False)  
    isModified = classmethod( _factories.makeQueryFlagMethod( cmds.file, 'modified', 'isModified'))
    setModified = classmethod( _factories.makeCreateFlagMethod( cmds.file, 'modified', 'setModified'))
    
    isWritableInScene = _factories.makeQueryFlagMethod( cmds.file, 'writable' )
    @classmethod
    @addMelDocs( 'file', 'sceneName')
    def name(self):
        return Path( OpenMaya.MFileIO.currentFile() ) 



  
        
#===============================================================================
# FileReference
#===============================================================================



def listReferences(type='list'):
    """file -q -reference
    By default returns a list of reference files as FileReference classes. The optional type argument can be passed a 'dict'
    (or dict object) to return the references as a dictionary with namespaces as keys and References as values.
    
    Untested: multiple references with no namespace...
    """
    
    # dict
    if type in ['dict', dict]:
        res = {}
        try:
            for x in cmds.file( q=1, reference=1):
                res[cmds.file( x, q=1, namespace=1)] = FileReference(x)
        except: pass
        return res
    
    # list
    return map( FileReference,cmds.file( q=1, reference=1) )

def iterReferences( parentReference=None, recursive=True, namespaces=True, refNodes=False, references=True ):
    """
    returns references in the scene as a list of value tuples. the values in the tuples can be namespaces, refNodes (as PyNodes),
    and/or references (as FileReferences)
    
    :param parentReference: a reference to get sub-references from. If None (default), the current scene is used.
    :type parentReference: string, `Path`, or `FileReference`
    
    :param recursive: recursively determine all references and sub-references
    :type recursive: bool
    
    """
    import general
    import other
#    if asDict:
#        assert not (namespaces and refNodes)
        
    res = []   
    if parentReference is None:
        refs = zip( cmds.file( q=1, reference=1), cmds.file( q=1, reference=1, unresolvedName=1) )
    else:
        refs = zip( cmds.file( parentReference, q=1, reference=1), cmds.file( parentReference, q=1, reference=1, unresolvedName=1) )
    #print "reference", parentReference
    for ref, unresolvedRef in refs:
        row = []
        
        refNode = cmds.file( ref, q=1, referenceNode=1) 
        refNode = general.PyNode( refNode )
        
        if namespaces:
            row.append( refNode.namespace() + cmds.file( ref, q=1, namespace=1)  )
        if refNodes:
            row.append( refNode )
        if references:
            row.append( FileReference(refNode) )
        #print "yielding"
        yield tuple(row)
        if recursive:
            for x in iterReferences(parentReference=ref, recursive=True, namespaces=namespaces, refNodes=refNodes, references=references):
                #print "yield sub"
                yield x
        #print "for done"
    #print "done"


#def getReferences( reference=None, recursive=False, namespaces=True, refNodes=False, asDict=True ):
#    """
#    returns references in the scene as (namespace, FileReference) pairs
#    
#    :param reference: a reference to get sub-references from. If None (default), the current scene is used.
#    :type reference: string, `Path`, or `FileReference`
#    
#    :param recursive: recursively determine all references and sub-references
#    :type recursive: bool
#    
#    """
#    import general
#    import other
##    if asDict:
##        assert not (namespaces and refNodes)
#        
#    res = []   
#    if reference is None:
#        refs = zip( cmds.file( q=1, reference=1), cmds.file( q=1, reference=1, unresolvedName=1) )
#    else:
#        refs = zip( cmds.file( reference, q=1, reference=1), cmds.file( reference, q=1, reference=1, unresolvedName=1) )
#        
#    for ref, unresolvedRef in refs:
#        row = []
#        print ref, cmds.file( ref, q=1, namespace=1)
#        refNode = cmds.file( ref, q=1, referenceNode=1) 
#        
#        fileRef = FileReference(ref, unresolvedPath=unresolvedRef)
#        if namespaces:
#            row.append( other.DependNodeName( refNode ).namespace() + cmds.file( ref, q=1, namespace=1)  )
#        if refNodes:
#            row.append( general.PyNode( refNode ) )
#        row.append( fileRef )
#        res.append( row ) 
#        if recursive:
#            res += getReferences(reference=ref, recursive=True, namespaces=namespaces, refNodes=refNodes)
#
#    return res

def getReferences(parentReference=None, recursive=False):
    return dict( iterReferences( parentReference=parentReference, recursive=recursive, namespaces=True, refNodes=False ) )

@decorator
def suspendReferenceUpdates(func):
    def suspendedRefUpdateFunc(*args, **kw):
        ReferenceCache.deferReferenceUpdates(True)
        try:
            ret = func(*args, **kw)
        finally:
            ReferenceCache.deferReferenceUpdates(False)
        return ret
    return suspendedRefUpdateFunc
    
class ReferenceCache(object):
    """
    For the sake of speeding up the process of identifying File References in the scene
    and properly associating with their respective namespace/reference-node/fullpath,
    a set of API callbacks is set-up which triggers a file-reference cache refresh.
    
    This callback mechanism can be suspended temporarily, which is useful when a process
    needs to change the state of several references at once (loading/unloading, adding/removing).
    Use the 'deferReferenceUpdates' function or the 'suspendReferenceUpdates' decorator
    """
    
    _deferReferenceUpdates = False
    _callbacks = []
    _allFiles = []
    byNamespace = {}
    byRefNode = {}
    byFullPath = {}
    callbacksEnabled = False
    
    @classmethod
    def deferReferenceUpdates(cls, state):
        logging.debug("%s Reference Updates" % ("SUSPENDING " if state else "Enabling"))
        cls._deferReferenceUpdates = state
    
    
    @classmethod
    def refresh(cls):

        import general
        import other
        
        cls.byNamespace.clear()
        cls.byRefNode.clear()
        cls.byFullPath.clear()
    
        def getRefs(reference=None, currNamespace='' ):
            res = []
            args = []
            if reference is not None:
                args.append(reference)

            resolved = cmds.file(  q=1, reference=1, *args )
            unresolved = cmds.file( q=1, reference=1, unresolvedName=1, *args ) 

            assert len(resolved) == len(unresolved)
                     
            for ref, unresolvedRef in zip( resolved, unresolved ):
                row = []
                # we cannot reliably get refNode in a nested reference scenario, but it's ok
                # we can get the refFile directly from refNode using MFileIO.getReferenceFileByNode()
                # so there's no real need to keep a dictionary
                
                namespace = cmds.file( ref, q=1, namespace=1)
                fullNamespace = currNamespace + namespace
                row.append( ref )
                row.append( unresolvedRef )
                #row.append( refNode )
                res.append( row ) 
                row.append( fullNamespace )
                
                res += getRefs(ref, fullNamespace + ':' )
        
            return res

        refData = getRefs()
        _logger.info("Refreshing %s references..." % len(refData))

        for path, unresolvedPath, namespace in refData:

            #fr = ( fullpath, unresolvedPath )
            
            _logger.debug("Found %s" % path)
            #refNode = general.PyNode( refNode )
            data = ( path, unresolvedPath )
            # The FileReference Object is inserted into the dictionray under multiple keys 
            # so that it can be easily found using a full-namespace, a reference-node name, or a filepath
            cls.byNamespace[namespace] = data
            #cls.byRefNode[refNode] = data
            cls.byFullPath[path.replace("/","\\")] = data
            cls.byFullPath[path.replace("\\","/")] = data
    
    @classmethod
    def _getAllFileReferences(cls):
        ret =  [v for (k,v) in cls.byNamspace.iteritems() ]
        if not ret:
            cls.refresh()
            ret =  [v for (k,v) in cls.byNamspace.iteritems()]
        return ret
            
    @classmethod
    def setupFileReferenceCallbacks(cls):
        cls.callbacksEnabled = True
        
        def refererencesUpdated(*args):
            if cls._deferReferenceUpdates:
                return
            cls.refresh()
        
        messages = ['kAfterReference', 'kAfterRemoveReference', 'kAfterImportReference', 'kAfterExportReference', 'kSceneUpdate']
        for msg in messages:
            _logger.debug("Setting up File-Reference Callback: %s" % msg)
            cb = OpenMaya.MSceneMessage.addCallback(getattr(OpenMaya.MSceneMessage,msg), refererencesUpdated, None)
            cb.disown()     # suppresses those swig 'memory leak' warnings
            cls._callbacks.append(cb)

    @classmethod
    def getPaths(cls, path=None, namespace=None):
        
        # there's no guarantee that:
        #  the namespace has not changed since the last cache refresh
        #  the refNode has not been renamed since the last cache refresh (doesn't matter if we're using > 2009, where node hashing is not based on name)
        if not cls.callbacksEnabled or namespace: # or ( refnode and Version.current < Version.v2009 ):
            # force refresh (only need to try once)
            attempts=1
            cls.refresh()
        else:
            # try twice (refresh if failed the first time)
            attempts = 2
            
        while attempts:
            try:
                if path:
                    resolvedPath, unresolvedPath = cls.byFullPath[path]
#                elif refnode:
#                    refnode = general.PyNode(refnode)
#                    data = ReferenceCache.byRefNode[refnode]
                elif namespace:
                    resolvedPath, unresolvedPath = cls.byNamespace[namespace]
                
                return resolvedPath, unresolvedPath               
            except KeyError:
                attempts -= 1
                if attempts:
                    ReferenceCache.refresh()
        raise ValueError("Could not find FileReference (args: %s)" % [path, namespace])    

class FileReference(object):
    """
    A class for manipulating references which inherits Path and path.  you can create an 
    instance by supplying the path to a reference file, its namespace, or its reference node to the 
    appropriate keyword. The namespace and reference node of the reference can be retreived via 
    the namespace and refNode properties. The namespace property can also be used to change the namespace
    of the reference. 
    
    Use listRefences command to return a list of references as instances of the FileReference class.
    
    It is important to note that instances of this class will have their copy number stripped off
    and stored in an internal variable upon creation.  This is to maintain compatibility with the numerous methods
    inherited from the path class which requires a real file path. When calling built-in methods of FileReference, 
    the path will automatically be suffixed with the copy number before being passed to maya commands, thus ensuring 
    the proper results in maya as well. 
    """


    def __init__(self, pathOrRefNode=None, namespace=None, refnode=None, unresolvedPath=None):
        import general
        self._refNode = None
        if pathOrRefNode:
            if isinstance(pathOrRefNode, basestring) and '.' in pathOrRefNode:
                self._refNode = general.PyNode( cmds.referenceQuery( pathOrRefNode, referenceNode=1 ) )
            elif isinstance( pathOrRefNode, general.Reference ):
                self._refNode = pathOrRefNode
            else:
                self._refNode = general.PyNode( pathOrRefNode )
            
        elif namespace:
            namespace = namespace.rstrip(':')
            for iNamespace, iRefNode in iterReferences(namespaces=True, recursive=True, refNodes=True, references=False): 
                if namespace == iNamespace:
                    self._refNode = iRefNode
                    break
            if self._refNode is None:
                raise "Could not find a reference with the namespace %r" % namespace
            
        elif refnode:
            self._refNode = general.PyNode( refnode )
        
        assert self._refNode.type() == 'reference'
        
#        def create(path, unresolvedPath ):
#            """Actually create the FileReference object"""
#            def splitCopyNumber(path):
#                """Return a tuple with the path and the copy number. Second element will be None if no copy number"""
#                buf = path.split('{')
#                try:
#                    return ( buf[0], int(buf[1][:-1]) )
#                except:
#                    return (path, None)
#                    
#            path, copyNumber = splitCopyNumber(path)
#            unresolvedPath, copyNumber2 = splitCopyNumber(unresolvedPath)
#            assert copyNumber == copyNumber2, "copy number of %s is not the same as %s" % ( path, unresolvedPath )
#            self._file = Path(path)
#            self._copyNumber = copyNumber
#            self._unresolvedPath = Path(unresolvedPath)
#            #self._refNode = refNode
#            #return self
#
#        # Direct mappings:
#        # refNode --> refFile:  MFileIO.getReferenceFileByNode( refNode )
#        # refFile --> refNode:  cmds.file( refFile, q=1, referenceNode=1)
#        # refFile --> namespace:  refNode.namespace() + cmds.file( refFile, q=1, namespace=1)
#        self._refNode = None   
#        
#        import general
#        if unresolvedPath:
#            # check to ensure it's legit
#            assert path in ReferenceCache.byFullPath,  "%s is not a valid reference file" % path
#            return create(path, unresolvedPath)
#        
#        if refnode:
#            refNode = general.PyNode(refnode)
#            self._refNode = refNode
#            # refNode is all we need for now. we can get anything else from this when it is asked for
#            return
#
#            
#        
#        resolvedPath, unresolvedPath = ReferenceCache.getPaths( path, namespace )
#        create( resolvedPath, unresolvedPath )
        
        
   
    def __melobject__(self):
        return self.withCopyNumber()
    
    def __repr__(self):
        return u'%s(%r)' % ( self.__class__.__name__, self.withCopyNumber() )
    
    def subReferences(self):
        namespace = self.namespace + ':'
        res = {}
        for x in cmds.file( self, q=1, reference=1):
            try:
                res[namespace + cmds.file( x, q=1, namespace=1)] = FileReference(x)
            except Exception, e:
                mel.warning("Could not get namespace for '%s': %s" % (x,e))  
        return res  
        
    @addMelDocs('namespace', 'exists')    
    def namespaceExists(self):
        return cmds.namespace(ex=self.namespace)
     
    def path(self):
        # TODO: check in cache to see if this has changed
#        if not ReferenceCache.callbacksEnabled or Version.current < Version.v2009:
#            ReferenceCache.refresh()
#            
#        return ReferenceCache[ self.refNode ]._file
        
        #path = self.withCopyNumber().split('{')[0]
        path = cmds.referenceQuery( self.refNode, filename=1, withoutCopyNumber=1 )
        return Path(path)
     
    def withCopyNumber(self):
        """return the with the copy number at the end"""
        # the file path is subject to change
        path = cmds.referenceQuery( self.refNode, filename=1 )
        return path
        
#        if self._copyNumber is not None:
#            return u'%s{%d}' % (self.path(), self._copyNumber)
#        return unicode( self.path() )
    
    def unresolvedPath(self):
        path = cmds.referenceQuery( self.refNode, filename=1, unresolvedName=1, withoutCopyNumber=1 )
        return Path(path)
        
#    @createflag('file', 'importReference')
#    def importContents(self, **kwargs):
#        return cmds.file( self.withCopyNumber(), **kwargs )

    @addMelDocs('file', 'importReference')
    def importContents(self):
        return cmds.file( rfn=self.refNode, importReference=1 )
      
#    @createflag('file', 'removeReference')
#    def remove(self, **kwargs):
#        return cmds.file( self.withCopyNumber(), **kwargs )

    @addMelDocs('file', 'removeReference')
    def remove(self):
        return cmds.file( rfn=self.refNode, removeReference=1 )
           
#    @addMelDocs('file', 'unloadReference')
#    def unload(self):
#        return cmds.file( self.withCopyNumber(), unloadReference=1 )

    @addMelDocs('file', 'unloadReference')
    def unload(self):
        return cmds.file( rfn=self.refNode, unloadReference=1 )
       
    @addMelDocs('file', 'loadReference')
    def load(self, newFile=None, **kwargs):
        if not newFile:
            args = ()
        else:
            args = (newFile,)
        return cmds.file( loadReference=self.refNode,*args, **kwargs )
    
    @addMelDocs('file', 'loadReference')
    def replaceWith(self, newFile):
        return self.load(newFile)   
    
    @addMelDocs('file', 'cleanReference')
    def clean(self, **kwargs):
        return cmds.file( cleanReference=self.refNode, **kwargs )
    
    @addMelDocs('file', 'lockReference')
    def lock(self):
        return cmds.file( self.withCopyNumber(), lockReference=1 )
    
    @addMelDocs('file', 'lockReference')
    def unlock(self):
        return cmds.file( self.withCopyNumber(), lockReference=0 )
    
#    @addMelDocs('file', 'deferReference')     
#    def isDeferred(self):
#        return cmds.file( self.withCopyNumber(), q=1, deferReference=1 )

    @addMelDocs('file', 'deferReference')     
    def isDeferred(self):
        return cmds.file( rfn=self.refNodes, q=1, deferReference=1 )

#    @addMelDocs('file', 'deferReference')
#    def isLoaded(self):
#        return not cmds.file( self.withCopyNumber(), q=1, deferReference=1 )

          
    @addMelDocs('file', 'deferReference')
    def isLoaded(self):
        return not cmds.file( rfn=self.refNode, q=1, deferReference=1 )
        
    @addMelDocs('referenceQuery', 'nodes')
    def nodes(self):
        import general
        return map( general.PyNode, cmds.referenceQuery( self.refNode, nodes=1, dagPath=1 ) )
    
    @addMelDocs('file', 'copyNumberList')
    def copyNumberList(self):
        """returns a list of all the copy numbers of this file"""
        return cmds.file( self, q=1, copyNumberList=1 )
      
    @addMelDocs('file', 'selectAll')
    def selectAll(self):
        return cmds.file( self.withCopyNumber(), selectAll=1 )
    
    def _getNamespace(self):
        return cmds.file( self.withCopyNumber(), q=1, ns=1)
    
    def _setNamespace(self, namespace):
        return cmds.file( self.withCopyNumber(), e=1, ns=namespace)    
    
    namespace = property(_getNamespace, _setNamespace)

    @property
    def fullNamespace(self):
        return "%s%s" % (self.refNode.namespace(), self.namespace)
    
    def _getRefNode(self):
        # since the refNode is a PyNode, it's name will reflect any renames performed on the node
#        if self._refNode is None:
#            try:
#                import general
#                self._refNode = general.PyNode( cmds.referenceQuery( self.withCopyNumber(), referenceNode=1 ) )
#            except RuntimeError:
#                pass
        return self._refNode
        
    refNode = property( _getRefNode, '_refNode')
    
    @addMelDocs('file', 'usingNamespaces')
    def isUsingNamespaces(self):
        return cmds.file( self.withCopyNumber(), q=1, usingNamespaces=1 )

    @addMelDocs('file', 'exportAnimFromReference')    
    def exportAnim( self, exportPath, **kwargs ):
        if 'type' not in kwargs:
            try: kwargs['type'] = _getTypeFromExtension(exportPath)
            except: pass
        return Path(cmds.file( exportPath, rfn=self.refNode, exportAnimFromReference=1))
          
    @addMelDocs('file', 'exportSelectedAnimFromReference')    
    def exportSelectedAnim( self, exportPath, **kwargs ):
        if 'type' not in kwargs:
            try: kwargs['type'] = _getTypeFromExtension(exportPath)
            except: pass
        return Path(cmds.file( exportPath, rfn=self.refNode, exportSelectedAnimFromReference=1))


    def getReferenceEdits(self, **kwargs):
        """referenceQuery -editString -onReferenceNode <self.refNode>"""
          
        kwargs.pop('editStrings',None)
        kwargs.pop('es',None)
        edits = referenceQuery(self.refNode, editStrings=True, onReferenceNode=self.refNode, **kwargs)
        return edits
    
    def removeReferenceEdits(self, editCommand=None, force=False):
        """Remove edits from the reference.
        @param editCommand: If specified, remove only edits of a particular type: addAttr, setAttr, connectAttr, disconnectAttr or parent
        @param force: Unload the reference if it is not unloaded already
        """

        if self.isLoaded():
            self.unload()
        
        kwargs = {}
        if editCommand:
            kwargs['editCommand'] = editCommand
        cmds.file(cleanReference=self.refNode, **kwargs)


def referenceQuery(*args, **kwargs):
    """When queried for 'es/editStrings', returned a list of ReferenceEdit objects"""
    if kwargs.get("editStrings", kwargs.get("es")):
        from general import PyNode, MayaNodeError
        
        try:
            target = PyNode(args[0])
            if target.type()=='reference':
                fr = FileReference(refnode=target)
            else:
                fr = target.referenceFile()
        except MayaNodeError:
            target = path(target)
            if target.isfile():
                fr = FileReference(path=target)
                
        failedEdits = kwargs.pop('failedEdits', kwargs.pop('fld', None))
        successfulEdits = kwargs.pop('successfulEdits', kwargs.pop('scs', None))
        modes = []
        if failedEdits is None and successfulEdits is None:
            modes = [True, False]
        else:
            if failedEdits:     modes.append(False)
            if successfulEdits: modes.append(True)
                    
        allEdits = []
        for mode in modes:
            edits = cmds.referenceQuery(fr,
                                        failedEdits = not mode, 
                                        successfulEdits = mode, 
                                        **kwargs)
            allEdits.extend(ReferenceEdit(edit, fr, mode) for edit in edits)
        return allEdits
    else:
        return cmds.referenceQuery(*args, **kwargs)

import general, other

def _safeEval(s):
    try:
        return eval(s)
    except:
        return s

def _safePyNode(n):
    try:
        return general.PyNode(_safeEval(n))
    except:
        if "." in n:
            return other.AttributeName(n)
        else:
            return other.DependNodeName(n)

class ReferenceEdit(str):
    """
    Parses a reference edit command string into various components based on the edit type.
    This is the class returned by pymel's version of the 'referenceQuery' command.
    """
      
    def __new__(cls, editStr, fileReference=None, successful=None):

        self = str.__new__(cls, editStr)
        
        self.type = self.split()[0]
        self.fileReference = fileReference
        self.namespace = fileReference and self.fileReference.namespace
        self.fullNamespace = fileReference and self.fileReference.fullNamespace
        self.successful = successful
        return self

    def _getEditData(self):
        """
        Returns a dictionary with the relevant data for this reference edit. 
        Each edit type will have a different set of keys.
        """
        if self.fileReference:
            def _safeRefPyNode(n):
                n = _safePyNode(_safeEval(n))
                if self.namespace in n:
                    ns = self.fileReference.refNode.namespace()
                    if not ns==":":
                        n = n.addPrefix(ns)
                return n
        else:
            def _safeRefPyNode(n):
                return _safePyNode(_safeEval(n))
        
        import pymel.tools.mel2py as mel2py
        pyCmd = "".join(mel2py.mel2pyStr(self + ";").splitlines()[1:])  # chop off the 'import pymel' line
        args, kwargs = eval("dummy" + "".join(pyCmd.partition("(")[1:]), {}, dict(dummy=lambda *x,**y: (x, y)))

        elements = self.split()
        elements.pop(0)
        editData = {}
        if self.type=="addAttr":
            editData['node'] = _safeRefPyNode(elements.pop(-1))
            editData['attribute'] = elements.pop(1)
        elif self.type=="setAttr":
            editData['node'] = _safeRefPyNode(elements.pop(0))
            editData['value'] = " ".join(elements)
        elif self.type=="parent":
            editData['node'] = _safeRefPyNode(elements.pop(-1))
            if elements[-1]=="-w":
                editData['child'] = '<World>'
            else:
                editData['child'] = _safePyNode(elements.pop(-1))
        elif self.type=="disconnectAttr":
            if elements[0].startswith("-"):
                elements.append(elements.pop(0))
            refNode, otherNode = map(_safeRefPyNode, elements[:2])
            editData['sourceNode'] = refNode
            editData['targetNode'] = otherNode
            otherNode, refNode = sorted([otherNode, refNode], key=lambda  n: self.namespace in n)
            editData['node'] = refNode
            del elements[:2]
        elif self.type=="connectAttr":
            if elements[0].startswith("-"):
                elements.append(elements.pop(0))
            refNode, otherNode = map(_safeRefPyNode, elements[:2])
            editData['sourceNode'] = refNode
            editData['targetNode'] = otherNode
            otherNode, refNode = sorted([otherNode, refNode], key=lambda  n: self.namespace in n)
            editData['node'] = refNode
            del elements[:2]
        else:
            editData['node'] = _safeRefPyNode(elements.pop(0))
        editData['parameters'] = map(str, elements)
        
        editData['args'] = args
        editData['kwargs'] = kwargs
        
        return editData
    
    def remove(self, force=False):
        """Remove the reference edit. if 'force=True' then the reference will be unloaded from the scene (if it is not already unloaded)"""
        if self.fileReference.isLoaded():
            if not force:
                raise Exception("Cannon remove edits while reference '%s' is loaded. Unload the reference first, or use the 'force=True' flag." % self.fileReference)
            self.fileReference.unload()
        cmds.referenceEdit(self.editData['node'], removeEdits=True, successfulEdits=True, failedEdits=True, editCommand=self.type)

    editData = util.cacheProperty(_getEditData,"_editData") 


# TODO: anyModified, modified, errorStatus, executeScriptNodes, lockFile, lastTempFile, renamingPrefixList, renameToSave ( api : mustRenameToSave )
# From API: isReadingFile, isWritingFile, isOpeningFile, isNewingFile, isImportingFile


@createflag('file', 'reference')
def createReference( *args, **kwargs ):
    return FileReference(cmds.file(*args, **kwargs))

@createflag('file', 'loadReference')
def loadReference( file, refNode, **kwargs ):
    return FileReference(cmds.file(file, **kwargs))

@createflag('file', 'exportAll')    
def exportAll( exportPath, **kwargs ):
    if 'type' not in kwargs:
        try: kwargs['type'] = _getTypeFromExtension(exportPath)
        except: pass  
    return Path(cmds.file(*args, **kwargs))

@createflag('file', 'exportAsReference')
def exportAsReference( exportPath, **kwargs ):
    if 'type' not in kwargs:
        try: kwargs['type'] = _getTypeFromExtension(exportPath)
        except: pass
    return FileReference(cmds.file(*args, **kwargs))

@createflag('file', 'exportSelected')
def exportSelected( exportPath, **kwargs ):
    if 'type' not in kwargs:
        try: kwargs['type'] = _getTypeFromExtension(exportPath)
        except: pass
    return Path(cmds.file(exportPath, **kwargs))

@createflag('file', 'exportAnim')
def exportAnim( exportPath, **kwargs ):
    if 'type' not in kwargs:
        try: kwargs['type'] = _getTypeFromExtension(exportPath)
        except: pass
    return Path(cmds.file(exportPath, **kwargs))

@createflag('file', 'exportSelectedAnim')
def exportSelectedAnim( exportPath, **kwargs ):
    if 'type' not in kwargs:
        try: kwargs['type'] = _getTypeFromExtension(exportPath)
        except: pass
    return Path(cmds.file(exportPath, **kwargs))

@addMelDocs('file', 'exportAnimFromReference')    
def exportAnimFromReference( exportPath, **kwargs ):
    if 'type' not in kwargs:
        try: kwargs['type'] = _getTypeFromExtension(exportPath)
        except: pass
    return Path(cmds.file( *args, **kwargs))
      
@addMelDocs('file', 'exportSelectedAnimFromReference')    
def exportSelectedAnimFromReference( exportPath, **kwargs ):
    if 'type' not in kwargs:
        try: kwargs['type'] = _getTypeFromExtension(exportPath)
        except: pass
    return Path(cmds.file( *args, **kwargs))
    
@createflag('file', 'i')
def importFile( *args, **kwargs ):
    return Path(cmds.file(*args, **kwargs))

@createflag('file', 'newFile')
def newFile( *args, **kwargs ):
    return Path(cmds.file(*args, **kwargs))

@createflag('file', 'open')
def openFile( *args, **kwargs ):
    return Path(cmds.file(*args, **kwargs))    

@addMelDocs('file', 'rename')
def renameFile( *args, **kwargs ):
    return Path(cmds.file(rename=args[0]))

def saveAs(exportPath, **kwargs):
    cmds.file( rename=exportPath )
    kwargs['save']=True
    if 'type' not in kwargs:
        try: kwargs['type'] = _getTypeFromExtension(exportPath)
        except: pass
    return Path(cmds.file(**kwargs) )

#ReferenceCache.setupFileReferenceCallbacks()

#createReference = _factories.makecreateflagCmd( 'createReference', cmds.file, 'reference', __name__, returnFunc=FileReference )
#loadReference = _factories.makecreateflagCmd( 'loadReference', cmds.file, 'loadReference',  __name__, returnFunc=FileReference )
#exportAnim = _factories.makecreateflagCmd( 'exportAnim', cmds.file, 'exportAnim',  __name__, returnFunc=Path )
#exportAnimFromReference = _factories.makecreateflagCmd( 'exportAnimFromReference', cmds.file, 'exportAnimFromReference',  __name__, returnFunc=Path )
#exportSelectedAnim = _factories.makecreateflagCmd( 'exportSelectedAnim', cmds.file, 'exportSelectedAnim',  __name__, returnFunc=Path )
#exportSelectedAnimFromReference = _factories.makecreateflagCmd( 'exportSelectedAnimFromReference', cmds.file, 'exportSelectedAnimFromReference', __name__,  returnFunc=Path )
#importFile = _factories.makecreateflagCmd( 'importFile', cmds.file, 'i',  __name__, returnFunc=Path )
#newFile = _factories.makecreateflagCmd( 'newFile', cmds.file, 'newFile',  __name__, returnFunc=Path )
#openFile = _factories.makecreateflagCmd( 'openFile', cmds.file, 'open',  __name__, returnFunc=Path )
#renameFile = _factories.makecreateflagCmd( 'renameFile', cmds.file, 'rename',  __name__, returnFunc=Path )

_factories.createFunctions( __name__ )
